<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[存储过程]]></title>
    <url>%2F2019%2F07%2F30%2Fcunchu%2F</url>
    <content type="text"><![CDATA[存储过程定义存储过程（Stored Procedure）是在大型数据库系统中，一组为了完成特定功能的SQL 语句集，它存储在数据库中，一次编译后永久有效，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。存储过程是数据库中的一个重要对象。 存储过程格式CREATE PROCEDURE [拥有者.]存储过程名[;程序编号][(参数#1,…参数#1024)][WITH{RECOMPILE | ENCRYPTION | RECOMPILE, ENCRYPTION}] [FOR REPLICATION]AS 程序行其中存储过程名不能超过128个字。每个存储过程中最多设定1024个参数例子 12345678CREATE PROCEDURE order_tot_amt@o_id int,@p_tot int outputASSELECT @p_tot = sum(Unitprice*Quantity)FROM orderdetailsWHERE orderid=@o_idGO 该例子是建立一个简单的存储过程order_tot_amt,这个存储过程根据用户输入的订单ID号码(@o_id),由订单明细表 (orderdetails)中计算该订单销售总额[单价(Unitprice)*数量(Quantity)],这一金额通过@p_tot这一参数输出给调用这一存储过程的程序。 功能这类语言主要提供以下功能，让用户可以设计出符合应用需求的程序：1)、变量说明2)、ANSI（美国国家标准化组织）兼容的SQL命令(如Select,Update….)3)、一般流程控制命令(if…else…、while….)4)、内部函数 种类系统存储过程以sp_开头,用来进行系统的各项设定.取得信息.相关管理工作。 本地存储过程用户创建的存储过程是由用户创建并完成某一特定功能的存储过程，事实上一般所说的存储过程就是指本地存储过程。 临时存储过程分为两种存储过程：一是本地临时存储过程，以井字号(#)作为其名称的第一个字符，则该存储过程将成为一个存放在tempdb数据库中的本地临时存储过程，且只有创建它的用户才能执行它;二是全局临时存储过程，以两个井字号(##)号开始，则该存储过程将成为一个存储在tempdb数据库中的全局临时存储过程，全局临时存储过程一旦创建，以后连接到服务器的任意用户都可以执行它，而且不需要特定的权限。 远程存储过程在SQL Server2005中，远程存储过程(Remote Stored Procedures)是位于远程服务器上的存储过程，通常可以使用分布式查询和EXECUTE命令执行一个远程存储过程。 扩展存储过程扩展存储过程(Extended Stored Procedures)是用户可以使用外部程序语言编写的存储过程，而且扩展存储过程的名称通常以xp_开头。 基本语法调用存储过程1.基本语法：exec sp_name [参数名] 删除存储过程drop procedure sp_name不能在一个存储过程中删除另一个存储过程，只能调用另一个存储过程 其他常用命令show procedure status 显示数据库中所有存储的存储过程基本信息，包括所属数据库，存储过程名称，创建时间等show create procedure sp_name 显示某一个mysql存储过程的详细信息exec sp_helptext sp_name 显示你这个sp_name这个对象创建文本 存储过程的优缺点优点①重复使用。存储过程可以重复使用，从而可以减少数据库开发人员的工作量。②减少网络流量。存储过程位于服务器上，调用的时候只需要传递存储过程的名称以及参数就可以了，因此降低了网络传输的数据量。③安全性。参数化的存储过程可以防止SQL注入式攻击，而且可以将Grant、Deny以及Revoke权限应用于存储过程。 缺点1：调试麻烦，但是用 PL/SQL Developer 调试很方便！弥补这个缺点。2：移植问题，数据库端代码当然是与数据库相关的。但是如果是做工程型项目，基本不存在移植问题。3：重新编译问题，因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存储过程、包将需要重新编译（不过也可以设置成运行时刻自动编译）。4：如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，接着就是系统的相关问题了，最后如果用户想维护该系统可以说是很难很难、而且代价是空前的，维护起来更麻烦。 实例数据库存储过程数据库存储过程的实质就是部署在数据库端的一组定义代码以及SQL。将常用的或很复杂的工作，预先用SQL语句写好并用一个指定的名称存储起来，那么以后要叫数据库提供与已定义好的存储过程的功能相同的服务时，只需调用execute，即可自动完成命令。利用SQL的语言可以编写对于数据库访问的存储过程，其语法如下：CREATE PROC[EDURE] procedure_name [;number][{@parameter data_type} ][VARYING] [= default] [OUTPUT]] [,…n][WITH{ RECOMPILE| ENCRYPTION| RECOMPILE, ENCRYPTION} ][FOR REPLICATION]ASsql_statement […n][ ]内的内容是可选项，而（）内的内容是必选项，例：若用户想建立一个删除表tmp中的记录的存储过程Select_delete可写为： 12Create Proc select_del AsDelete tmp 例：用户想查询tmp表中某年的数据的存储过程 12create proc select_query @year int asselect * from tmp where year=@year 在这里@year是存储过程的参数 Oracle中的存储过程1.创建过程与其它的数据库系统一样，Oracle的存储过程是用PL/SQL语言编写的能完成一定处理功能的存储在数据库字典中的程序。语法:create [or replace] procedure procedure_name[ (argment [ { in| in out }] type,argment [ { in | out | in out } ] type{ is | as }&lt;类型.变量的说明&gt;(注:不用 declare语句 )Begin&lt;执行部分&gt;exception&lt;可选的异常处理说明&gt;end;1.1 这里的IN表示向存储过程传递参数，OUT表示从存储过程返回参数。而IN OUT 表示传递参数和返回参数；1.2 在存储过程内的参数只能指定参数类型；不能指定长度；1.3 在AS或IS 后声明要用到的变量名称和变量类型及长度；1.4 在AS或IS 后声明变量不要加declare 语句。2.使用过程存储过程建立完成后，只要通过授权，用户就可以在SQLPLUS 、Oracle开发工具或第三方开发工具来调用运行。Oracle 使用CALL 语句来实现对存储过程的调用。语法：call procedure_name( parameter1, parameter2…);3.开发过程如今的几大数据库厂商提供的编写存储过程的工具都没有统一，虽然它们的编写风格有些相似，但由于没有标准，所以各家的开发调试过程也不一样。下面编写PL/SQL存储过程、函数、包及触发器的步骤如下：3.1 编辑存储过程源码使用文字编辑处理软件编辑存储过程源码，要用类似WORD文字处理软件进行编辑时，要将源码存为文本格式。3.2 对存储过程程序进行解释在SQLPLUS或用调试工具将 存储过程程序进行解释；在SQL&gt;下调试，可用start 或get 等Oracle命令来启动解释。如：SQL&gt;start c:\stat1.sql如果使用调试工具，可直接编辑和点击相应的按钮即可生成存储过程。 [1]3.3 调试源码直到正确我们不能保证所写的存储过程达到一次就正确。所以这里的调试是每个程序员必须进行的工作之一。在SQLPLUS下来调试主要用的方法是：1．使用 SHOW ERROR命令来提示源码的错误位置；2．使用 USER_ERRORS数据字典来查看各存储过程的错误位置。3.4 授权执行权给相关的用户或角色如果调试正确的存储过程没有进行授权，那就只有建立者本人才可以运行。所以作为应用系统的一部分的存储过程也必须进行授权才能达到要求。 在SQLPLUS下可以用GRANT命令来进行存储过程的运行授权。语法： 12GRANT system_privilege | role TO user | role | PUBLIC[WITH ADMIN OPTION] 或 12GRANT object_privilege | ALL column ON schema.objectTO user | role | PUBLIC WITH GRANT OPTION 其中system_privilege: 系统权限role: 角色名user: 被授权的用户名object_privilege: 所授予的权限名字，可以是ALTERDELETEEXECUTEINDEXINSERTREFERENCESSELECTUPDATEColumn: 列名schema: 模式名object: 对象名4.数据字典USER_SOURCE 用户的存储过程、函数的源代码字典DBA_SOURCE 整个系统所有用户的存储过程、函数的源代码字典ALL_SOURCE 当前用户能使用的存储过程(包括其她用户授权)、函数的源代码字典USER_ERRORS 用户的存储过程、函数的源代码存在错误的信息字典临时表（针对SQL2000/2005）可以创建本地和全局临时表。本地临时表仅在当前会话中可见；全局临时表在所有会话中都可见。本地临时表的名称前面有一个编号符 (#table_name)，而全局临时表的名称前面有两个编号符 (##table_name)。SQL 语句使用 CREATE TABLE 语句中为 table_name 指定的名称引用临时表：CREATE TABLE #MyTempTable (cola INT PRIMARY KEY)INSERT INTO #MyTempTable VALUES (1)如果本地临时表由存储过程创建或由多个用户同时执行的应用程序创建，则 SQL Server 必须能够区分由不同用户创建的表。为此，SQL Server 在内部为每个本地临时表的表名追加一个数字后缀。存储在 tempdb 数据库的 sysobjects 表中的临时表，其全名由 CREATE TABLE 语句中指定的表名和系统生成的数字后缀组成。为了允许追加后缀，为本地临时表指定的表名 table_name 不能超过 116 个字符。除非使用 DROP TABLE 语句显式除去临时表，否则临时表将在退出其作用域时由系统自动除去：当存储过程完成时，将自动除去在存储过程中创建的本地临时表。由创建表的存储过程执行的所有嵌套存储过程都可以引用此表。但调用创建此表的存储过程的进程无法引用此表。所有其它本地临时表在当前会话结束时自动除去。全局临时表在创建此表的会话结束且其它任务停止对其引用时自动除去。任务与表之间的关联只在单个 Transact-SQL 语句的生存周期内保持。换言之，当创建全局临时表的会话结束时，最后一条引用此表的 Transact-SQL 语句完成后，将自动除去此表。 存储过程的创建与查看创建存储过程可以通过DMS或MySQL客户端登录到RDS， 创建存储过程。示例代码如下： 12345678910DROP PROCEDURE IF EXISTS TEST_PROC;DELIMITER //CREATE PROCEDURE TEST_PROC(IN ID int,OUT NAME VARCHAR(50))BEGINIF(ID = 1) THEN SET NAME = ‘test1’;END IF;IF(ID = 2) THEN SET NAME = ‘test2’;END IF;SELECT version();END //; 查看存储过程在RDS for MySQL中，有两种方法查看数据库中的存储过程：通过系统表查询登录到数据库中，执行如下命令： 1select * from mysql.proc where db=’‘ and type=’procedure’ order by name; 查看存储过程通过show status查询登录到数据库中，执行如下命令： 12show procedure status;show create procedure \G;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>存储过程</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux集群环境]]></title>
    <url>%2F2019%2F07%2F03%2Fjava02%2F</url>
    <content type="text"><![CDATA[修改IP为静态IP修改配置文件 cd /etc/sysconfig/network-scripts进入网络配置目录dir ifcfg*找到网卡配置文件ifcfg-ens33找到版本最新的文件并修改vim ifcfg-ens33 配置文件内容 12345678910TYPE=EthernetBOOTPROTO=static #改成static，针对NATNAME=eno16777736UUID=4cc9c89b-cf9e-4847-b9ea-ac713baf4cc8DEVICE=eno16777736DNS1=114.114.114.114 #和网关相同ONBOOT=yes #开机启动此网卡IPADDR=192.168.65.161 #固定IP地址192.168.65(网段).***NETMASK=255.255.255.0 #子网掩码GATEWAY=192.168.65.2 #网关和NAT自动配置的相同，不同则无法登录 重启网络 12service network restart #重启网络systemctl restart network.service #重启网络centos7 查看IP 1ip addr #查看IP地址 ip add 关闭防火墙systemctl stop firewalld.service关闭防火墙服务systemctl disable firewalld.service禁止防火墙开启启动systemctl restart iptables.service重启防火墙使配置生效systemctl enable iptables.service设置防火墙开机启动firewall-cmd --state检查防火墙状态yum install -y lrzsz下载安装上传文件插件 修改主机名vim /etc/hostname删掉原内容,修改为想要的主机名 Hostname为内核属性需要重启才能生效，不想重启可以定义临时主机名 hostname hadoop01(主机名)设置临时主机名hostname查看主机名 修改host文件vi /etc/hosts ** **删掉原来所有内容，改为以下 123456127.0.0.1 localhost::1 localhost#（集群主机IP） （主机名）192.168.47.161 hadoop01192.168.47.162 hadoop02192.168.47.163 hadoop03 设置免密登录每台都执行以下操作ssh-keygen然后三次直接回车不输入任何内容得到秘钥后执行：ssh-copy-id root@hadoop01 #(主机名)hadoop02、hadoop03（本机也要发） 测试ssh hadoop02 #随意一个其他主机名不需要输入密码直接进入说明成功，exit退出 安装JDK在用户目录 ~ 中编辑go文件 1234vim go#编辑内容为cd /usr/local/src#保存后执行 . go即可到达指定目录 /usr/local/src下创建目录java——mkdir java 上传安装包并解压 tar -zxvf jdk-8u65-linux-x64.tar.gz解压JDK scp -r java/ root@hadoop02（主机名）:/usr/local/src发送给集群其他主机 修改环境变量vim /etc/profile 文档最后添加 123456#set java environmentJAVA_HOME=/usr/local/src/java/jdk1.8.0_65 #jdk路径JAVA_BIN=/usr/local/src/java/jdk1.8.0_65/bin #jdk下bin路径PATH=$JAVA_HOME/bin:$PATHCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport JAVA_HOME JAVA_BIN PATH CLASSPATH source /etc/profile加载环境变量 测试java -version scp /etc/profile root@hadoop02（主机名）:/etc发送给集群其他主机]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[六大设计原则]]></title>
    <url>%2F2019%2F07%2F01%2Fliudayuanze%2F</url>
    <content type="text"><![CDATA[单一职责原则（SPR）单一职责的原则定义是：应该有且仅有一个原因引起类的变更 单一职责原则要求一个接口或类只有一个原因引起变化，也就是一个接口或类只有一个职责，他就负责一件事情 单一职责原则的好处1.类的复杂性降低，实现什么职责都有清晰明确的定义 2.可读性提高，可维护性提高，复杂性降低 3.变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对应的实现类有影响，对其他接口无影响，这对系统的扩展性、维护性都有非常大的帮助 单一职责的使用单一原则提出了一个编写程序的标准，用“职责”或“变化原因”来衡量接口或类设计得是否优良，但是“职责”和“变化原因”都是不可度量的，因项目而异，因环境而异。 对于单一职责原则，接口一定要做到单一职责，类的设计尽可能做到单一职责 里式替换原则（LSP）继承的优缺点继承的优点1.代码共享，减少创造类的工作量，每个子类都有父类的方法和属性 2.提高代码的重用性 3.子类保存父类的共性，同时拥有自己的特性 4.提高代码可扩展性，实现父类的方法就可以“为所欲为”了，市场上大多开源框架的扩展接口都是通过继承父类实现 5.提高产品或项目的开放性 继承的缺点1.只要继承就必须拥有父类所有的属性和方法 2.降低代码的灵活性，子类必须拥有父类的所有属性和方法，让子类多了些约束 3.增强了耦合性，当父类的常量、变量和方法被修改时，必须要考虑子类的修改，而且在缺乏规范的环境下，可能会需要重构大片的代码 里式替换原则定义如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都替换成o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型 所有引用基类的地方必须能透明的使用期子类的对象 通俗来讲就是只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本不需要知道是父类还是子类。但是，反过来就不行了，有子类出现的地方，父类未必就能适应。 里式替换原则的含义子类必须完全实现父类的方法以FPS类游戏为例，描述一下里面用到的枪：枪的主要职责是射击，如何射击在各个具体子类定义枪支的抽象类 1234public abstract class AbstractGun &#123; //枪用来干什么的？杀敌！ public abstract void shoot(); &#125; 手枪、步枪、机枪的实现类 1234567891011121314151617181920public class Handgun extends AbstractGun &#123; //手枪的特点是携带方便，射程短 @Override public void shoot() &#123; System.out.println("手枪射击..."); &#125; &#125; public class Rifle extends AbstractGun&#123; //步枪的特点是射程远，威力大 @Override public void shoot()&#123; System.out.println("步枪射击..."); &#125; &#125; public class MachineGun extends AbstractGun&#123; @Override public void shoot()&#123; System.out.println("机枪扫射..."); &#125; &#125; 士兵的实现类 123456789101112public class Soldier &#123; //定义士兵的枪支 private AbstractGun gun; //给士兵一支枪 public void setGun(AbstractGun _gun)&#123; this.gun = _gun; &#125; public void killEnemy()&#123; System.out.println("士兵开始杀敌人..."); gun.shoot(); &#125; &#125; 测试类 123456789public class Client &#123; public static void main(String[] args) &#123; //产生三毛这个士兵 Soldier sanMao = new Soldier(); //给三毛一支枪 sanMao.setGun(new Rifle()); sanMao.killEnemy(); &#125; &#125; 运行结果 12士兵开始杀敌人...步枪射击... 如果要使用机枪可以直接把sanMao.setGun(new Rifle());改为sanMao.setGun(new MachineGun());即可，在编写程序时士兵类根本不需要知道是哪个子类(枪)被传入 注意 在类中调用其他类时务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了LSP原则如果子类不能完整的实现父类方法，或者某些父类方法在子类中发生“畸变”，则建议断开继承关系，采用依赖、聚集、组合等关系代替继承 子类可以有自己的特性子类可以有自己的方法和属性，LSP可以正着用，但是不能反过来用，在子类出现的地方，父类未必可以使用。还是以FPS游戏为例，步枪可分为AK47、AUG狙击步枪等，把这两把枪引入之后的子类图：AUG狙击步枪类 123456789public class AUG extends Rifle &#123; //狙击枪都携带一个精准的望远镜 public void zoomOut()&#123; System.out.println("通过望远镜察看敌人..."); &#125; public void shoot()&#123; System.out.println("AUG射击..."); &#125; &#125; 狙击手类 12345678public class Snipper &#123; public void killEnemy(AUG aug)&#123; //首先看看敌人的情况，别杀死敌人，自己也被人干掉 aug.zoomOut(); //开始射击 aug.shoot(); &#125; &#125; 测试类 12345678public class Client &#123; public static void main(String[] args) &#123; //产生三毛这个狙击手 Snipper sanMao = new Snipper(); sanMao.setRifle(new AUG()); sanMao.killEnemy(); &#125; &#125; 运行结果 12通过望远镜察看敌人... AUG射击... 在这里如果换成了父类会在运行期抛出java.lang.ClassCastException异常，也就是向下转型不安全 覆盖或实现父类的方法时输入参数可以被放大里式替换原则要求定制一个契约，就是父类或接口，这种设计方法也叫做Design by Contract（契约设计），与LSP有异曲同工之妙。契约制定了，也就同时制定了前置条件和后置条件，前置条件就是你要让我执行，就必须满足我的条件；后置条件就是我执行完了需要反馈，标准是什么。 子类中方法的前置条件必须与超类中被覆写的方法的前置条件相同或者更宽松 覆盖或实现父类的方法时输出结果可以被缩小父类的一个方法的返回值是一个类型T，子类的相同方法（重载或覆写）的返回值为S，那么里氏替换原则就要求S必须小于等于T，也就是说，要么S和T是同一个类型，要么S是T的子类 覆写，父类和子类的同名方法的输入参数是相同的，两个方法的范围值S小于等于T，这是覆写的要求，这才是重中之重，子类覆写父类的方法，天经地义。 重载，则要求方法的输入参数类型或数量不相同，在里氏替换原则要求下，就是子类的输入参数宽于或等于父类的输入参数，也就是说你写的这个方法是不会被调用的。 LSP的最佳使用在项目中，采用里氏替换原则时，尽量避免子类的“个性”，一旦子类有“个性”，这个子类和父类之间的关系就很难调和了，把子类当做父类使用，子类的“个性”被抹杀——委屈了点；把子类单独作为一个业务来使用，则会让代码间的耦合关系变得扑朔迷离——缺乏类替换的标准。 依赖倒置原则（DIP）依赖倒置原则定义1.高层模块不应该依赖低层模块，两者都应该依赖其抽象 2.抽象不应该依赖细节 3.细节应该依赖抽象 不可分割的原子逻辑就是低层模块，原子逻辑再组装的就是高层模块抽象就是指接口或抽象类，两者都是不能直接被实例化的细节就是实现类，实现接口或继承抽象类而生成的类就是细节，其特点是可以直接实例化，可以直接new一个对象。 依赖倒置原则在Java中的表现1.模块间的依赖通过抽象发生，实现类之间不发生之间的依赖关系，其依赖关系是通过接口或抽象类产生的 2.接口或抽象类不依赖于实现类 3.实现类依赖接口或抽象类 总而言之就是“面向接口编程”——OOD的精髓之一 依赖倒置原则的优点1.减少类间的耦合性 2.提高系统的稳定性 3.降低并行开发引起的风险 4.提高代码的可读性和可维护性 依赖的三种写法1.构造函数传递依赖对象 2.Setter方法传递依赖对象 3.接口声明依赖对象 接口隔离原则接口实例接口，在java中声明一个类，然后用new关键字产生一个实例，它是对一个类型的事物的描述，也是一种接口 类接口，java中用interface关键字定义的接口 接口隔离原则的定义1.客户端不应该依赖它不需要的接口 2.类间的依赖关系应该建立在最小的接口上 建立单一接口，不要建立臃肿庞大的接口，通俗来讲就是接口尽量细化，同时接口中的方法尽量少 接口隔离原则的4层含义1.接口要尽量小不出现臃肿的接口，在拆分之前首先得保证它遵守单一职责原则 2.接口要高内聚高内聚就是提高接口、类、模块的处理能力，减少对外的交互。应用到接口隔离原则就是在接口中尽量少公布public方法，接口是对外的承诺，承诺越少对系统开发越有利，变更的风险也就越少 3.定制服务一个系统或系统内的模块之间必然会有耦合，有耦合就要有相互访问的接口（并不一定就是Java中定义的Interface，也可能是一个类或单纯的数据交换），我们设计时就需要为各个访问者（即客户端）定制服务定制服务就是单独为一个个体提供优良的服务。我们在做系统设计时也需要考虑对系统之间或模块之间的接口采用定制服务。采用定制服务就必然有一个要求：只提供访问者需要的方法。 4.接口设计是有限度的接口设计粒度越小，系统越灵活 接口隔离原则最佳使用一个接口只服务于一个子模块或业务逻辑 通过业务逻辑压缩接口中的public方法，接口时常去回顾，尽量让接口达到“满身筋骨肉”，而不是“肥嘟嘟”的一大堆方法 已经被污染了的接口，尽量去修改，若变更的风险较大，则采用适配器模式进行转化处理 了解环境，拒绝盲从。每个项目或产品都有特定的环境因素，别看到大师是这样做的你就照抄。千万别，环境不同，接口拆分的标准就不同。深入了解业务逻辑，最好的接口设计就出自你的手中！ 迪米特法则（LoD）也被称为最少知识原则（LKP） 也被称为最少知识原则 一个对象应该对其他对象有最少的了解。通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少，你（被耦合或调用的类）的内部是如何复杂都和我没关系，那是你的事情，我就知道你提供的这么多public方法，我就调用这么多，其他的我一概不关心。 迪米特法则的4层含义1.只和朋友交流 两个对象之间的耦合就会成为朋友关系朋友类的定义：出现在成员变量、方法的输入输出参数中的类称为成员朋友类，而出现在方法体内部的类不属于朋友类 2.朋友间也是有距离的 一个类公开的public属性或方法越多，修改时涉及到的面越广，变更引起的风险扩散也就越大。因此为了保持朋友类间的距离，在设计时需要反复衡量，是否可以修改为private、package-private（包类型，不加访问权限时默认为包类型）、protected等访问权限，是否可以加上final关键字等。迪米特法则要求类尽量不要对外公布太多的public方法和非静态的public变量，尽量多使用private、package-private、protected等访问权限 3.是自己的就是自己的 如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，那就放置在本类中。 4.谨慎使用Serializable 迪米特法则的最佳使用迪米特法则的核心观念就是类间解耦，弱耦合，只有弱耦合了以后，类的复用率在可以提高。其要求的结果就是产生了大量的中转或跳转类，导致系统的复杂性提高，同时也为维护带来了难度。在采用迪米特法则时，需要反复权衡，既做到让结构清晰，又做到高内聚低耦合 开闭原则开闭原则的定义一个软件实体如类、模块、函数应该对外扩展开放，对修改类关闭也就是说，一个软件实体应该通过扩展来实现变化，而不是通过修改已有代码来实现变化。 软件实体项目或软件产品中按照一定的逻辑规则划分的模块抽象和类方法 开闭原则对扩展开放，对修改关闭，并不意味着不做任何修改，低层模块的变更，必然要有高层模块进行耦合，否则就是一个孤立无意义的代码片段 开闭原则的好处1.开闭原则对测试的影响 2.开闭原则可以提高复用性 3.开闭原则可以提高可维护性 4.面向对象开发的要求 如何使用开闭原则1.抽象约束抽象是对一组事物的通用描述，没有具体的实现，也就表示它可以有非常多的可能性，可以跟随需求的变化而变化。因此，通过接口或抽象类可以约束一组可能变化的行为，并且能够实现对扩展开放。 2.元数据（metadata）控制模块行为元数据就是用来描述环境和数据的数据，通俗来说就是配置参数 3.制定项目章程章程中指定了所有人员必须遵守的约定，对项目来说，约定优于配置。 4.封装变化对变化的封装包含两层含义：第一，将相同的变化封装到一个接口或抽象类中。第二，将不同变化封装到不同的接口或抽象类中，不应该有两个不同的变化出现在同一接口或抽象类中。封装变化也就是封装可能发生的变化]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的算法思想——2]]></title>
    <url>%2F2019%2F06%2F29%2Fsuanfan002%2F</url>
    <content type="text"><![CDATA[贪心算法贪心算法也被成为“贪婪算法”，它在求解问题时总想用当前看来是最好的方法来实现。这种算法不从整体最优上考虑问题，仅仅是在某种意义上的局部最优求解。 贪心算法基础贪心算法从问题的某一个初始解出发，逐步逼近给定的目标，以便尽快求出更好的解。当达到算法中的某一步不能再继续前进时就停止算法，给出一个近似解。 贪心算法的问题1.不能保证最后的解是最优解 2.不能用来求最大或最小解问题 3.只能求满足某些约束条件的可行解的范围 贪心算法的基本思路1.建立数学模型来描述问题 2.把求解的问题分成若干个子问题 3.对每一个子问题求解，得到子问题的局部最优解 4.把子问题的局部最优解合并成原来问题的一个解 实现过程1.从问题的某一初始解出发 2.while能向给定总目标前进一步 3.求出可行解的一个解元素 4.由所有解元素组合成问题的一个可行解 案例“装箱”问题假设有编号分别为0,1…，n-1的n种物品，体积分别为V0,V1…，Vn-1。将这n种物品装到容量都为V的若干箱子里，约定这n种物品体积都不超过V，即对于0&lt;=i&lt;n,有0&lt;V1&lt;=V。不同的装箱方案所需要箱子可能不同。装箱问题要求用最少的箱子装下这n种物品 算法分析]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2019%2F06%2F29%2Fshejimoshi%2F</url>
    <content type="text"><![CDATA[单例模式确保一个类只有一个实例，并提供该实例的全局访问点 使用一个私有构造函数、一个私有静态变量以及一个公有静态函数来实现。 私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。 懒汉式——线程不安全1234567891011121314public class Singleton &#123; private static Singleton uniqueInstance; private Singleton() &#123; &#125; public static Singleton getUniqueInstance() &#123; if (uniqueInstance == null) &#123; uniqueInstance = new Singleton(); &#125; return uniqueInstance; &#125;&#125; 私有静态变量 uniqueInstance 被延迟实例化，这样做的好处是，如果没有用到该类，那么就不会实例化 uniqueInstance，从而节约资源。 这个实现在多线程环境下是不安全的，如果多个线程能够同时进入 if (uniqueInstance == null) ，并且此时 uniqueInstance 为 null，那么会有多个线程执行 uniqueInstance = new Singleton(); 语句，这将导致实例化多次 uniqueInstance。 饿汉式——线程安全线程不安全问题主要是由于 uniqueInstance 被实例化多次，采取直接实例化 uniqueInstance 的方式就不会产生线程不安全问题。 但是直接实例化的方式也丢失了延迟实例化带来的节约资源的好处。 1private static Singleton uniqueInstance = new Singleton(); 懒汉式——线程安全123456public static synchronized Singleton getUniqueInstance() &#123; if (uniqueInstance == null) &#123; uniqueInstance = new Singleton(); &#125; return uniqueInstance;&#125; 只需要对 getUniqueInstance() 方法加锁，那么在一个时间点只能有一个线程能够进入该方法，从而避免了实例化多次 uniqueInstance。 但是当一个线程进入该方法之后，其它试图进入该方法的线程都必须等待，即使 uniqueInstance 已经被实例化了。这会让线程阻塞时间过长，因此该方法有性能问题，不推荐使用。 双重锁——线程安全123456789101112131415161718public class Singleton &#123; private volatile static Singleton uniqueInstance; private Singleton() &#123; &#125; public static Singleton getUniqueInstance() &#123; if (uniqueInstance == null) &#123; synchronized (Singleton.class) &#123; if (uniqueInstance == null) &#123; uniqueInstance = new Singleton(); &#125; &#125; &#125; return uniqueInstance; &#125;&#125; uniqueInstance 只需要被实例化一次，之后就可以直接使用了。加锁操作只需要对实例化那部分的代码进行，只有当 uniqueInstance 没有被实例化时，才需要进行加锁。 双重校验锁先判断 uniqueInstance 是否已经被实例化，如果没有被实例化，那么才对实例化语句进行加锁。 静态内部类实现当 Singleton 类被加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 getUniqueInstance() 方法从而触发 SingletonHolder.INSTANCE 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。 这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。 12345678910111213public class Singleton &#123; private Singleton() &#123; &#125; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; public static Singleton getUniqueInstance() &#123; return SingletonHolder.INSTANCE; &#125;&#125; 枚举实现123456789101112131415161718192021222324252627282930313233343536373839public enum Singleton &#123; INSTANCE; private String objName; public String getObjName() &#123; return objName; &#125; public void setObjName(String objName) &#123; this.objName = objName; &#125; public static void main(String[] args) &#123; // 单例测试 Singleton firstSingleton = Singleton.INSTANCE; firstSingleton.setObjName("firstName"); System.out.println(firstSingleton.getObjName()); Singleton secondSingleton = Singleton.INSTANCE; secondSingleton.setObjName("secondName"); System.out.println(firstSingleton.getObjName()); System.out.println(secondSingleton.getObjName()); // 反射获取实例测试 try &#123; Singleton[] enumConstants = Singleton.class.getEnumConstants(); for (Singleton enumConstant : enumConstants) &#123; System.out.println(enumConstant.getObjName()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 该实现可以防止反射攻击。在其它实现中，通过 setAccessible() 方法可以将私有构造函数的访问级别设置为 public，然后调用构造函数从而实例化对象，如果要防止这种攻击，需要在构造函数中添加防止多次实例化的代码。该实现是由 JVM 保证只会实例化一次，因此不会出现上述的反射攻击。 该实现在多次序列化和序列化之后，不会得到多个实例。而其它实现需要使用 transient 修饰所有字段，并且实现序列化和反序列化的方法。 测试结果： 1234firstNamesecondNamesecondNamesecondName 简单工厂模式在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。 简单工厂把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化。 这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类。客户类往往有多个，如果不使用简单工厂，那么所有的客户类都要知道所有子类的细节。而且一旦子类发生改变，例如增加子类，那么所有的客户类都要进行修改。 工厂方法定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。 在简单工厂中，创建对象的是另一个类，而在工厂方法中，是由子类来创建对象。 抽象工厂提供一个接口，用于创建相关的对象家族。 抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同。 抽象工厂模式用到了工厂方法模式来创建单一对象，AbstractFactory 中的 createProductA() 和 createProductB() 方法都是让子类来实现，这两个方法单独来看就是在创建一个对象，这符合工厂方法模式的定义。 至于创建对象的家族这一概念是在 Client 体现，Client 要通过 AbstractFactory 同时调用两个方法来创建出两个对象，在这里这两个对象就有很大的相关性，Client 需要同时创建出这两个对象。 从高层次来看，抽象工厂使用了组合，即 Cilent 组合了 AbstractFactory，而工厂方法模式使用了继承。 工厂模式小demo（https://github.com/51461/factory ） 代理模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用密令]]></title>
    <url>%2F2019%2F06%2F29%2Fgit%2F</url>
    <content type="text"><![CDATA[新建本地代码库git init 在当前目录下新建一个git代码库 git init [project-name] 新建一个目录，将其初始化为Git代码库 git clone[url] 下载一个项目和它的整个代码历史 配置# 显示当前的Git配置git config --list # 编辑Git配置文件git config -e [--global] # 设置提交代码时的用户信息git config [--global] user.name “[name]”git config [--global] user.email “[email address]” 生成ssh密钥ssh-keygen -t rsa -C “[email address]” 增加/删除文件git add[file1][file2]… 添加指定文件到暂存区 git add . 添加当前目录的所有文件到暂存区 git add -p 添加每个变化前，都会要求确认对于同一个文件的多处变化，可以实现分次提交 git rm [file1] [file2] … 删除工作区文件，并且将这次删除放入暂存区 git rm --cached [file] 停止追踪指定文件，但该文件会保留在工作区 git mv [file-original] [file-renamed] 更改文件名，并且将这个改名放入暂存区 代码提交git commit -m[message] 提交暂存区到仓库区 git commit [file1][file2]… -m[message] 提交暂存区的指定文件到仓库区 $ git commit -a 提交工作区自上次commit之后的变化，直接到仓库区 git commit -v 提交时显示所有diff信息 git commit --amend -m [message] 使用一次新的commit，替代上一次提交,如果代码没有任何新变化，则用来改写上一次commit的提交信息 git commit --amend [file1] [file2] … 重做上一次commit，并包括指定文件的新变化 分支git branch 列出所有本地分支git branch -r 列出远程所有分支git branch -a 列出所有本地分支和远程分支git branch [branch-name] 新建一个分支但依然停留在当前分支git checkout -b [branch] 新建一个分支并切换到该分支git checkout [branch-name] 切换到指定分支并更新工作区git checkout -b [branch] 新建一个分支并切换到该分支git branch [branch] [commit] 新建一个分支，指向指定commitgit branch --track [branch] [remote-branch] 新建一个分支，与指定的远程分支建立追踪关系git checkout [branch-name] 切换到指定分支，并更新工作区git checkout - 切换到上一个分支git branch --set-upstream [branch] [remote-branch] 建立追踪关系，在现有分支与指定的远程分支之间git merge [branch] 合并指定分支到当前分支git cherry-pick [commit] 选择一个commit，合并进当前分支git branch -d[branch-name] 删除分支git push origin --delete [branch-name] 删除远程分支git branch -dr [remote/branch] 删除远程分支 查看信息git status 查看有变更的文件git log 查看当前分支的版本历史git log --stat 显示commit历史，以及每次commit发生变更的文件git log -S [keyword] 搜索提交历史，根据关键词git log [tag] HEAD --pretty=format:%s 显示某个commit之后的所有变动，每个commit占据一行git log [tag] HEAD --grep feature 显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件显示某个文件的版本历史，包括文件改名git log --follow [file]git whatchanged [file]git log -p [file] 显示指定文件相关的每一次diffgit log -5 --pretty --oneline 显示过去5次提交git shortlog -sn 显示所有提交过的用户，按提交次数排序git blame [file] 显示指定文件是什么人在什么时间修改过git diff 显示暂存区和工作区的差异显示暂存区和上一个commit的差异$ git diff --cached [file]显示工作区与当前分支最新commit之间的差异$ git diff HEAD显示两次提交之间的差异$ git diff [first-branch]...[second-branch]显示今天你写了多少行代码$ git diff --shortstat &quot;@{0 day ago}&quot;git show[commit] 显示每次提交的元数据和内容变化git show --name-only [commit] 显示某次提交发生变化的文件git show [commit]:[filename] 显示某次提交时，某个文件的内容git rebase [branch] 从本地master拉取代码更新当前分支branch 一般为master 标签# 列出所有tag$ git tag 新建一个tag在当前commit$ git tag [tag] 新建一个tag在指定commit$ git tag [tag] [commit] 删除本地tag$ git tag -d [tag] 删除远程tag$ git push origin :refs/tags/[tagName]** 查看tag信息$ git show [tag] 提交指定tag$ git push [remote] [tag] 提交所有taggit push [remote] --tags 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 远程同步git pull [remote][branch] 取回远程仓库变化，并与本地分支合并 git push [remote][branch] 上传本地指定的分支到远程仓库 git fetch [remote] 下载远程仓库的所有变动 git remote -v 显示所有远程仓库 显示某个远程仓库的信息$ git remote show [remote] 增加一个新的远程仓库，并命名$ git remote add [shortname] [url] 取回远程仓库的变化，并与本地分支合并$ git pull [remote]\ [branch] 上传本地指定分支到远程仓库$ git push [remote] [branch] 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force 推送所有分支到远程仓库$ git push [remote] --all 撤销恢复暂存区的指定文件到工作区$ git checkout [file] 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file] 恢复暂存区的所有文件到工作区$ git checkout . 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file] 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit] 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit] 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit] 新建一个commit，用来撤销指定commit,后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit] 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop graph列表工具，使用方式：git log --graph gitk可视化工具，直接在gitbase输入gitk即可 git详细介绍： https://git-scm.com/book/zh/v1]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm&GC基础]]></title>
    <url>%2F2019%2F06%2F29%2Fjvm%2F</url>
    <content type="text"><![CDATA[JVM是Java语言可以跨平台、保持高发展的根本，没有了JVM，java语言将失去语言环境 JVMJVM虚拟机栈每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。 可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小java -Xss2M HackTheJava 该区域可能抛出以下异常： 当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常； 栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常 本地方法栈本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。 本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。 堆所有对象都在这里分配内存，是垃圾收集的主要区域（”GC 堆”）。 现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块： 新生代（Young Generation） 老年代（Old Generation） 堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。 可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。 1java -Xms1M -Xmx2M HackTheJava 方法区用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。 对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。 HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。 方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等放入堆中。 运行时常量池运行时常量池是方法区的一部分。 Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。 除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。 直接内存在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。 垃圾回收器Serial GC:JDK1.3.1,串行方式回收，它是单线程的收集器，只会使用一个线程进行垃圾收集工作。它的优点是简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。它是 Client 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。最小化了使用内存和并行开销 Parallel GC：其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器。JDK6之后成为默认GC，最大化应用程序的吞吐量 Concurrent Mark Sweep GC：在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。最小化GC中断或停顿时间 Garbage First：G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。 判断回收算法引用计数算法为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。 在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正是因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。 可达性分析算法以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。 Java 虚拟机使用该算法来判断对象是否可被回收，GC Roots 一般包含以下内容： 虚拟机栈中局部变量表中引用的对象 本地方法栈中 JNI 中引用的对象 方法区中类静态属性引用的对象 方法区中的常量引用的对象 方法区的回收因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。 主要是对常量池的回收和对类的卸载。 为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。 类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载： 该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。 加载该类的 ClassLoader 已经被回收。 该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。 finalize()类似 C++ 的析构函数，用于关闭外部资源。但是 try-finally 等方式可以做得更好，并且该方法运行代价很高，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。 当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会再调用该方法。 引用类型无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。 1.强引用被强引用关联的对象不会被回收。使用 new 一个新对象的方式来创建强引用。 1Object obj = new Object(); 2.软引用被软引用关联的对象只有在内存不够的情况下才会被回收。使用 SoftReference 类来创建软引用。 123Object obj = new Object();SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;(obj);obj = null; // 使对象只被软引用关联 3.弱引用被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。使用 WeakReference 类来创建弱引用。 123Object obj = new Object();WeakReference&lt;Object&gt; wf = new WeakReference&lt;Object&gt;(obj);obj = null; //使对象只被弱引用关联 4.虚引用又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。使用 PhantomReference 来创建虚引用。 123Object obj = new Object();PhantomReference&lt;Object&gt; pf = new PhantomReference&lt;Object&gt;(obj, null);obj = null; //使对象被虚引用关联 垃圾收集算法标记——清除在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。 在清除阶段，会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。回收对象就是把对象作为分块，连接到被称为 “空闲链表” 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。 在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block。如果它找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 (block - size) 的两部分，返回大小为 size 的分块，并把大小为 (block - size) 的块返回给空闲链表。 缺点：- 标记和清除过程效率都不高；- 会产生大量不连续的内存碎片，导致无法给大对象分配内存。 标记——整理让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。 优点: 不会产生内存碎片 缺点: 需要移动大量对象，处理效率比较低 复制将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。 缺点是只使用了内存的一半。 现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。 HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。 分代收集现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。 一般将堆分为新生代和老年代。- 新生代使用：复制算法- 老年代使用：标记 - 清除 或者 标记 - 整理 算法 GC回收器回收过程G1(Garbage First)1. 初始标记2. 并发标记3. 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。4. 筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。 特点：1. 空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。2. 可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。 CMS(Concurrent Mark Sweep GC)1. 初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。2. 并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。3. 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。4. 并发清除：不需要停顿在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。 缺点： 1. 吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。2. 无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。3. 标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。 内存分配与回收策略Minor GC 和 Full GCMinor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多 内存分配策略1.对象优先在 Eden 分配大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。 2.大对象直接进入老年代大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。 经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。 -XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。 3. 长期存活的对象进入老年代为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。 -XX:MaxTenuringThreshold 用来定义年龄的阈值。 4. 动态对象年龄判定虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。 5. 空间分配担保在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。 如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。 Full GC 的触发条件对于 Minor GC，其触发条件非常简单，当Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件： 调用 System.gc()只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。 老年代空间不足老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。 为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。 空间分配担保失败使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。具体内容请参考上面的第 5 小节。 JDK 1.7 及以前的永久代空间不足在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。 当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。 为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。 Concurrent Mode Failure执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。 类加载机制类的生命周期 加载（Loading） 验证（Verification） 准备（Preparation） 解析（Resolution） 初始化（Initialization） 使用（Using） 卸载（Unloading）类的加载过程 包含了加载、验证、准备、解析和初始化这 5 个阶段。 加载加载是类加载的一个阶段，注意不要混淆。 加载过程完成以下三件事： 通过类的完全限定名称获取定义该类的二进制字节流。 将该字节流表示的静态存储结构转换为方法区的运行时存储结构。 在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。 其中二进制字节流可以从以下方式中获取： 从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。 从网络中获取，最典型的应用是 Applet。 运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。 由其他文件生成，例如由 JSP 文件生成对应的 Class 类。 验证确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 准备类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。 实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。 解析将常量池的符号引用替换为直接引用的过程。 其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。 初始化初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行类构造器 () 方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。 类初始化时机主动引用时必须初始化，被动引用不会触动初始化 主动引用 遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类； 当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化； 被动引用 通过子类引用父类的静态字段，不会导致子类初始化。 1System.out.println(SubClass.value); // value 字段在 SuperClass 中定义 通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。 1SuperClass[] sca = new SuperClass[10]; 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。 1System.out.println(ConstClass.HELLOWORLD); 类加载器分类从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器： 启动类加载器（Bootstrap ClassLoader），使用 C++ 实现，是虚拟机自身的一部分； 所有其它类的加载器，使用 Java 实现，独立于虚拟机，继承自抽象类 java.lang.ClassLoader。 从 Java 开发人员的角度看，类加载器可以划分得更细致一些： 启动类加载器（Bootstrap ClassLoader）此类加载器负责将存放在 \lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。 扩展类加载器（Extension ClassLoader）这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 /lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。 应用程序类加载器（Application ClassLoader）这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 双亲委派模型该模型要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。这里的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）。 过程一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。 好处使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。 实现以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass() 方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出 ClassNotFoundException，此时尝试自己去加载。 1234567891011121314151617181920212223242526272829303132333435363738394041public abstract class ClassLoader &#123; // The parent class loader for delegation private final ClassLoader parent; public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123; return loadClass(name, false); &#125; protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; synchronized (getClassLoadingLock(name)) &#123; // First, check if the class has already been loaded Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; try &#123; if (parent != null) &#123; c = parent.loadClass(name, false); &#125; else &#123; c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; // If still not found, then invoke findClass in order // to find the class. c = findClass(name); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125; &#125; protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; throw new ClassNotFoundException(name); &#125;&#125; 自定义类加载器以下代码中的 FileSystemClassLoader 是自定义类加载器，继承自 java.lang.ClassLoader，用于加载文件系统上的类。它首先根据类的全名在文件系统上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 defineClass() 方法来把这些字节代码转换成 java.lang.Class 类的实例。 java.lang.ClassLoader 的 loadClass() 实现了双亲委派模型的逻辑，自定义类加载器一般不去重写它，但是需要重写 findClass() 方法。 12345678910111213141516171819202122232425262728293031323334353637383940public class FileSystemClassLoader extends ClassLoader &#123; private String rootDir; public FileSystemClassLoader(String rootDir) &#123; this.rootDir = rootDir; &#125; protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; byte[] classData = getClassData(name); if (classData == null) &#123; throw new ClassNotFoundException(); &#125; else &#123; return defineClass(name, classData, 0, classData.length); &#125; &#125; private byte[] getClassData(String className) &#123; String path = classNameToPath(className); try &#123; InputStream ins = new FileInputStream(path); ByteArrayOutputStream baos = new ByteArrayOutputStream(); int bufferSize = 4096; byte[] buffer = new byte[bufferSize]; int bytesNumRead; while ((bytesNumRead = ins.read(buffer)) != -1) &#123; baos.write(buffer, 0, bytesNumRead); &#125; return baos.toByteArray(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125; private String classNameToPath(String className) &#123; return rootDir + File.separatorChar + className.replace('.', File.separatorChar) + ".class"; &#125;&#125; 摘自https://cyc2018.github.io/CS-Notes/#/notes/Java%20虚拟机]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[注册中心——zookeeper]]></title>
    <url>%2F2019%2F06%2F26%2Fzookeeper%2F</url>
    <content type="text"><![CDATA[zookeeper的介绍ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。 ZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。 ZooKeeper包含一个简单的原语集， 提供Java和C的接口。 ZooKeeper代码版本中，提供了分布式独享锁、选举、队列的接口，代码在zookeeper-3.4.3\src\recipes。其中分布锁和队列有Java和C两个版本，选举只有Java版本。 总结:zookeeper是服务的协调调度服务器!!! zookeeper的安装使用zookeeper的下载网址: http://zookeeper.apache.org/releases.html.*http://mirrors.hust.edu.cn/apache/zookeeper/ * zookeeper的安装安装JDK将JDK1.8文件上传到Linux操作系统中/src/usr/local/java/文件下. 1.解压文件tar -xvf jdk-8u51-linux-x64.tar.gz 2.配置环境变量编辑环境变量配置文件vim /etc/profile 使JDK生效,之后检查jdk安装是否成功source /etc/profile 上传安装文件说明:上传zookeeper安装文件.之后解压.解压目录:tar -xvf zookeeper-3.4.8.tar.gz 在zk根目录下创建文件夹data/logmkdir data log 复制配置文件并且修改名称cp zoo_sample.cfg zoo.cfg 修改配置文件dataDir，dataLogDir为新建data/log路径 启动zookeeperzk启动关闭命令如下. 123sh zkServer.sh start 或者 ./zkServer.sh startsh zkServer.sh stopsh zkServer.sh status zookeeper集群准备文件夹在zookeeper根目录中创建新的文件夹zkCluster. 在zkCluster下创建zk1/zk2/zk3文件夹.在每个文件夹里创建data/log文件夹.mkdir {zk1,zk2,zk3}/{data,log} 添加myid文件分别在zk1/zk2/zk3中的data文件夹中创建新的文件myid.其中的内容依次为1/2/3,与zk节点号对应.编辑myid文件,定义编号. 编辑配置文件将zoo_sample.cfg 复制为zoo1.cfg之后修改配置文件. 修改zoo1.cfg 配置完成后将zoo1.cfg复制2份.之后需要修改对应的文件夹目录.和不同的端口即可. zookeeper集群测试通过下面的命令启动zk集群.sh zkServer.sh start zoo1.cfg 启动sh zkServer.sh stop zoo1.cfg 停止sh zkServer.sh status zoo1.cfg 查看状态 检查主从关系,从机情况说明. Zookeeper集群中leader负责监控集群状态,follower主要负责客户端链接获取服务列表信息.同时参与投票. dubbo控制台dubbo控制台是监控服务的.修改dubbo的配置文件信息.改为zkIP地址和端口 修改配置文件信息 123dubbo.registry.address=zookeeper://192.168.175.126:2181(ip:端口)?backup=192.168.175.126:2182,192.168.175.126:2183dubbo.admin.root.password=rootdubbo.admin.guest.password=guest 控制台展现用户名和密码都是root 登录之后进入控制台. dubbo提供者配置文件1234567891011121314151617181920212223242526server: port: 9000spring: datasource: #引入druid数据源 type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/jtdb?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;allowMultiQueries=true username: root password: root#Springboot整合dubbo dubbo: scan: basePackages: com.compent #包扫描dubbo的service注解 application: name: provider-user #提供者服务名称 registry: #链接zookeeper address: zookeeper://192.168.175.126:2181?backup=192.168.175.126:2182,192.168.175.126:2183 protocol: name: dubbo port: 20880 #服务通信端口 消费者链接提供者端口mybatis-plus: type-aliases-package: com.jt.dubbo.pojo #配置别名包路径 mapper-locations: classpath:/mybatis/mappers/*.xml #添加mapper映射文件 configuration: map-underscore-to-camel-case: true #开启驼峰映射规则 dubbo消费者配置文件123456789server: port: 9001dubbo: scan: basePackages: com.compent application: name: consumer-user #服务名称&quot;唯一&quot; registry: address: zookeeper://192.168.175.126:2181?backup=192.168.175.126:2182,192.168.175.126:2183 dubbo小demo（https://github.com/51461/dubbo-demo/ ）]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis常用命令]]></title>
    <url>%2F2019%2F06%2F24%2Fredis02%2F</url>
    <content type="text"><![CDATA[String类型 命令 说明 案例 set 添加key-value set username admin get 根据key获取数据 get username strlen 获取key的长度 strlen key exists 判断key是否存在 exists name 返回1存在 0不存在 del 删除redis中的key del key Keys 用于查询符合条件的key keys * 查询redis中全部的keykeys n?me 使用占位符获取数据keys nam* 获取nam开头的数据 mset 赋值多个key-value mset key1 value1 key2 value2 key3 value3 mget 获取多个key的值 mget key1 key2 append 对某个key的值进行追加 append key value type 检查某个key的类型 type key select 切换redis数据库 select 0-15 redis中共有16个数据库 flushdb 清空单个数据库 flushdb flushall 清空全部数据库 flushall incr 自动加1 incr key decr 自动减1 decr key incrby 指定数值添加 incrby 10 decrby 指定数值减 decrby 10 expire 指定key的生效时间 单位秒 expire key 20 key20秒后失效 pexpire 指定key的失效时间 单位毫秒 pexpire key 2000key 2000毫秒后失效 ttl 检查key的剩余存活时间 ttl key persist 撤销key的失效时间 persist key Hash类型说明:可以用散列类型保存对象和属性值例子:User对象{id:2,name:小明,age:19} 命令 说明 案例 hset 为对象添加数据 hset key field value hget 获取对象的属性值 hget key field hexists 判断对象的属性是否存在 HEXISTS key field1表示存在 0表示不存在 hdel 删除hash中的属性 hdel user field [field …] hgetall 获取hash全部元素和值 HGETALL key hkyes 获取hash中的所有字段 HKEYS key hlen 获取hash中所有属性的数量 hlen key hmget 获取hash里面指定字段的值 hmget key field [field …] hmset 为hash的多个字段设定值 hmset key field value [field value …] hsetnx 设置hash的一个字段,只有当这个字段不存在时有效 HSETNX key field value hstrlen 获取hash中指定key的长度 HSTRLEN key field hvals 获取hash的所有值 HVALS user List类型说明:Redis中的List集合是双端循环列表,分别可以从左右两个方向插入数据.List集合可以当做队列使用,也可以当做栈使用存入数据的方向和获取数据的方向相反存入数据的方向和获取数据的方向相同 命令 说明 案例 lpush 从队列的左边入队一个或多个元素 LPUSH key value [value …] rpush 从队列的右边入队一个或多个元素 RPUSH key value [value …] lpop 从队列的左端出队一个元素 LPOP key rpop 从队列的右端出队一个元素 RPOP key lpushx 当队列存在时从队列的左侧入队一个元素 LPUSHX key value rpushx 当队列存在时从队列的右侧入队一个元素 RPUSHx key value lrange 从列表中获取指定返回的元素 LRANGE key start stop Lrange key 0 -1 获取全部队列的数据 lrem 从存于 key 的列表里移除前 count 次出现的值为 value 的元素。 这个 count 参数通过下面几种方式影响这个操作：· count &gt; 0: 从头往尾移除值为 value 的元素。· count &lt; 0: 从尾往头移除值为 value 的元素。· count = 0: 移除所有值为 value 的元素。 LREM list -2 “hello” 会从存于 list 的列表里移除最后两个出现的 “hello”。需要注意的是，如果list里没有存在key就会被当作空list处理，所以当 key 不存在的时候，这个命令会返回 0。 Lset 设置 index 位置的list元素的值为 value LSET key index value 事务命令说明:redis中操作可以添加事务的支持.一项任务可以由多个redis命令完成,如果有一个命令失败导致入库失败时.需要实现事务回滚. 命令 说明 案例 multi 标记一个事务开始 127.0.0.1:6379&gt; MULTIOK exec 执行所有multi之后发的命令 127.0.0.1:6379&gt; EXEC OK discard 丢弃所有multi之后发的命令]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>redis</tag>
        <tag>指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis]]></title>
    <url>%2F2019%2F06%2F24%2Fredis%2F</url>
    <content type="text"><![CDATA[Redis介绍Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。 Redis性能读:11.2万/秒写:8.6万/秒平均: 10万/秒 吞吐量 Redis安装和使用安装redis要求:命令的执行值redis的根目录中运行. 命令:​ 1.make 表示编译文件​ 2.make install 表示安装redis服务. 修改配置文件vim redis.conf 去除IP绑定#bind 127.0.0.1（69行左右） 关闭保护模式protected-mode no(88行左右) 开启后台启动daemonize yes(136行左右) VIM常见报错报错演示： 报错原因:在vim编辑状态下.程序异常外退出导致Linux程序启动保护模式.导致异常. 解决方案:1. 根据选项 点击 D2. 利用删除指令 直接删除临时文件 rm –rf .xxxxxx.swap Redis运行命令启动命令Redis-server 忽略 一切加载都是默认项Redis-server redis.conf 目的读取配置文件 进入客户端redis-cli –p 6379(端口号)exit 退出客户端ctrl + c 退出简化:如果Redis默认的端口号为6379则命令可以简化redis-cli Redis关闭redis-cli –p 6379（端口号） shutdownkill -9 PID PID2redis-cli shutdown 简化命令 Redis入门案例linux防火墙操作密令连接虚拟机Redis要确保虚拟机防火墙关闭1 关闭防火墙—–service iptables stop2 启动防火墙—–service iptables start3 重启防火墙—–service iptables restart4 查看防火墙状态——service iptables status5 永久关闭防火墙——chkconfig iptables off6 永久关闭后启用——chkconfig iptables on 添加jar包文件123456789101112&lt;!-- jedis --&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;$&#123;jedis.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--添加spring-datajar包 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt; &lt;version&gt;1.4.1.RELEASE&lt;/version&gt;&lt;/dependency&gt; 入门案例——String1234567891011121314/** * 连接单台redis * 参数介绍: * redisIP地址. * redis:6379 */@Testpublic void test01()&#123; Jedis jedis = new Jedis("192.168.126.166",6379); jedis.set("redis", "redis入门案例"); System.out.println("获取redis中的数据:"+jedis.get("redis")); //为数据设定超时时间 单位秒 jedis.setex("1804", 100, "1804班");&#125; 入门案例——hash12345678910@Testpublic void test01()&#123; Jedis jedis = new Jedis("192.168.126.148", 6379); jedis.hset("user", "id", "1"); jedis.hset("user", "name", "tomcat"); jedis.hset("user", "age", "18"); System.out.println("操作完成!!!"+jedis.hget("user", "id")); Map&lt;String,String&gt; map = jedis.hgetAll("user"); System.out.println(map);&#125; 入门案例——List12345678@Testpublic void test02()&#123; Jedis jedis = new Jedis("192.168.126.148", 6379); Long number = jedis.lpush("list", "a","b","c","d","e"); System.out.println("获取数据"+number); List&lt;String&gt; list= jedis.lrange("list", 0, -1); System.out.println("获取参数:"+list);&#125; SpringBoot整合Redis导入jar包123456789&lt;!--spring整合redis --&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 入门案例123456789//String类型操作方式 配置文件3处 防火墙//IP:端口号@Testpublic void testString() &#123; Jedis jedis = new Jedis("192.168.175.129",6379); jedis.set("1902","1902班"); jedis.expire("1902", 10); System.out.println(jedis.get("1902")); &#125; 超时时间定时123456789101112//设定数据的超时方法//分布式锁!!!!!@Testpublic void testTimeOut() throws InterruptedException &#123; Jedis jedis = new Jedis("192.168.175.129",6379); jedis.setex("aa", 2, "aa"); System.out.println(jedis.get("aa")); Thread.sleep(3000); //当key不存在时操作正常.当key存在时,则操作失败 Long result = jedis.setnx("aa","bb"); System.out.println("获取输出数据:"+result+":"+jedis.get("aa"));&#125; 对象转化JSON转化说明利用ObjectMapper实现对象的转化. 12345ObjectMapper mapper = new ObjectMapper();//对象转化为JSONString json串 = mapper.writeValueAsString(对象);//JSON转化为对象对象 T = mapper.readValue(json, 对象.class); 对象与JSON互转123456789101112131415161718192021/** * 3.利用Redis保存业务数据 数据库 * 数据库数据: 对象 Object * String类型要求只能存储字符串类型 * item ~~~ JSON ~~~ 字符串 */@Testpublic void objectToJSON() throws IOException &#123; ItemDesc itemDesc = new ItemDesc(); itemDesc.setItemId(1000L) .setItemDesc("测试方法") .setCreated(new Date()) .setUpdated(new Date()); ObjectMapper mapper = new ObjectMapper(); //转化JSON时必须 get/set方法 String json =mapper.writeValueAsString(itemDesc); System.out.println(json); //将json串转化为对象 ItemDesc desc2 = mapper.readValue(json, ItemDesc.class); System.out.println("测试对象:"+desc2);&#125; List与JSON互转12345678910111213141516171819202122//实现List集合与JSON转化@SuppressWarnings("unused")@Testpublic void listTOJSON() throws IOException &#123; ItemDesc itemDesc1 = new ItemDesc(); itemDesc1.setItemId(1000L).setItemDesc("测试方法"); ItemDesc itemDesc2 = new ItemDesc(); itemDesc2.setItemId(1000L).setItemDesc("测试方法"); List&lt;ItemDesc&gt; list = new ArrayList&lt;ItemDesc&gt;(); list.add(itemDesc1); list.add(itemDesc2); ObjectMapper mapper = new ObjectMapper(); String json = mapper.writeValueAsString(list); System.out.println("集合转化为JSON"+json); //将数据保存到redis中 Jedis jedis = new Jedis("192.168.175.129",6379); jedis.set("itemDescList", json); //从redis中获取数据 String result = jedis.get("itemDescList"); List&lt;ItemDesc&gt; descList = mapper.readValue(result,list.getClass()); System.out.println(descList);&#125; 编辑pro文件jedis.host=192.168.175.129jedis.port=6379 编辑配置类12345678910111213//表示redis配置类@Configuration@PropertySource("classpath:/properties/redis.properties")public class RedisConfig &#123; @Value("$&#123;jedis.host&#125;") private String host; @Value("$&#123;jedis.port&#125;") private Integer port; @Bean public Jedis jedis() &#123; return new Jedis(host, port); &#125;&#125; 设定虚拟机静态IP检查当前IP 检查网关地址 配置静态IP Redis分片机制Redis单台问题1. 使用redis单台时内存会明显不足.如果一味的扩容内存,则运行的效率低.2. 如果redis单台服务器宕机. Redis分片（分区）介绍核心特点:实现了redis内存的扩容.说明:使用多个redis节点,共同为用户提供服务.内存空间翻倍.​ 用户使用时当做一个整体.并且内存保存的数据不一. 分片搭建创建新文件在Redis根目录下创建一个新的文件夹 复制配置文件复制配置文件到新建的文件夹里[root@localhost redis-5.0.4]# cp redis.conf shards/redis-6379.conf[root@localhost redis-5.0.4]# cp redis.conf shards/redis-6380.conf[root@localhost redis-5.0.4]# cp redis.conf shards/redis-6381.conf 修改端口号可以使用:/port快速定位数据将6380.conf中端口号改为6380.同理 修改其他配置文件 启动多台Redis启动Redisredis-server redis-6379.confredis-server redis-6380.confredis-server redis-6381.conf 检查redis服务ps -ef | grep redis Redis分片测试入门案例1234567891011121314151617/** * 操作时需要将多台redis当做1台使用. */@Testpublic void testShards() &#123; List&lt;JedisShardInfo&gt; shards = new ArrayList&lt;JedisShardInfo&gt;(); JedisShardInfo info1 = new JedisShardInfo("192.168.175.129",6379); JedisShardInfo info2 = new JedisShardInfo("192.168.175.129",6380); JedisShardInfo info3 = new JedisShardInfo("192.168.175.129",6381); shards.add(info1); shards.add(info2); shards.add(info3); //操作分片 redis对象工具类 ShardedJedis shardedJedis = new ShardedJedis(shards); shardedJedis.set("1902","1902班"); System.out.println(shardedJedis.get("1902"));&#125; Hash一致性算法概念概念:同一个字符串hash值是一致的. Hash一致性说明 Hash一致性——特性问题说明因为所有节点都是通过ip地址加算法计算获取的,则可能会出现节点分配不均的问题.导致数据丢失. 均衡性说明:均衡性要求节点中的数据尽可能的平均.措施:引入虚拟节点概念 单调性说明:当节点新增时,能够实现数据的自动的迁移.补充说明:如果节点一旦丢失,则导致内存丢失则整个分片无法使用. 分散性概念:由于分布式原因,导致系统不能获取全部的内存空间.导致一个key有多个位置. 负载概念:由于分布式原因,系统不能获取全部的内存地址.导致同一个位置保存多个数据 Spring整合Redis分片编辑properties文件redis.nodes=ip:端口，ip:端口，……redis.nodes=192.168.175.129:6379,192.168.175.129:6380,192.168.175.129:6381 编辑配置类1234567891011121314151617181920//表示redis配置类@Configuration@PropertySource("classpath:/properties/redis.properties")public class RedisConfig &#123; @Value("$&#123;redis.nodes&#125;") private String redisNodes; //node1,node2,node3 @Bean public ShardedJedis shardedJedis() &#123; List&lt;JedisShardInfo&gt; shards = new ArrayList&lt;&gt;(); //ip:端口,ip:端口 String[] nodes = redisNodes.split(","); for (String node : nodes) &#123; String host = node.split(":")[0]; int port = Integer.parseInt(node.split(":")[1]); JedisShardInfo info = new JedisShardInfo(host, port); shards.add(info); &#125; return new ShardedJedis(shards); &#125;&#125; Redis持久化策略说明Redis中的数据都在内存中,如果断电宕机则内存数据丢失.其中数据应该持久化保存.不允许丢失.持久化策略:1. RDB模式2. AOF模式 Redis持久化工作原理说明:按照配置的时间,定期将内存数据保存到redis中的持久化文件中.当redis服务器宕机之后重启时,首先读取指定的持久化文件,恢复内存数据,方便用户使用. RDB模式概念:​ RDB模式是Redis中默认的持久化策略.保存的是redis的内存快照。占用的资源少.持久化效率最高的.RDB特点:​ 1.RDB模式能够定期持久化,但是有丢失数据的风险.​ 2.Redis中默认的持久化策略​ 3.RDB模式做内存的快照. 效率高​ 4.占用磁盘空间较小. RDB模式配置1. 修改持久化文件名称2.持久化文件目录设定3.持久化策略save 900 1 用户在900秒内做1次set操作时持久化1次save 300 10 用户在300秒内做10次set草时持久化1次save 60 10000 60秒内做10000次set 持久化一次 使用save持久化化时,如果执行持久化操作,则程序陷入阻塞.用户不能执行set. AOF模式特点:1. AOF模式可以实现数据的实时持久化.2. 记录的是用户的操作过程.3. 持久化文件会比较大.4. 持久化效率低.5. AOF模式默认是关闭的6. AOF模式持久化是异步的. AOF模式持久化策略1.开启AOF模式2.修改持久化文件名称3.持久化策略# appendfsync always 只要用户执行”更新”命令则持久化一次appendfsync everysec 每秒持久化一次.# appendfsync no 由默认的操作系统决定什么时候持久化. Redis缓存策略说明1. 如果有并发查询时.如果缓存服务器宕机/缓存失效.则查询数据库.可能导致数据库宕机. 俗称缓存雪崩2. 如果用户,高并发查询一个不存在的数据时.后台数据库有宕机的风险，俗称缓存穿透限流 直至封杀IP地址. IP模拟器3. 如果高并发条件下.当某一个热点的key,超时或者失效时.数据库有宕机的风险.俗称:缓存击穿 Redis内存机制业务需求Redis中的数据都保存内存中.内存中的数据如果一味的新增,不删除则内存数据很快存满.导致新的数据保存错误.需求:用户每次都能存储数据,但是内存大小是可控的.要求动态维护内存大小. Redis中内存策略LRU算法内存管理的一种页面置换算法，对于在内存中但又不用的数据块（内存块）叫做LRU，操作系统会根据哪些数据属于LRU而将其移出内存而腾出空间来加载另外的数据。 LFU算法LFU（least frequently used (LFU) page-replacement algorithm）。即最不经常使用页置换算法，要求在页置换时置换引用计数最小的页，因为经常使用的页应该有一个较大的引用次数。但是有些页在开始时使用次数很多，但以后就不再使用，这类页将会长时间留在内存中，因此可以将引用计数寄存器定时右移一位，形成指数衰减的平均使用次数。 LFU:根据数据使用的次数多少删除数据. 内存优化策略1. volatile-lru设定超时时间的数据采用LRU算法删除数据.2. allkeys-lru所有的数据采用LRU算法删除数据3. volatile-lfu设定了超时时间的数据采用LFU删除数据4. allkeys-lfu所有的数据采用LFU算法删除数据5. volatile-random设定了超时时间的随机删除6. allkeys-random所有key随机删除7. volatile-ttl设定了超时时间的数据排序.将马上要超时的数据提前删除.8. Noeviction不删除数据.如果内存数据存满则报错返回. 该策略是默认策略 Redis主从同步高可用介绍(HA)“高可用性”（High Availability）通常来描述一个系统经过专门的设计，从而减少停工时间，而保持其服务的高度可用性。概括:利用技术手段实现了当服务器宕机,自动的实现故障的迁移. 业务说明Redis的最终形态必须实现高可用,实现高可用的前提必须满足主从同步.当发生故障,由于从机与主机的数据是相同的,所以可以非常灵活实现数据的故障迁移. 主从同步搭建复制文件说明:将分片文件夹shards复制为sentinel.（shards文件参考上方分片）cp –r shards sentinel 检查主从关系进入Redis-6379客户端，输入info replication 实现主从挂载说明:6379当主机, 6380/6381当从机.命令:在客户端中cli端 执行指令 ** **saveof IP 端口 挂载情况 主从测试 当在6379中写入数据时,从机80/81也同步了数据. 主从同步持久性问题说明:通过slaveof指令可以指定主从关系.如果从机关闭之后重启问情况如何??回答:​ 当6381重启之后,发现主从结构不存在了.6381变为主机.如何解决该问题:​ 需求:当6381为从机时,当重启服务器依然是从机.​ 需要人为的动态修改redis.conf配置文件. Redis哨兵实现高可用Redis中哨兵的作用分片作用:redis分片实现了redis内存扩容.Redis哨兵:主要实现了redis节点的高可用. Redis哨兵实现步骤1. redis哨兵会监听redis主节点.目的1:检查主节点是否存活目的2:获取连接主节点的从机. IP:端口2. 当利用ping-pong检测机制.检查主节点是否存活,当哨兵连续3次检测都没有数据返回.则表明主节点宕机.3. 哨兵根据从主节点获取的从节点信息,进行推选.从中挑选一台新的从节点当做现在的主节点.将新的主从关系写入其他节点的redis.conf文件中.4. 当服务器重启后,能够了解当前主从关系,实现了redis高可用. Redis哨兵配置复制哨兵配置文件cp sentinel.conf sentinel/ 编辑sentinel配置文件1. 关闭保护模式 17行 2.开启哨兵后台启动 26行 3.修改哨兵监控 84行sentinel monitor mymaster 127.0.0.1 6379 1mymaster:当前主机的变量IP:端口: redis主节点的IP和端口投票生效票数: ** **规则:超半数即可,哨兵的数量是奇数. 4.主机宕机后多久进行推选. 5.修改哨兵推选失败超时时间. Redis哨兵测试1. 启动redis哨兵redis-sentinel sentinel.conf 2. 当关闭redis-6379之后等10秒之后.检查主从结构是否正确. Spring整合哨兵入门案例1234567891011121314//测试哨兵get/set操作@Testpublic void test01() &#123; //masterName 代表主机的变量名称 //sentinels Set&lt;String&gt; IP:端口 Set&lt;String&gt; sentinels = new HashSet&lt;&gt;(); sentinels.add("192.168.175.129:26379"); JedisSentinelPool sentinelPool = new JedisSentinelPool("mymaster", sentinels); Jedis jedis = sentinelPool.getResource(); jedis.set("z", "dd"); System.out.println(jedis.get("z")); jedis.close(); //关闭链接&#125; Spring整合哨兵思路1. 利用配置类,封装JedisSentinelPool.2. 利用工具API封装2个方法.set/get 编辑pro文件redis.sentinels=192.168.175.129:26379redis.sentinel.masterName=mymaster 编辑配置类123456789101112131415//表示redis配置类@Configuration //xml@PropertySource("classpath:/properties/redis.properties")public class RedisConfig &#123; @Value("$&#123;redis.sentinels&#125;") private String jedisSentinelNodes; @Value("$&#123;redis.sentinel.masterName&#125;") private String masterName; @Bean public JedisSentinelPool jedisSentinelPool() &#123; Set&lt;String&gt; sentinels = new HashSet&lt;&gt;(); sentinels.add(jedisSentinelNodes); return new JedisSentinelPool(masterName, sentinels); &#125;&#125; 编辑工具API12345678910111213141516171819202122@Servicepublic class RedisService &#123; @Autowired(required = false)//调用时才注入 private JedisSentinelPool sentinelPool; //封装方法 get public String get(String key) &#123; Jedis jedis = sentinelPool.getResource(); String result = jedis.get(key); jedis.close(); return result; &#125; public void set(String key,String value) &#123; Jedis jedis = sentinelPool.getResource(); jedis.set(key, value); jedis.close(); &#125; public void setex(String key,int seconds,String value) &#123; Jedis jedis = sentinelPool.getResource(); jedis.setex(key, seconds, value); jedis.close(); &#125;&#125; 编辑RedisAOP配置项 项目测试说明:重启tomcat服务器.检查程序调用是否正确.当redis节点宕机时.检查是否影响用户操作redis. Redis集群背景1. Redis分片用户通过API利用hash一致性算法,实现了数据存储.利用分片机制实现了内存的扩容!!!缺点:如果一个节点宕机.,则违反单调性要求,分片失效.2. Redis哨兵哨兵基于心跳检测机制.实现redis节点高可用.但是前提必须配置主从.哨兵缺点:1. 操作的redis依然是单台,内存无法扩容.2. Redis哨兵也有可能宕机. 分片:没有高可用效果.哨兵:哨兵本身没有高可用需要借助第三方. 内存没有扩容. Redis集群介绍说明:搭建redis集群可以实现redis分片和哨兵的全部功能!!!.Redis集群中所有的主节点参与选举.redis集群中全部的节点都能互相通信.所有的节点都有投票权(发现某个节点宕机投票数+1) 集群搭建集群设计最小的集群单位3个主节点,从机不做要求,搭建策略一主一从主机3台​ 端口:7000/7001/7002从机3台​ 端口:7003/7004/7005 准备集群文件1.准备集群文件夹 redis根目录下Mkdir cluster 2.在cluster文件夹中分别创建7000-7005文件夹mkdir 7000 7001 7002 7003 7004 7005 复制配置文件说明:将redis根目录中的redis.conf文件复制到cluster/7000/ 并以原名保存cp redis.conf cluster/7000/ 编辑配置文件1. 注释本地绑定IP地址 2.关闭保护模式 3.修改端口号 4. 启动后台启动 5. 修改pid文件 6. 修改持久化文件路径 7. 设定内存优化策略 8. 关闭AOF模式 9. 开启集群配置 10. 开启集群配置文件，保存集群中的状态信息.谁是主机,谁是从机 11. 修改集群超时时间 复制修改后的配置文件说明:将7000文件夹下的redis.conf文件分别复制到7001-7005中 12345[root@localhost cluster]# cp 7000/redis.conf 7001/[root@localhost cluster]# cp 7000/redis.conf 7002/[root@localhost cluster]# cp 7000/redis.conf 7003/[root@localhost cluster]# cp 7000/redis.conf 7004/[root@localhost cluster]# cp 7000/redis.conf 7005/ 批量修改说明:分别将7001-7005文件中的7000改为对应的端口号的名称,修改时注意方向键的使用 通过脚本编辑启动/关闭命令1. 创建启动脚本 vim start.sh 2.编辑关闭的脚本 vim shutdown.sh 3.启动redis节点sh start.sh 4.检查redis节点启动是否正常 ps ef | grep redis 创建redis集群#5.0版本执行 使用C语言内部管理集群redis-cli --cluster create --cluster-replicas 1 192.168.35.130:7000 192.168.35.130:7001 192.168.35.130:7002 192.168.35.130:7003 192.168.35.130:7004 192.168.35.130:7005 Redis高可用测试1. 关闭redis主机.检查是否自动实现故障迁移.2. 再次启动关闭的主机.检查是否能够实现自动的挂载.一般情况下 能够实现主从挂载个别情况: 宕机后的节点重启,可能挂载到其他主节点中(7001-7002) 正确的 Redis集群工作原理数据存储原理分片数据存储原理: 根据hash一致性算法实现数据存储.Hash一致性运算发生在服务器端.在存储数据前已经计算完成存储到哪台redis服务器中.分片中存在的问题:*​ 分片的数据是用户通过服务器程序计算进行存储.用户也可以利用redis的客户端进行非法的操作.修改分片中的数据!!! * 集群中数据存储：1.当在从节点中存储数据时.不允许操作,只有主节点能够set/get数据。2.Redis集群与分片明显不同.存储数据必须满足条件. Redis集群储存条件：说明:redis集群一共有16384个槽位.这些操作会均匀的分配给主节点.当数据进行存取时首先根据key进行计算.计算槽位的位置.之后从节点中获取数据.Crc16算法 Redis集群宕机条件宕机条件:Redis集群宕机的条件是主节点宕机则集群奔溃例子:9个redis节点 3主6从 节点宕机多少次集群奔溃5-7台集群奔溃条件说明:Redis集群中当节点宕机后,由主节点进行推选.如果当前节点没有从节点时.从其他主节点中借用多余的从节点 SpringBoot整合Redis集群测试案例12345678910111213@Testpublic void test01() &#123; Set&lt;HostAndPort&gt; sets = new HashSet&lt;&gt;(); sets.add(new HostAndPort("192.168.175.129",7000)); sets.add(new HostAndPort("192.168.175.129",7001)); sets.add(new HostAndPort("192.168.175.129",7002)); sets.add(new HostAndPort("192.168.175.129",7003)); sets.add(new HostAndPort("192.168.175.129",7004)); sets.add(new HostAndPort("192.168.175.129",7005)); JedisCluster cluster = new JedisCluster(sets); cluster.set("1902", "集群搭建完成"); System.out.println("获取集群数据:"+cluster.get("1902"));&#125; 编辑pro文件redis.nodes=192.168.175.129:7000,192.168.175.129:7001,192.168.175.129:7002,192.168.175.129:7003,192.168.175.129:7004,192.168.175.129:7005 编辑配置类1234567891011121314151617181920212223//表示redis配置类@Configuration //xml@PropertySource("classpath:/properties/redis.properties")public class RedisConfig &#123;//redis.nodes=192.168.175.129:7000,192.168.175.129:7001,192.168.175.129:7002,192.168.175.129:7003,192.168.175.129:7004,192.168.175.129:7005 @Value("$&#123;redis.nodes&#125;") private String redisNodes; @Bean public JedisCluster jedisCluster() &#123; Set&lt;HostAndPort&gt; nodes = new HashSet&lt;&gt;(); //1.根据,号拆分为多个node String[] strNode = redisNodes.split(","); //IP:端口 for (String node : strNode) &#123; String host = node.split(":")[0]; int port = Integer.parseInt(node.split(":")[1]); HostAndPort hostAndPort = new HostAndPort(host, port); nodes.add(hostAndPort); &#125; return new JedisCluster(nodes); &#125;&#125; 修改AOP切面]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务基础]]></title>
    <url>%2F2019%2F06%2F24%2Fweifuwu%2F</url>
    <content type="text"><![CDATA[微服务架构背景从软件开发之初，业界一直致力于寻找大型分布式应用系统开发的“银弹”从结构化编程、面向对象，到COBRA、EJB、ESB、SOA等。Fread Brooks在《没有银弹：软件工程的本质性与附属性工作》一文中提出：大型分布式系统具有复杂性、隐匿性、配合性和易变性四大难题，不会存在任何单一软件工程上的突破，能够让开发生产力得到一个数量上的提升。而微服务的出现虽然不是一颗“银弹”，但它给出了四大难题的对策，解决了以往单体架构系统构建的困境 单体架构的困境Java开发中一个单体架构应用就是将一个应用中的所有功能都打包到一个war文件中，并部署到服务器（Tomcat）中运行 对于单体架构来说，随着业务的扩张，其开发、部署和运维都会越来越慢，越来越复杂，甚至在单体架构应用开发中敏捷模式都无法施展开。 在单体架构中，一个应用承载的职责太多，其开发、部署运维复杂度都会呈几何形增长，应用的每次编译和启动都需要更长的时间，每次需要修改、增加新功能时都需要更多的协调和测试。而对于新功能，每次修正bug都会使系统的代码更加复杂，使开发——编译——启动——测试进入了一种恶性循环，大大降低了开发效率。 单体架构应用逐渐变得不稳定，一方面是因为系统不断增长的复杂性造成的，另一方面是由于系统本身牵一发而动全身的特性造成的，可能一个不常用的模块因为存在内存泄漏而造成整个服务器无法正常提供服务，甚至引起服务崩溃 在数据管理上单体架构应用容易产生漏洞，最常见的就是数据管理。单体架构往往要管理的数据类型/表都非常多，而且分布在不同团队之间，如果沟通不好可能某些团队的开发会直接操纵数据库表，最常见的就是在数据层通过写SQL语句操作数据表。这种做法相当于埋下了定时炸弹，当数据相关团队修改了数据库结构，由于之前团队之间使用SQL语句进行处理，程序在系统编译、打包和测试时都有可能通过，但当在真实的生产环境使用时就有可能造成服务的崩溃 单体架构的应用开发时要求我们必须使用同一个技术栈，使得单体架构应用很难接受或切换到其他框架、语言。因为重写风险太大，即使有更合适的开发框架或语言，甚至应用使用的框架有了新版本，也很难进行升级 单体架构应用开发对于开发者来说，需要了解更多的东西，如系统架构、统一的开发模式、与之交互的相关模块等，造成了一个新加入的开发者需要更长的时间才能够进入开发状态 最后，单体架构应用还有一个显著的问题：多名开发者同时修改一个代码库。一方面需要开发者自己快速提交修改的代码，另一方面开发者每次提交修改都要祈求代码不要发生冲突这也造成了代码库很难快速进入稳定可发布状态 在部署上，单体架构应用还会造成系统难以进行水平扩展，因为每一个应用实例对服务器来说都需要相同的硬件配置，这让服务器无法充分发挥其能力，造成浪费，并且部署的服务速度会随着代码积累逐渐变慢，性能降低 微服务架构微服务架构中的服务和模块化开发很相似，单服务是有明确服务边界的，所以更易于开发和管控，同时也更易于单独部署和扩展模块化开发是在大型开发、复杂应用中常用的开发方式，大型应用的开发往往是一个人无法掌控全局的，通过模块化的方式将应用分解成多个具有关联的模块，并交由不同开发团队来完成。模块之间的调用直接使用接口，依赖关系则是可以使用Maven等工具进行管理 微服务架构的定义微服务架构可以说是一种将功能分解成一系列服务的一种架构模式。对于一个应用系统包含两部分的需求：第一部分是功能需求，用于定义一个应用是用来做什么的，该应用系统用来达到什么目的。第二部分是非功能需求，包括了对应用系统的扩展性、灵活性，还有性能、运维、安全、测试、监控等需求，这种非功能性需求是用来保障业务系统能够正确、顺畅的运行。而对于微服务来说，更侧重于第二种需求 微服务从结构上来看就是将一个应用拆分成多个松耦合的服务，这些服务之间通过某种协议（REST、RPC等）进行互相协作，完成单元体架构下的业务功能，但提供更灵活的部署模式，更容易扩展，降低了开发、运维上的复杂度。 微服务的核心思路就是分而治之 服务是一个可以独立运行、提供范围有限的功能(可以是业务功能，也可以是非业务功能)的组件。功能具体实现隐藏在组件内部，而对外提供访问接口，外部其他服务可以通过这些接口进行访问交互 微服务架构的优点松耦合：基于微服务架构的应用是一系列小服务的集合，这些服务之间通过非具体实现的接口及非专有通信协议进行通信(比如REST)，这样只要原接口没有变，就不会对服务消费者造成任何影响 抽象：一个微服务对其数据结构和数据源有绝对的控制权，只有该服务才可以对数据进行修改，其他微服务只有通过该服务才能够访问数据。因此该服务可以很方便的对所能提供的数据进行有效控制 独立：每个微服务都可以在不影响其他微服务的情况下进行编译、打包和部署，这是单体架构应用无法做到的 多样性：微服务架构可以让我们轻松应对不同客户的特殊需求，通过定义良好的接口，可以让不同的微服务承担不同的职责，同时快速部署上线能力可以让用户需求尽早实现 更高可用性和弹性：微服务架构可以认为是一个去中心化的应用，每一个微服务都可以随时上线下线。这样当某个微服务出现问题时只需要将其下线即可，其他同类型的微服务将承担其功能，对外仍旧可以提供服务，不会造成整个服务器无法正常工作。 微服务项目工程代码少，不会造成IDE速度变慢，开发和调试速度也会非常有效率。微服务架构不会要求我们在一个应用中选用同一个技术栈，每个服务可以根据应用特性、开发人员特长选择合适的开发语言和框架。因为微服务足够小，非常容易重构或重写，同时在重构或重写时可以选择合适的开发语言和框架，而且一旦有更适合的技术也可以在低风险的情况下对应用进行升级或改造，而不至于影响整个应该。通过微服务架构可以为我们带来开发、运维、升级上的灵活性 因为每个服务都可以独立进行部署，开发人员可以很快对自己所开发的服务做出变更，而不会影响其他服务，也不会受其他服务影响，持续集成和开发都很灵活 每个微服务都可以快速的实施X（运行多个应用实例）、Z（数据分区的扩展）轴扩展（提升应用的容量和可用性），并为每个服务定义合适的硬件环境（I/O密集型、计算密集型），而不像单体架构采用大锅饭形式，可以为组织节约硬件成本 错误隔离：比如一个服务内存泄漏，它只会影响自身微服务实例，不会影响到其他微服务 微服务的缺点可用性降低：微服务之间都是通过远程调用进行协作的，而远程调用的代名词就是不稳定，如果没有有效的方案，微服务架构可能会大大降低应用的可用性。当一个服务不可用时，有可能会引起级联反应，最终造成应用的“雪崩效应”而拖垮整个应用 处理分布式事务较棘手：当一个用户请求的业务涉及多个微服务时，如何保障数据的一致性就成为一个棘手的问题。传统开发通常会使用两阶段提交的解决方案来解决这个问题。但对于微服务架构来说，这个解决方案并不是一个很好的选择，甚至在某些情况下很难实现。 全能对象阻止业务拆分：在进行微服务拆分时最让人头疼的一个问题就是全能对象，几乎对于任何一个业务的应用来说都可能存在一个或多个这样的全能对象。比如电子商城中的订单，订单几乎涉及到电商应用中的每一个业务，它会阻止你进行业务拆分 学习难度曲线加大：微服务架构虽然可以将业务可以分解为更小、更容易开发的模式，但也需要开发人员学习掌握一门微服务开发技术，加大了进入门槛。 组织结构变更：虽然对于单独一个微服务的部署简化了，但整个应用部署复杂度却提升了，需要涉及服务编排和服务治理等一系列处理，即不需要制定微服务之间的部署编排、关联关系、回滚计划等，还需要协调不同的团队，以及在人事组织上进行调整来适应这种变化 微服务架构设计的步骤1.把应用中的关键需求定义出来 2.识别出采用微服务架构时应用中所包含的所有服务 3.将第一步所定义出的关键需求作为架构需求的场景来描述服务之间如何进行协作 微服务拆分原则单一职责原则（SRP）单一职责原则（Single Responsibility Principle）：一个类应该有且只有一个变化的原因 每一个职责都是一个变化引起类变化的中心。当功能变化时，通常需要通过更改相关的类来实现。如果一个类拥有多个职责，那么就会有多于一个原因来导致这个类的变化。另外，一个类承担多个职责后，往往这些职责就会耦合在一起，某一职责的改变可能会影响到其他的职责。这样的类设计是非常脆弱的，从而会导致应用的稳定性。因此，我们在进行类设计时要遵守单一职责原则。 同样，对于微服务设计来说，如果一个微服务承担太多职责的话，也会导致微服务业务之间的耦合，为业务进行改变时埋下了不稳定因素。所以，单一职责原则同样也适用于微服务设计，我们可以将微服务保持足够小，仅拥有一个业务职责，保持微服务的业务单一性，从而提升应用的稳定性。 共同封闭原则（CCP）共同封闭原则（Common Closure Principle，CCP）：包中的所有的类对于同一种性质的变化应该是共同封闭的。一个变化若对一个封闭的包产生影响，则将对该包中的所有类产生影响，而对其他包则不造成任何影响。 共同封闭原则是延伸了面向对象开发中六大原则之一的开闭原则（OCP）中的关闭概念。就是说当需要修改某项业务时，我们需要将修改的范围限制在同一个包内，而不是遍布在很多包中。共同封闭原则指导我们如何对类进行有效的组织，将那些在业务概念上联系得非常紧密、通常一起发生改变的类，封装到同一个包中。通过共同封闭原则可以提升对应用组织上的管理。 同样，通过使用共同封闭原则可以将那些在业务上联系紧密，由于同一个原因而改变的服务组织在一个微服务中。这样一方面我们可以减少微服务的数量，另外一方面当业务发生改变时我们只需要一个业务开发团队进行单独修改，只需要重新部署该服务即可，减少了不同微服务开发团队之间沟通成本。 微服务自治原则一个团队越大，那么沟通与协助成本就会越高。因此，在微服务治理中有一个重要的理念就是自治，自治范围并不只是代码和数据，还包含微服务的运行和维护管理，所以亚马逊的微服务有一个规则：你构建，你运行。 将微服务分而治之的另一个重要方面是数据管理的分而治之。传统单体架构应用的开发在很多时候多个业务之间的数据交互是直接通过操作数据库来完成，当需要更改某一业务数据库表时往往会涉及多个模块，甚至有时候根本不清楚修改这张数据库表到底会影响到多少业务代码，从而不敢动数据库表的定义，只好退而求其次，通过增加表来处理，进而加剧了系统架构的恶化。 虽然现在O／R mapping技术的出现从一定程度上解决了这个头痛的问题，但终未从根本上解决。而微服务中的分而治之理念，不但是指业务功能，也同时包含了对业务数据的管理。将业务数据管理进行私有化之后就进一步降低了业务之间的耦合度，所以实施微服务的架构师，一定要保持业务数据管理的私有化，即使你在项目中不能够分库，也要牢记这条规则，严格要求各微服务团队看好自己的数据。 服务架构中的数据自治是指每个微服务拥有其业务领域对象下的数据，只有该微服务可以对这些数据进行操作（包含读取与更改），而其他微服务只有通过该服务才能访问到这些数据，不能直接通过数据库进行沟通。因此，我们可以不用为每一个微服务创建一个独立数据库，可以将它们统一存放在一个数据库中，保障不破坏上述的数据访问原则即可。 微服务交互原则REST协议：（http+uri）REST在微服务互相调用之间起着非常重要的角色，强烈建议使用HTTP作为服务的调用协议，并在服务处理上使用HTTP标准动词（GET、POST、PUT、DELETE）。 URI表达：服务端点的URI应该能清晰的表达出我们想要解决的问题、提供的方法、相应资源信息及资源之间的关联关系 JSON数据格式：JSON作为轻量级数据格式协议，及自带的序列化和反序列化机制，几乎已经成为通信中的数据标准协议，并且对于前端开发来说非常容易使用和整合 HTTP标准状态码：HTTP协议本身具有非常丰富的状态码，那么使用这些状态码来作为服务调用结果的状态是非常合适的 微服务架构迁移单体架构应用迁移到微服务架构意味着一个漫长的过程，不过这和在开发时经常做的代码重构类似，只是变成了对架构的重构，因此可以从中吸取一些思路。对于代码重构，有一个很重要的指导思想就是不要大规模进行重构，而是一小步一小步来。作为开发人员，每次听到重写代码可能会很兴奋，但实际上却是充满了风险，道路也是非常崎岖坎坷，最终也有可能会失败，每一个重写过代码的开发者可能对这一点深有体会。 因此，与大规模进行重构相反，在进行微服务架构迁移时可以使用Martin Fowler提出绞杀（Strangler）模式。该策略名字来源于雨林中的绞杀藤，绞杀藤为了能够爬到森林顶端都要缠绕着某棵大树生长，最终使被缠绕的大树死掉，只留下树形一样的绞杀藤。通过这种策略，我们在迁移时应首先围绕着传统应用开发出新的微服务应用，并逐渐替代传统应用中的部分业务功能。通过这种方式逐步构建微服务应用，并替代、兼容整合旧的传统应用，直到微服务承担全部应用功能，而传统单体架构应用此时也就可以退出历史舞台了。 不应用微服务的场景构建分布式架构非常吃力 服务器蔓延时 采用小型应用、快速产品原型时 对数据事务的一致性有一定要求时]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的算法思想——1]]></title>
    <url>%2F2019%2F06%2F23%2Fsuanfa%2F</url>
    <content type="text"><![CDATA[枚举算法枚举算法思想特点是在面对任何问题时它都会去尝试每一种解决方法，在进行归纳推理时，如果逐个考察了某类事件的所有可能情况，因而得出一般结论，那么这个结论可能是可靠的，这种归纳方法叫归纳法 枚举算法基础枚举算法思想是：将问题所有可能的答案一一列举，然后根据条件判断此答案是否合适，保留合适的，丢弃不合适的 枚举算法基本思路1.确定枚举对象、枚举范围和判定条件 2.逐一列举可能的解，验证每个解是否是问题的解 枚举算法基本步骤1.题解的可能范围，不能遗漏任何一个真正解，也要避免有重复 2.判断是否是真正解的方法 3.使可能解的范围将至最小，以便提高解决问题的效率 案例百元买百鸡公鸡每只5元，母鸡每只3元，小鸡3只1元。用100元买一百只鸡 1234567891011public static void main(String[] args) &#123; int xj; for (int gj=0;gj&lt;=20;gj++)&#123; for (int mj=0;mj&lt;=33;mj++)&#123; xj=100-gj-mj; if (xj%3==0&amp;&amp;5*gj+3*mj+xj/3==100)&#123; System.out.println("公鸡："+gj+",母鸡："+mj+",小鸡："+xj); &#125; &#125; &#125;&#125; 运行结果 填写运算符在下面算式中，添加“＋”“－”“×”“÷”4个运算符使等式成立 5 5 5 5 5 = 5 ‘×’，’÷’运算符优先级高于’+’,’-‘且’÷’后面的数不可以是0 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public static void main(String[] args) &#123; int[] i=new int[4]; //表示4个运算符 int sign; //累加运算时的符号 int result=5; //运算的结果值 int count=0; //结果个数 int [] num=&#123;5,5,5,5,5&#125;; char [] oper=&#123;' ','+','-','*','/'&#125;; double left,right; for (i[0]=1;i[0]&lt;=4;i[0]++)&#123;//循环4种运算符，1+2-3*4/ if (i[0]&lt;4||(num[1]!=0))&#123;//若运算符为/，下一个数值不能为0 for (i[1]=1;i[1]&lt;=4;i[1]++)&#123; if (i[1]&lt;4||num[2]!=0)&#123; for (i[2]=1;i[2]&lt;=4;i[2]++)&#123; if (i[2]&lt;4||num[3]!=0)&#123; for (i[3]=1;i[3]&lt;=4;i[3]++)&#123; if (i[3]&lt;4||num[4]!=0)&#123; left=0; right=num[0]; sign=1; for (int j=0;j&lt;4;j++)&#123; switch (oper[i[j]])&#123; case '+':left=left+sign*right; sign=1; right=num[j+1]; break; case '-':left=left+sign*right; sign=-1; right=num[j+1]; break; case '*':right=right*num[j+1]; break; case '/':right=right/num[j+1]; break; &#125; &#125; if (left+sign*right==result)&#123; count++; System.out.print(count+":"); for (int j=0;j&lt;4;j++)&#123; System.out.print(num[j]+""+oper[i[j]]); &#125; System.out.print(num[4]+"="+result+" "); &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; 运行结果 递推算法递推算法基础递推算法可以不断利用已有信息推导出新的东西 顺推法：从已知条件出发，逐步推算出要解决问题的方法逆推法：从已知结果出发，用迭代表达式逐步推算出问题开始的条件，即顺推法的逆过程 案例顺推法——裴波那契数列兔子在出生两个月以后就有繁殖能力，一对兔子每月能生出一对兔子，如果所有兔子都不死，一年后有多少兔子 算法分析 第一个月兔子没有繁殖能力，所以还是一对 二个月后，一对小兔子生出一对新兔子，所以是两对 第三个月后老兔子又生下一对，小兔子还没有繁殖能力，所有有三对 月数： 1 2 3 4 5 6 7 8 … 对数： 1 1 2 3 5 8 13 21 … 得出特征：前面相邻两项之和等于后一项 由此可知n个月的兔子总数为：Fn=Fn-2+Fn-1 12345678910111213public static void main(String[] args) &#123; int [] fib=new int[13]; fib[0]=fib[1]=1; for (int i=2;i&lt;fib.length;i++)&#123; fib[i]=fib[i-1]+fib[i-2]; &#125; for (int i=0;i&lt;fib.length;i++)&#123; System.out.print(i+1+"月："+fib[i]+"个兔子 "); if (i%3==0)&#123; System.out.println(); &#125; &#125; &#125; 运行结果 逆推法——银行存款问题母亲为儿子4年大学生活准备了一笔存款，方式是整存零取，规定儿子每月月底取下一个月生活费，现假设银行年利率为1.71%，计算母亲最少要存入多少钱 算法分析因为按月取钱，所以需要将4年分为48个月 如果48月后，儿子大学毕业时连本带利要取1000，则要先求出第47个月时银行存款的钱数 47月末=1000/(1+0.0171/12) 46月末=(47月末+1000)/(1+0.171/12) 45月末=(46月末+1000)/(1+0.171/12) 44月末=(45月末+1000)/(1+0.171/12) 43月末=(44月末+1000)/(1+0.171/12) …… 2月末=(3月末+1000)/(1+0.171/12) 1月末=(2月末+1000)/(1+0.171/12) 12345678910public static void main(String[] args) &#123; double [] corpus=new double[48]; int i; corpus[47]=1000; double rate=0.0171; for (i=46;i&gt;=0;i--)&#123; corpus[i]=(corpus[i+1]+1000)/(1+rate/12); &#125; System.out.println("需存储："+corpus[0]+"元");&#125; 运行结果 递归算法递归算法基础在计算机编程中，递归算法对解决大多数问题是十分有效的，它能使算法的描述变得简洁而且易于理解 递归算法的特点1.递归过程一般通过函数或子过程来实现 2.递归算法在函数或子过程的内部，直接或间接的调用自身 3.递归算法实际上是把问题转化为小规模的同类问题，然后再递归调用函数或过程来表示问题的解 使用递归的注意事项1.递归是在过程或函数中调用自身的过程 2.在使用递归时，必须有一个明确的结束条件（递归出口） 3.递归算法通常显得很简洁，但运行效率很低，所以一般不提倡用递归算法设计程序 4.在递归调用过程中，系统用栈来存储每一层的返回点和局部变量。如果递归次数过多，则会造成栈溢出，所以一般不提倡使用递归算法设计程序 案例汉诺塔详解（https://www.cnblogs.com/vsky/p/5014657.html/ ）（https://blog.csdn.net/qq_37873310/article/details/80461767 ） 123456789public static void move(int n, String x, String y, String z)&#123; if (n==1)&#123; System.out.println(""+x+z); &#125;else &#123; move(n-1,x,z,y); //System.out.println(""+x+z); move(n-1, y,x ,z); &#125; &#125; 阶乘自然数由1~n的n个数连乘积叫做n的阶乘，记作n！ 1234567891011121314public class JieCheng &#123; public static void main(String[] args) &#123; int i=6; long n=fact(i); System.out.println(i+"的阶乘是："+n); &#125; public static int fact(int n)&#123; if (n&lt;=1)&#123; return 1; &#125;else &#123; return n*fact(n-1); &#125; &#125;&#125; 运行结果调用过程 分治算法分治算法也采取了各个击破的方法，将一个规模为N的问题分解成K个规模较小的子问题，这些子问题相互独立且与原问题性质相同，只要求出子问题的解，就可得到原问题的解 分治算法基础分治算法基本步骤1.分解，将要解决的问题划分为若干个规模较小的同类问题 2.求解，当子问题划分的足够小时，用较简单的方法求解 3.合并，按原问题要求将子问题的解逐层合并构成原问题的解 案例大数相乘问题详解（https://blog.csdn.net/u011446177/article/details/52894191/ ） 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public static void main(String[] args) &#123; String str1 = "2345678900987766655554444455"; String str2 = "34658743659843759437594387593875"; int len1 = str1.length(); int len2 = str2.length(); char[] s1 = str1.toCharArray(); char[] s2 = str2.toCharArray(); // 高低位对调 covertdata(s1, len1); covertdata(s2, len2); System.out.println("乘数："+str1); System.out.println("乘数："+str2); multiply(s1, len1, s2, len2); &#125; public static void covertdata(char data[], int len) &#123; //高低位对调 for (int i = 0; i &lt; len / 2; i++) &#123; data[i] += data[len - 1 - i]; data[len - 1 - i] = (char) (data[i] - data[len - 1 - i]); data[i] = (char) (data[i] - data[len - 1 - i]); &#125; &#125; public static void multiply(char a[], int alen, char b[], int blen) &#123; // 两数乘积位数不会超过乘数位数和+ 3位 int csize = alen + blen + 3; // 开辟乘积数组 int[] c = new int[csize]; // 乘积数组填充0 for (int ii = 0; ii &lt; csize; ii++) &#123; c[ii] = 0; &#125; // 对齐逐位相乘 for (int j = 0; j &lt; blen; j++) &#123; for (int i = 0; i &lt; alen; i++) &#123; c[i + j] += Integer.parseInt(String.valueOf(a[i]))* Integer.parseInt(String.valueOf(b[j])); &#125; &#125; int m = 0; // 进位处理 for (m = 0; m &lt; csize; m++) &#123; int carry = c[m] / 10; c[m] = c[m] % 10; if (carry &gt; 0) &#123; c[m + 1] += carry; &#125; &#125; // 找到最高位 for (m = csize - 1; m &gt;= 0;) &#123; if (c[m] &gt; 0) &#123; break; &#125; m--; &#125; // 由最高位开始打印乘积 System.out.print("乘积："); for (int n = 0; n &lt;= m; n++) &#123; System.out.print(c[m - n]); &#125; &#125; 欧洲冠军杯比赛欧洲冠军杯初赛阶段采用循环制，设共有n队参加，初赛共进行n-1天，每队都要和其他各队进行一场比赛，然后按照最后积分选拔进入决赛的球队。要求每队每天只能进行一场比赛，并且不能轮空。 算法分析根据分治算法思路，将所有参赛队伍分为两半，则n队比赛日程表可以通过n/2个队的比赛日程来决定，然后继续划分，直到只剩下最后2队为止。 代码实现转自(https://www.jianshu.com/p/2089e19e7f99/ ) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129public class Solution &#123; /** * 循环赛日程表 * @param ranksNumber */ static public void raceSchedule(int ranksNumber) &#123; if (ranksNumber &lt; 2) &#123; System.out.println("无需安排"); return; &#125; int[][] resultArray = new int[ranksNumber][ranksNumber]; for (int counter = 0;counter &lt; ranksNumber;counter++) &#123; resultArray[counter][0] = counter + 1; for (int counter1 = 1;counter1 &lt; ranksNumber;counter1++) &#123; resultArray[counter][counter1] = resultArray[counter][counter1 - 1] + 1; if (resultArray[counter][counter1] &gt; ranksNumber)resultArray[counter][counter1] = 1; &#125; &#125; for (int counter = 0;counter &lt; ranksNumber;counter++) &#123; if (counter == 0)System.out.print("No.\t"); else System.out.print("D" + counter + "\t"); &#125; System.out.println(); for (int counter = 0;counter &lt; ranksNumber;counter++) &#123; for (int counter1 = 0;counter1 &lt; ranksNumber;counter1++) &#123; System.out.print(resultArray[counter][counter1] + "\t"); &#125; System.out.println(); &#125; &#125; /** * 本算法采用分治策略来解决。 * @param ranksNumber */ static public void raceSchedule0(int ranksNumber) &#123; //判断它是不是2的次幂，并且它还必须至少是2. if (!isPowerOfTwo(ranksNumber) || ranksNumber &lt; 2) &#123; System.out.println("输入错误"); return; &#125; int[][] scheduleArray = new int[ranksNumber][ranksNumber]; Solution.dAndC(scheduleArray,1,ranksNumber,ranksNumber); for (int counter = 0;counter &lt; ranksNumber;counter++) &#123; if (counter == 0)System.out.print("No.\t"); else System.out.print("D" + counter + "\t"); &#125; System.out.println(); for (int counter = 0;counter &lt; ranksNumber;counter++) &#123; for (int counter1 = 0;counter1 &lt; ranksNumber;counter1++) &#123; System.out.print(scheduleArray[counter][counter1] + "\t"); &#125; System.out.println(); &#125; &#125; /** * 分治策略的迭代部分 * @param scheduleArray * @param number * @param length * @param ranksNumber */ static private void dAndC(int[][] scheduleArray,int number,int length,int ranksNumber) &#123; //如果就2个队伍就很简单了，就是2个斜方向的问题了。 if (length == 2) &#123; scheduleArray[number - 1][0] = number; scheduleArray[number][1] = number; scheduleArray[number - 1][1] = number + 1; scheduleArray[number][0] = number + 1; &#125; else &#123; int halfLength = length / 2; //迭代处理左上角方阵。 Solution.dAndC(scheduleArray,number,halfLength,ranksNumber); Solution.printMatrix(scheduleArray,ranksNumber); //迭代处理左下角方阵。 Solution.dAndC(scheduleArray,number + halfLength,halfLength,ranksNumber); Solution.printMatrix(scheduleArray,ranksNumber); //接下来把左下的方阵复制到右上角的方阵去 for (int counter = number - 1;counter &lt; number - 1 + halfLength;counter++) for (int counter0 = halfLength;counter0 &lt; length;counter0++) scheduleArray[counter][counter0] = scheduleArray[counter + halfLength][counter0 - halfLength]; Solution.printMatrix(scheduleArray,ranksNumber); //接下来把左上的方阵复制到右下角的方阵去 for (int counter = number - 1 + halfLength;counter &lt; number - 1 + length;counter++) for (int counter0 = halfLength;counter0 &lt; length;counter0++) scheduleArray[counter][counter0] = scheduleArray[counter - halfLength][counter0 - halfLength]; Solution.printMatrix(scheduleArray,ranksNumber); &#125; &#125; /** * 打印矩阵 * @param scheduleArray * @param rank */ static private void printMatrix(int[][] scheduleArray,int rank) &#123; for (int counter = 0;counter &lt; rank;counter++) &#123; for (int counter1 = 0;counter1 &lt; rank;counter1++) &#123; if (scheduleArray[counter][counter1] == 0)System.out.print(" "); else System.out.print(scheduleArray[counter][counter1] + " "); &#125; System.out.println(); &#125; System.out.println(); &#125; /** * 判断一个数是不是2的幂次 * @param number * @return */ static private boolean isPowerOfTwo(int number) &#123; int bitFlag = 1; int bitSum = Integer.SIZE - 1;//不算符号位 int bitIterator = 0; int oneCounter = 0; while (bitIterator &lt; bitSum) &#123; if ((bitFlag &amp; number) != 0) &#123; oneCounter++; if (oneCounter &gt; 1) return false; &#125; bitFlag = bitFlag &lt;&lt; 1; bitIterator++; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础知识]]></title>
    <url>%2F2019%2F06%2F22%2Fjava01%2F</url>
    <content type="text"><![CDATA[重载与重写的区别重载重载发生在同一个类中,方法名相同，参数类型，个数，顺序不同返回值和访问修饰符可以不同 重写重写发生在子类中，方法名，参数列表必须相同，返回值范围小于等于父类，抛出异常范围小于等于父类，访问修饰符大于等于父类,如果父类方法修饰符为private则不可以重写该方法 String,StringBuffer,StringBuilder的区别，String为什么不可变可变性String类中使用final关键字字符数组保存字符串,private final char value[],所以string对象是不可变的,而StringBuffer和StringBuilder都继承AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，但是没用final关键字修饰，所以这两种对象都是可变的 AbstractStringBuilder.java 123456789101112131415abstract class AbstractStringBuilder implements Appendable, CharSequence &#123; //The value is used for character storage. //该值用于字符存储。 char[] value; //The count is the number of characters used. //使用的字符数。 int count; //This no-arg constructor is necessary for serialization of subclasses. //这个无参数构造函数是子类序列化所必需的。 AbstractStringBuilder() &#123; &#125; //创建指定容量的AbstractStringBuilder。 AbstractStringBuilder(int capacity) &#123; value = new char[capacity]; &#125; 线程安全性String中的对象是不可变的，也可以理解为常量，线程安全 AbstractStringBuilder是StringBuilder和StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexof等公共方法，StringBuffer对方法加了同步锁或对调用的方法加入了同步锁，所以线程是安全的而StringBuilder并没有对方法加同步锁，所以线程是不安全的 性能每次对String类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String对象 StingBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StringBuilder比StringBuffer性能高10%·15%左右，但要冒多线程下不安全的风险 总结 操作量少的数据String 单线程操作字符串缓冲区下操作大量数据StringBuilder 多线程操作字符串缓冲区下操作大量数据StringBuffer 自动装箱与拆箱装箱：将基本类型用他们对应的引用类型包装起来 拆箱：将包装类型转换为基本类型 注：基本类型与引用类型用==判断相等时注意空指针异常(https://gpdstudy.club/posts/integer-bug/#more) 1234567int a = 1;Integer b = null;if(a == b) &#123;//空指针异常 System.out.println(true);&#125;else &#123; System.out.println(false);&#125; ==与equals==它的作用是判断两个对象的地址是否相等，即判断两个对象是不是同一个对象基本类型比值，引用数据类型比较的是内存地址 equals()它的也作用是判断两个对象是否相等，但他一般有两种情况 类没有重写equals方法通过equals()比较该类型的两个对象时，等价于==比较 类重写了equals()方法，一般，我们重写equals方法来比较两个对象的内容相等相等返回true 举个例子 1234567891011121314public class test&#123; public static void main(string[] args)&#123; String a=new String("ab");//a为一个引用 String b=new String("ab");//b为另一个引用，对象内容一样 String c="ab";//放在常量池中 String d="ab";//从常量池中查找 if(a==b)//false System.out.println("a==b") if(c==d)//true System.out.println("c==d") if(42==42.0)//true System.out.println("true") &#125; &#125; String中的equals()方法是被重写过的,因为Object的equals方法是比较对象的内存地址而String中的equals()方法比较的是对象的内容 当创建String类型的对象时，虚拟机会在常量池中查找有没有已存的值和要创建的值相等，如果有就把他给当前对象引用，如果没有就在常量池中重新创建一个String对象 final关键字final关键字主要用在三个地方：变量，方法，类 对于一个final变量，如果是基本数据的类型的变量，则其数值一旦初始化后不能在更改.如果是引用类型的变量，则在其初始化后便不能再让其指向另一个对象 当用final修饰一个类时，表示这个类不能被继承。final类中的所有成员方法都会被隐式指定为final方法 用final修饰的方法原因有两个一是因为把方法锁定，以防任何继承类修改它的含义二是因为效率早期java实现版本中，会将final方法转为内嵌调用，但如果方法过于庞大，可能看不到内嵌调用带来的性能提升（现在java版本已不需要final方法进行优化）类中所有private方法都隐式指定为finalObject类中的常见方法总结 Object是所有类的父类,主要提供了11个方法 native方法，用于返回当前运行时对象的Class对象，使用了final关键字，不允许重写 1public final native Class&lt;?&gt; getClass(); native方法，用于返回对象的哈希码，主要使用在哈希表中（HshMap） 1public native int hashCode(); 用于比较两个对象的地址是否相同，string重写改为了比较两个对象的内容 123public boolean equals(Object obj) &#123; return (this == obj);&#125; native方法，用于创建并返回当前对象的一份拷贝，一般情况下，对于任何对象x，表达式x.clone()!=x为true，而x.clone().getClass()==x.getClass()为true。Object本身没有实现Cloneable接口，所以不重写clone方法并调用的话会发生CloneNotSupportedException异常 1protected native Object clone() throws CloneNotSupportedException; 返回类的名字@实例的哈希码的16进制的字符串(建议Object子类都重写这个方法） 123public String toString() &#123; return getClass().getName() + "@" + Integer.toHexString(hashCode());&#125; native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程（监视器相当于就是锁的概念），如果有多个线程在等待只会随机唤醒一个 1public final native void notify(); native方法，并且不能重写。与notify方法一样，区别在于会唤醒在此对象监视器上等待的所有线程，而不是其中一个 1public final native void notifyAll(); native方法，并且不能重写。暂停线程的执行,注：sleep方法没有释放锁，而wait释放了锁，timeout是等待时间 1public final native void wait(long timeout) throws InterruptedException; 与上个方法一样，只是多了nanos参数，这个参数表示额外时间（以毫秒为单位，0-999999），所以超时时间还要加上nanos毫秒 12345678910111213141516public final void wait(long timeout, int nanos) throws InterruptedException &#123; if (timeout &lt; 0) &#123; throw new IllegalArgumentException("timeout value is negative"); &#125; if (nanos &lt; 0 || nanos &gt; 999999) &#123; throw new IllegalArgumentException( "nanosecond timeout value out of range"); &#125; if (nanos &gt;= 500000 || (nanos != 0 &amp;&amp; timeout == 0)) &#123; timeout++; &#125; wait(timeout);&#125; 和之前两个wait方法一样，只不过该方法一直等待，没有超时 123public final void wait() throws InterruptedException &#123; wait(0);&#125; 实例被垃圾回收器回收时触发的操作 1protected void finalize() throws Throwable &#123; &#125; java中的异常处理在java中，所有的异常都有一个共同的父类java.lang.Throwable,Throwable有两个子类Exception(异常)和Error(错误)两者都是异常处理的重要子类，各自都包含大量子类 Error(错误)**Error(错误)是程序无法处理的错误，表示运行程序中较严重的问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时JVM出现的问题 java虚拟机运行错误(Virtual MachineError) 类定义错误(NoClassDefFoundError) …… Exception(异常)Exception(异常)是程序本身可以处理的异常Exception有一个重要的子类RuntimeException。RuntimeExceptioon由java虚拟机抛出 NullPointerException，要访问的变量没有任何对象引用时，抛出该异常 ArithmeticException，算术运算异常，整数除0时抛出 ArrayIndexOutOfBoundsException,下标越界异常 注：异常和错误的区别在于异常能被程序本身处理，而错误不可以 Throwable类常用方法 getMessage()：返回异常发生时的详细信息 toString()：返回异常发生时的简要描述 getLocalizedMessage()：返回异常对象的本地化信息。使用Throwable子类重写这个方法可以声称本地化信息，如果子类没有重写该方法，则返回与getMessage()结果相同 printStackTrace()：在控制台打印Throwable对象封装的异常信息 异常处理 try块：用于捕捉异常，其后可接零或多个catch块，如果没有catch块则必须跟一个finally块 catch块：用于处理try捕捉到的异常 finally块：无论是否捕捉到异常都会执行当在try或catch中遇到return语句时，finally语句在返回前执行 finally不会执行的条件 finally中发生了异常 在finally前用System.exit()退出程序 程序所在线程死亡 关闭CPU 获取键盘输入 通过Scanner 123Scanner input = new Scanner(System.in);String s = input.nextLine();input.close(); 通过BufferedReader 123456BufferedReader input =new BufferedReader(new InputStreamReader(System.in));try &#123; String s = input.readLine();&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 接口与抽象类的区别 接口方法默认public，所有方法在接口中不能有实现在java8开始接口方法可以有默认实现抽象类可以有非抽象方法 接口中的实例变量默认是final类型的而抽象类不一定 一个类可以实现多个接口，但只能实现一个抽象类 接口不能被new实例化，但可以声明，但是必须引用一个实现该接口的对象，从设计层来说，抽象是对类的抽象，是一种模板设计，接口是行为的接口，是一种行为规范 jdk8中，接口也可以定义静态方法，可以直接用接口名调用。实现类和实现是不可以调用的。如果同时实现了两个接口，接口定义了一样的默认方法，必须重写，不然会报错（https://github.com/Snailclimb/JavaGuide/issues/146/ ） java集合ArrayList与LinkedList异同 线程安全 ArrayList和LinkedList都是不同步的，线程不保证安全 底层数据结构 ArrayList底层是Object数组，LinkedList底层使用的是双向链表数据结构（1.6之前是循环链表，1.7取消了循环） 插入和删除是否受元素位置的影响 ArrayList采用数组存储，所以插入和删除元素的时间复杂度受元素的位置影响，比如：执行add(E e)方法的时候，ArrayList会默认将指定元素追加到末尾，这种情况下时间复杂度为O(1),但如果是在指定位置i插入和删除元素add(int index E e)时时间复杂度为O(n-i)。因为在执行此方法时集合中的第i个元素个i之后(n-i)个元素都要执行向后/前位移一位的操作LinkedList采用链表存储，所以插入删除元素时间复杂度不受元素位置影响，都是近似O(1)，而数组为近似O(n) 是否支持快速随机访问 LinkedList不支持高效的随机元素访问，而ArrayList支持get(int index) 内存空间占用 ArrayList空间浪费在list列表结尾会预留一定的容量空间，而LinkedList空间花费在每一个元素，每个元素消耗的空间都比ArrayList更多，因为LinkendList要存放直接后继和直接前驱以及数据 list的遍历 实现了RandomAccess接口的list，优先使用for循环，其次foreach未实现RandomAccess接口的list，优先选择iterator遍历（foreach底层也是有iterator实现的）大size的数据不要使用普通for循环 ArrayList和VectorVector类所有方法都是同步的。可以由两个线程安全的访问一个Vector对象，但一个线程访问Vector的话代码要在同步操作上耗费大量的时间 ArrayList不是同步的，在不需要保证线程安全的时候建议使用]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学go第三天]]></title>
    <url>%2F2019%2F06%2F18%2Fgo3%2F</url>
    <content type="text"><![CDATA[流程控制if语句if后条件判断语句没有()if后面条件成立则执行{}里程序，不成立则跳过 if运行实例 12345678package mainimport "fmt"func main()&#123; var a int =3 if a==3 &#123; //条件判断语句没有() fmt.Println(a) &#125;&#125; 运行结果:3 if…else…if后条件不成立则执行else{}里语句运行实例 12345678910package mainimport "fmt"func main()&#123; var a int =3 if a&gt;3 &#123; //条件判断语句没有() fmt.Println(a) &#125;else &#123; fmt.Println("a不大于3") &#125;&#125; 运行结果:a不大于3 if…else if…else…第一个if不成立则判断第二个，直到所有if不成立执行else{}里程序，如果有一个if条件成立，则执行其{}内语句并跳出判断运行实例 1234567891011121314package mainimport "fmt"func main()&#123; var a int =3 if a == 1 &#123; fmt.Println("a==1") &#125;else if a == 2 &#123; fmt.Println("a==2") &#125;else if a == 3 &#123; fmt.Println("a==3") &#125;else&#123; fmt.Println("a&gt;=3") &#125;&#125; 运行结果:a==3 switch语句switch后写的是变量本身，不是判断条件,变量与case等式都不成立则执行default，go语言保留了break关键字,默认情况下不写，默认包含 运行实例: 123456789101112131415161718package mainimport "fmt"func main() &#123; num:=3 switch num &#123; //switch后写的是变量本身，不是判断条件 case 1: fmt.Println("按下的是",num,"楼")// break//go语言保留了break关键字,默认不写，默认包含 case 2: fmt.Println("按下的是",num,"楼") case 3: fmt.Println("按下的是",num,"楼") case 4: fmt.Println("按下的是",num,"楼") default: fmt.Println("按下的是",num,"楼") &#125;&#125; 运行结果:按下的是 3 楼 fallthrough关键字fallthrough表示不跳出switch循环,后面条件无条件执行运行实例: 123456789101112131415161718192021package mainimport "fmt"func main() &#123; num:=3 switch num &#123; //switch后写的是变量本身，不是判断条件 case 1: fmt.Println("按下的是",num,"楼") fallthrough case 2: fmt.Println("按下的是",num,"楼") fallthrough case 3: fmt.Println("按下的是",num,"楼") fallthrough case 4: fmt.Println("按下的是",num,"楼") fallthrough default: fmt.Println("按下的是",num,"楼") &#125;&#125; 运行结果: 123按下的是 3 楼按下的是 3 楼按下的是 3 楼 switch语句其他用法switch语句支持一个初始化语句,初始化语句和变量本身以分号分割运行实例: 1234567891011121314151617package mainimport "fmt"func main() &#123; //switch语句支持一个初始化语句,初始化语句和变量本身以分号分割 switch num := 3;num &#123; //switch后写的是变量本身，不是判断条件 case 1: fmt.Println("按下的是",num,"楼") case 2: fmt.Println("按下的是",num,"楼") case 3: fmt.Println("按下的是",num,"楼") case 4: fmt.Println("按下的是",num,"楼") default: fmt.Println("按下的是",num,"楼") &#125;&#125; 运行结果:按下的是 3 楼switch后可以没有变量,case后面可以加判断语句运行实例: 1234567891011121314151617package mainimport "fmt"func main() &#123; s :=88 switch &#123; //可以没有条件 case s &gt; 90: fmt.Println("优秀") case s &gt; 80: fmt.Println("良好") case s &gt; 70: fmt.Println("一般") case s &gt; 60: fmt.Println("较差") default: fmt.Println("差") &#125;&#125; 运行结果:良好switch语句case后可以加多个常量运行实例: 1234567891011121314package mainimport "fmt"func main() &#123; switch num := 3;num &#123; //switch后写的是变量本身，不是判断条件 case 1: fmt.Println("按下的是",num,"楼") case 2: fmt.Println("按下的是",num,"楼") case 3,4,5: //num=3|num=4|num=5时执行 fmt.Println("按下的是",num,"楼") default: fmt.Println("按下的是",num,"楼") &#125;&#125; 运行结果:按下的是 3 楼 for循环语句 语法 for 初始化条件;判断条件;条件变化{} 判断条件是否为真，如果为真执行循环体，如果为假跳出循环,如果不写判断条件则陷入死循环 12345678910package mainimport "fmt"func main() &#123; sum:=0 //判断条件是否为真,如果为真执行循环体,如果为假跳出循环 for i := 0; i &lt;= 100; i++ &#123; sum=sum+i &#125; fmt.Println(sum)&#125; range迭代器迭代打印每个元素,默认返回两个值:一个元素位置，一个元素本身 123456789101112package mainimport "fmt"func main() &#123; str :="abc" for i := 0; i &lt; len(str); i++ &#123; fmt.Printf("%d,%c\n",i,str[i]) &#125; //迭代打印每个元素,默认返回两个值:一个元素位置，一个元素本身 for i,data:=range str&#123; fmt.Println(i,data) &#125;&#125; 运行结果: 1234560,a1,b2,c0 971 982 99 其他用法 123456for i :=range str &#123; fmt.Printf("%d,%c",i,str[i])&#125;for i,_ :=range str &#123; fmt.Printf("%d,%c",i,str[i])&#125; 跳转语句break和continuebreak可用于for、switch、select，而continue只能用于for循环braek运行实例 1234567891011121314package mainimport "fmt"import "time"func main() &#123; i:=0 for&#123; i++ time.Sleep(time.Second)//休眠一秒 if i==5 &#123; break //跳出循环，如果嵌套多个循环，跳出最近的那个循环 &#125; fmt.Println(i) &#125;&#125; 运行结果 12341234 continue运行实例 123456789101112131415package mainimport "fmt"import "time"func main() &#123; i:=0 for&#123; i++ time.Sleep(time.Second)//休眠一秒 if i==5 &#123; //break //跳出循环，如果嵌套多个循环，跳出最近的那个循环 continue //跳过本次循环,下一次继续 &#125; fmt.Println(i) &#125;&#125; 运行结果 1234567123467…… goto跳转goto可以用在任何地方，但不能夸函数使用，用goto跳转前必须在当前函数内定义标签运行实例 12345678910package mainimport "fmt"func main() &#123; //goto可以用在任何地方，但不能夸函数使用 fmt.Println("111111111111111111111111111111") goto end //goto是关键字，end是用户定义标签的名字 fmt.Println("22222222222222222222222222") end: //定义标签 fmt.Println("33333333333333333333333")&#125; 运行结果: 1211111111111111111111111111111133333333333333333333333 函数在golang中，函数基本组成为:关键字func、函数名、参数列表、返回值、函数体和返回语句 1234func/*关键字*/ name/*函数名*/(/*参数列表*/)(a string,b int/*返回类型*/)&#123; /*函数体*/ return v1,v2//返回语句&#125; 自定义函数自定义函数不调用不会执行 无参无返回值函数12345678package mainimport "fmt"func Myfunc() &#123;//自定义函数 fmt.Println("我是Myfunc函数")&#125;func main() &#123; Myfunc()//无参无返回值函数的调用&#125; 运行结果: 1我是Myfunc函数 有参无返回值函数普通参数123456789101112131415package mainimport "fmt"func main() &#123; //调用函数传递的参数叫实参 youcan(10,10)//调用函数 youcan2(10,"abc")&#125;//定义函数时，在（）内定义的参数是形参//参数传递只能由实参传给形参func youcan(a,b int)&#123;//定义有参无返回值函数 fmt.Println(a,b)&#125;func youcan2(a int,b string)&#123; fmt.Println(a,b)&#125; 运行结果 1210 1010 abc 不定参数不定参数是指函数传入的参数个数为不定数量 1234567891011121314151617package mainimport "fmt"func main() &#123; Myfunc(100,200) Bdfunc(1,2,3,4,5) Bdfunc(1,2,3) Bdfunc()//不定参数也可以不传参数&#125;func Myfunc(a int, b int) &#123; fmt.Println(a,b)&#125;//...type不定参数类型func Bdfunc(a...int)&#123; //不定参数函数 for i := 0; i&lt; len(a);i++&#123; fmt.Print(a[i])//传多少参数打印多少个 &#125;&#125; 运行结果 123100 20012345123 不定参数，只能放在形参中的最后一个参数 不定参数的传递 12345678910111213141516package mainimport "fmt"func main() &#123; test(1,2,3,4,5)&#125;func test(args ...int) &#123; test01(args...)//全部元素传递给test01()函数 test01(args[:2]...)//从args[0]开始，到args[2]结束(不包括args[2])把中间所有元素传递过去 test01(args[2:]...)//从args[2]开始(包括args[2])，把后面所有元素传递过去&#125;func test01(args ...int)&#123; for _,data:=range args&#123; fmt.Printf("%d",data) &#125; fmt.Println()&#125; 运行结果 1231234512345 无参有返回值有返回值的参数，必须有明确的终止语句(return语句)，否则会引发编译错误， 123456789101112131415161718192021222324252627package mainimport "fmt"func main() &#123; var a int = func1() fmt.Println(a) var b int var c string b,c=func2() fmt.Println(b,c)&#125;//常用推荐写法func func1()(a int) &#123; a = 1 return a &#125;//也可写为,不推荐//func func1() int&#123;// return 1//&#125;func func2()(a int,b string) &#123; a=1 b="abc" return a,b&#125;//func func2()(int,string) &#123;// return 1,"abc"//&#125; 运行结果 1211 abc 有参有返回值123456789101112131415package mainimport "fmt"func main() &#123; max:=maxfunc(5,10) fmt.Println(max)&#125;//求两数最大值func maxfunc(a ,b int)(c int)&#123; if a&gt;b &#123; c=a &#125;else &#123; c=b &#125; return c&#125; 运行结果 110 递归函数递归函数可以直接或间接调用自身递归函数通常有相同的结构:一个跳出条件和一个递归体。所谓跳出条件是根据传入的参数判断是否需要停止递归，而递归体则是函数自身所做的一些处理 普通函数的调用流程123456789101112131415161718package mainimport "fmt"func main() &#123; a :=funca() //调用funca() fmt.Println(a) //4最后执行&#125;func funca()(a int) &#123; a=1 b:=funcb() //调用funcb() fmt.Println("funca b=",b) //2 fmt.Println("funca a=",a) //3 return a&#125;func funcb()(a int) &#123; a=1 fmt.Println("funcb a=",a) //1 return a&#125; 运行结果 1234funcb a= 1funca b= 1funca a= 11 递归函数调用流程12345678910111213package mainimport "fmt"func main() &#123; funcjian(10)&#125;func funcjian(a int) &#123; if a == 1 &#123; //此条件不成立下面调用函数一直执行，此语句成立时结束调用开始打印 fmt.Println(a) return &#125; funcjian(a-1) fmt.Print("a=",a)&#125; 121a=2a=3a=4a=5a=6a=7a=8a=9a=10 数字的累加123456789101112131415161718192021222324252627282930package mainimport "fmt"func main() &#123; var aum int = sum() fmt.Println(aum) sum1 :=sum01(100) fmt.Println(sum1) sum2 :=sum02(1) fmt.Println(sum2)&#125;//普通方法func sum()(sum int) &#123; for i:=0;i &lt;=100 ;i++ &#123; sum +=i &#125; return&#125;//递归方法func sum01(a int)(sum int) &#123; if a==1 &#123; return a &#125; return a+sum01(a-1)&#125;func sum02(a int)(sum int) &#123; if a==100 &#123; return a &#125; return a+sum02(a+1)&#125; 运行结果: 123505050505050 函数类型可以通过type给一个函数类型起名，并根据别名声明一个变量 123456789101112131415161718192021222324package mainimport "fmt"func main() &#123; var result int result=addd(10,10) fmt.Println(result) //声明一个函数类型的变量，变量名叫s var sss Functype sss=addd//是变量就可以赋值 result=sss(10,20)//等价于addd（10,20） fmt.Println(result) sss=jian result=sss(20,10)//等价于jian(20,10) fmt.Println(result)&#125;//函数也是一种数据类型，通过type给一个函数类型起名，名字为Functypetype Functype func(int,int) intfunc addd(a,b int)int &#123; return a+b&#125;func jian(a,b int)int &#123; return a-b&#125; 运行结果 123203010 回调函数1234567891011121314151617181920212223242526272829303132package mainimport "fmt"//回调函数。函数参数是函数类型，这个函数就是回调函数func main() &#123; var result int result = funccc(20,10,jia) fmt.Println(result) result = funccc(20,10,jians) fmt.Println(result) result = funccc(20,10,cheng) fmt.Println(result) result = funccc(20,10,chu) fmt.Println(result)&#125;type funcType func(int,int)intfunc funccc(a,b int,fun funcType) (c int) &#123; fmt.Print("funccc:") c=fun(a,b) return&#125;func jia(a int,b int)int&#123; return a+b&#125;func jians(a int,b int)int &#123; return a-b&#125;func cheng(a int,b int)int &#123; return a*b&#125;func chu(a int,b int)int &#123; return a/b&#125; 运行结果 1234funccc:30funccc:10funccc:200funccc:2 匿名函数与闭包详解（&lt;https://blog.csdn.net/lengyuezuixue/article/details/78527667）（https://www.cnblogs.com/williamjie/p/9875362.html） 匿名函数基本使用1234567891011121314151617package mainimport "fmt"func main() &#123; a:=10 str:="abc" //匿名函数，没有函数名字 f1 := func() &#123; fmt.Println(a) fmt.Println(str) &#125; f1() //给一个函数类型起别名 type funcType func() var f2 funcType f2=f1 f2()&#125; 运行结果 123410abc10abc 定义匿名函数同时调用123456789package mainimport "fmt"func main() &#123; a:=10 str:="abc"func()&#123; fmt.Println(a,str) &#125;()//()代表调用此匿名函数&#125; 运行结果 110 abc 带参数的匿名函数1234567package mainimport "fmt"func main() &#123; func(i,j int)&#123; fmt.Println(i,j) &#125;(1,2)&#125; 运行结果 11 2 匿名函数有参有返回值123456789101112131415package mainimport "fmt"func main() &#123; x,y:=func(i,j int)(max,min int)&#123; if i&gt;j &#123; max=i min=j &#125;else &#123; max=j min=i &#125; return &#125;(10,20) fmt.Println(x,y)&#125; 运行结果 120 10]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>-go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学go第二天]]></title>
    <url>%2F2019%2F06%2F17%2Fgo2%2F</url>
    <content type="text"><![CDATA[fmt包的格式化输出输入fmt包的格式化输出摘自(https://www.cnblogs.com/yinzhengjie/p/7680829.html/) 常用 %d 表示为十进制 %c 该值对应的unicode码值 %T 值的类型的Go语法表示 %v 使用默认格式输出的内置或者自定义类型的值，或者是使用其类型的String()方法输出自定义值,(如果有的话) 通用 %v 值的默认格式表示。当输出结构体时，扩展标志（%+v）会添加字段名 %#v 值的Go语法表示 %T 值的类型的Go语法表示 %% 百分号 布尔值 %t 单词true或false 整数 %b 表示为二进制 %c 该值对应的unicode码值 %d 表示为十进制 %o 表示为八进制 %q 该值对应的单引号括起来的go语法字符字面值，必要时会采用安全的转义表示 %x 表示为十六进制，使用a-f %X 表示为十六进制，使用A-F %U 表示为Unicode格式：U+1234，等价于”U+%04X” 浮点数、复数的两个组分 %b 无小数部分、二进制指数的科学计数法 %G 根据实际情况采用%E或%F格式（以获得更简洁、准确的输出） 字符串和[]byte %s 直接输出字符串或者[]byte %q 该值对应的双引号括起来的go语法字符串字面值，必要时会采用安全的转义表示 %x 每个字节用两字符十六进制数表示（使用a-f） %X 每个字节用两字符十六进制数表示（使用A-F） 指针 %p 表示为十六进制，并加上前导的0x %f: 默认宽度，默认精度 %9f 宽度9，默认精度 %.2f 默认宽度，精度2 %9.2f 宽度9，精度2 %9.f 宽度9，精度0 其它flag “+” 总是输出数值的正负号；对%q（%+q）会生成全部是ASCII字符的输出（通过转义）&quot;-&quot; 在输出右边填充空白而不是默认的左边（即从默认的右对齐切换为左对齐） #切换格式 八进制数前加0（%#o），十六进制数前加0x（%#x）或0X（%#X），指针去掉前面的0x（%#p）； 对%q（%#q），如果strconv.CanBackquote返回真会输出反引号括起来的未转义字符串； 对%U（%#U），如果字符是可打印的，会在输出Unicode格式、空格、单引号括起来的go字面值； ‘ ‘ 对数值，正数前加空格而负数前加负号； 对字符串采用%x或%X时（% x或% X）会给各打印的字节之间加空格； 0 使用0而不是空格填充，对于数值类型会把填充的0放在正负号后面；verb会忽略不支持的flag。例如，因为没有十进制切换模式，所以%#d和%d的输出是相同的。 对每一个类似Printf的函数，都有对应的Print型函数，该函数不接受格式字符串，就效果上等价于对每一个参数都是用verb %v。另一个变体Println型函数会在各个操作数的输出之间加空格并在最后换行 123456789101112package mainimport "fmt"func main() &#123; a:=10 b:="asd" c:='a' d:=3.14 fmt.Printf("%T,%T,%T,%T\n",a,b,c,d)//%T操作变量所属类型 //%d 整型格式 %s 字符串格式 %c 字符格式 %f 浮点格式 fmt.Printf("a=%d,b=%s,c=%c,d=%f\n",a,b,c,d) fmt.Printf("a=%v,b=%v,c=%v,d=%v\n",a,b,c,d)&#125; 变量的输入fmt.Scanf()必须要输入正确的格式 123456789package mainimport "fmt"func main() &#123; var a int fmt.Printf("请输入变量a:") //fmt.Scanf("%d",&amp;a) fmt.Scan(&amp;a) fmt.Println(a)&#125; 类型转换golang中不允许隐式转换，所有类型转换必须显式声明，而且转换只能发生在两种相互兼容的类型之间布尔类型和整型不兼容 123456789101112131415161718package mainimport "fmt"func main() &#123; var flag bool flag=true fmt.Printf("flag=%t\n",flag) //bool类型不能转换为整型 //fmt.Printf("flag=%d\n",int(flag)) //整型也不能转换为bool //flag=bool(1) var ch byte ch='a' var t int t=int(ch) //byte转int fmt.Printf("t=",t) fmt.Println() fmt.Println(ch)&#125; 类型别名type关键字(可以为变量类型更改一个名字) 1234567891011121314package mainimport "fmt"func main() &#123; type bigint int64 var a bigint fmt.Printf("a = %T\n",a) type ( long int64 char byte ) var b long = 11 var c byte = 'a' fmt.Printf("%d ,%s\n",b,c)&#125; 运算符详细使用实例(https://blog.csdn.net/ahaotata/article/details/84316528) 数学运算符“+” 加“-“ 减“*” 乘“/“ 除“%” 取模(取余)“++” 后自增(没有前自增)“- -“ 后自减(没有前自减) 关系运算符“==” 判断相等“!=” 不相等“&lt;” 小于“&gt;” 大于“&lt;=” 小于等于“&gt;=” 大于等于 逻辑运算符“!” 非,取反“&amp;&amp;” 与,同真为真“||” 或,有一个为真为真 位运算符“&amp;” 按位与,参与运算的两数各对应的二进位相与(加)“|” 按位或,参与运算的两数各对应的二进位相或(有1取1)“^” 异或,参与运算的两数各对应的二进位相异或(两数不同得1)“&lt;&lt;” 左移,左移n位=乘以2的n次方，左边丢弃，右边补0“&gt;&gt;” 右移,右移n位=除以2的n次方，右侧丢弃左边补0 赋值运算符“=” 普通赋值“+=” 相加后再赋值(a+=1等于a=a+1)“-=” 相减后再赋值(a-=1等于a=a-1)“*=” 相乘后再赋值(a*=2等于a=a*2)“/=” 相除后再赋值(a/=2等于a=a/2)“%=” 取模后再赋值(a%=2等于a=a%2)“&lt;&lt;=” 左移后再赋值(a&lt;&lt;=2等于a=a&lt;&lt;2)“&gt;&gt;=” 右移后再赋值(a&gt;&gt;=2等于a=a&gt;&gt;2)“&amp;=” 按位与后再赋值(a&amp;=2等于a=a&amp;2)“^=” 按位与后再赋值(a^=2等于a=a^2)“|=” 按位或后再赋值(a|=2等于a=a|2) 其他运算符“&amp;” 取地址运算符(&amp;a=变量a的地址)“*” 取值运算符(*a=指针变量a所指向内存的值)使用示例： 1234567891011package mainimport "fmt"func main() &#123; fmt.Println("1&gt;2",1&gt;2) var a int=10 var ptr *int ptr=&amp;a fmt.Printf("a 的值为 %d\n", a); fmt.Println(&amp;a) fmt.Printf("*ptr 为 %d\n", *ptr);&#125; 运行结果： 12341&gt;2 falsea 的值为 100xc00004c088*ptr 为 10 运算符优先级(https://www.sojson.com/operation/go.html)]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>-go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学go第一天]]></title>
    <url>%2F2019%2F06%2F16%2Fgo1%2F</url>
    <content type="text"><![CDATA[go的环境配置123456789- 1.golang下载(https://studygolang.com/dl)- 2.环境变量配置 GOROOT：Go 安装后的根目录（例如：D:\Go），安装过程中会由安装程序自动写入系统环境变量中。 GOBIN：Go 的二进制文件存放目录（%GOROOT%\bin） PATH：需要将 %GOBIN% 加在 PATH 变量的最后，方便在命令行下运行。-3.Go 工作空间 GOPATH :Go 的工作空间，就是我们的开发和依赖包的目录,例如(D:\abc\GO) 注意：不要把 GOPATH 设置成 Go 的安装路径-配置好之后，通过 go env 命令来查看go环境是否配置正确，如下图 Hello World123456package mainimport "fmt"//入口函数main()func main() &#123; fmt.Println("Hello World!")&#125; 将上面的程序保存成 helloworld.go，然后在文件地址栏输入cmd回车执行或者可以右键Git bash执行：go run helloworld.go运行结果 Golang标准库文档(https://studygolang.com/pkgdoc) golang数据类型数据类型作用：告诉编译器这个变量应该占用多大内存数据类型用于声明函数和变量。数据类型的出现是为了把数据分成所需内存大小不同的数据，编程的时候需要用大数据的时候才需要申请大内存，就可以充分利用内存。 整型uint8: 无符号 8 位整型 (0 到 255) uint16: 无符号 16 位整型 (0 到 65535) uint32: 无符号 32 位整型 (0 到 4294967295) uint64: 无符号 64 位整型 (0 到 18446744073709551615) int8: 有符号 8 位整型 (-128 到 127) int16: 有符号 16 位整型 (-32768 到 32767) int32: 有符号 32 位整型 (-2147483648 到 2147483647) int64: 有符号 64 位整型 (-9223372036854775808 到 9223372036854775807) 浮点型 float32: IEEE-754 32位浮点型数 float64: IEEE-754 64位浮点型数 complex64: 32 位实数和虚数 complex128: 64 位实数和虚数 变量命名规范- 1）字母，下划线，数字 - 2）不能以数字开头 - 3）不能以关键字命名 - 4）要区分大小写变量声明变量，程序运行期间可以改变的量，关键字var 123456//var(关键字) a(变量名) int(变量类型) //var(关键字) a(变量名),b(变量名) int(变量类型)//根据赋值自动推导变量类型，注同一个变量只能使用一次c := 30//打印变量c类型的函数fmt.Printf("c type is %T\n",c) 注：变量声明之后必须引用，不然会报错 Println和Printf的区别一个小例子 1234567package mainimport "fmt"func main() &#123; a,b,c :=10,20,30 fmt.Println("a=",a,",b=",b,"c=",c) fmt.Printf("a= %d,b= %d,c= %d\n",a,b,c)&#125; 运行结果都是a= 10 ,b= 20 c= 30但明显用Printf格式更好控制 多重赋值和匿名变量123456789101112131415161718192021//a:=10 b:=20 c:=30`a,b,c :=10,20,30`//交换a,b变量的值//传统方式c=aa=bb=c//go的方式a,b,c=c,b,a//_匿名变量，丢弃不处理，_匿名变量配合函数返回值使用，才有优势（go函数可以返回多个值）func test()(a,b,c int) &#123; return 1,2,3&#125;func main() &#123; var e,f,g int e,f,g=test() fmt.Printf("e= %d,f= %d,g= %d\n",e,f,g) //如果不想要2,可以用匿名变量把2替换掉 e,_,g=test() fmt.Printf("e= %d,f= %d,g= %d\n",e,f,g)&#125; 常量常量在程序运行期间不可改变，关键字const常量声明以后不可以再赋值常量的类型推导 12const a =10.2fmt.Printf("a=%T/n",a) 多个变量/常量的定义1234567891011121314151617package mainimport "fmt"func main() &#123; var ( a int b float64 c string ) a,b,c=10,10.1,"20" fmt.Println(a,b,c) const ( //类型可以省略 i int=10 j float64=10.23 ) fmt.Println(i,j)&#125; 枚举iota iota常量自动生成器，每换一行自动加1 iota给常量赋值 iota遇到const重置为0 可以只写一个iota 如果是同一行，值都一样12345678910111213141516171819202122func main() &#123; const ( a=iota //0 b=iota //1 c=iota //2 ) fmt.Println(a,b,c) const d=iota //0 fmt.Println(d) const ( a1=iota //0 b1 //1 c1 //2 ) fmt.Println(a1,b1,c1) const ( i=iota //0 j1,j2,j3=iota,iota,iota //1 k=iota //2 ) fmt.Println(i,j1,j2,j3,k)&#125; 基本类型 bool 布尔类型 初始为false 长度1 byte 字节型 初始为0 长度1=uint8 rune 字符类型 0 长度4=uint32 int uint 整型 0 长度4/8 （uint表示无符号） int8,uint8 整型 0 长度1 int16,uint16 整型 0 长度2 int32,uint32 整型 0 长度4 int64,uint64 整型 0 长度8 float32 浮点型 长度4 float64 浮点型 长度8 complex64 复数类型 长度8 (10+20i) 不常用 complex128 复数类型 长度16 uintptr 整型 长度4或8 string 字符串 utf-8字符串 复数类型1234567891011package mainimport "fmt"func main()&#123; var t complex64 //声明 t=2.1+3.14i //赋值 fmt.Println(t) t1:=2.1+3.14i fmt.Printf("t= %T\n",t1) fmt.Println(real(t1)) //实部 fmt.Println(imag(t1)) //虚部&#125;]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>-go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇文章]]></title>
    <url>%2F2019%2F06%2F15%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[Hello World测试文章]]></content>
      <tags>
        <tag>-测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F15%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Hello World Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello-world]]></title>
    <url>%2F2019%2F06%2F15%2FHello-world-0%2F</url>
    <content type="text"><![CDATA[Hello World快乐就完事了三级标题 列表1 列表2 a 子列表 b 子列表 列表3 Hello world冒泡大佬你看我直不你看我细不&lt;html&gt;&lt;/html&gt; 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;我是标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;我是一级标题&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 我的内容是引用的哦]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
</search>
