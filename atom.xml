<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>菜鸡不配听歌</title>
  
  <subtitle>菜鸡51461的博客</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://51461.github.io/blog/"/>
  <updated>2019-07-30T03:06:26.932Z</updated>
  <id>https://51461.github.io/blog/</id>
  
  <author>
    <name>ボ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>存储过程</title>
    <link href="https://51461.github.io/blog/2019/07/30/cunchu/"/>
    <id>https://51461.github.io/blog/2019/07/30/cunchu/</id>
    <published>2019-07-30T02:31:00.000Z</published>
    <updated>2019-07-30T03:06:26.932Z</updated>
    
    <content type="html"><![CDATA[<h2 id="存储过程定义"><a href="#存储过程定义" class="headerlink" title="存储过程定义"></a>存储过程定义</h2><p>存储过程（Stored Procedure）是在大型数据库系统中，一组为了完成特定功能的SQL 语句集，它存储在数据库中，一次编译后永久有效，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。存储过程是数据库中的一个重要对象。</p><h2 id="存储过程格式"><a href="#存储过程格式" class="headerlink" title="存储过程格式"></a>存储过程格式</h2><p>CREATE PROCEDURE [拥有者.]存储过程名[;程序编号]<br>[(参数#1,…参数#1024)]<br>[WITH<br>{RECOMPILE | ENCRYPTION | RECOMPILE, ENCRYPTION}<br>][FOR REPLICATION]<br>AS 程序行<br><strong>其中存储过程名不能超过128个字。每个存储过程中最多设定1024个参数</strong><br><strong>例子</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE order_tot_amt</span><br><span class="line">@o_id int,</span><br><span class="line">@p_tot int output</span><br><span class="line">AS</span><br><span class="line">SELECT @p_tot = sum(Unitprice*Quantity)</span><br><span class="line">FROM orderdetails</span><br><span class="line">WHERE orderid=@o_id</span><br><span class="line">GO</span><br></pre></td></tr></table></figure><p><strong>该例子是建立一个简单的存储过程order_tot_amt,这个存储过程根据用户输入的订单ID号码(@o_id),由订单明细表 (orderdetails)中计算该订单销售总额[单价(Unitprice)*数量(Quantity)],这一金额通过@p_tot这一参数输出给调用这一存储过程的程序。</strong></p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>这类语言主要提供以下功能，让用户可以设计出符合应用需求的程序：<br>1)、变量说明<br>2)、ANSI（美国国家标准化组织）兼容的SQL命令(如Select,Update….)<br>3)、一般流程控制命令(if…else…、while….)<br>4)、内部函数</p><h2 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h2><h3 id="系统存储过程"><a href="#系统存储过程" class="headerlink" title="系统存储过程"></a>系统存储过程</h3><p>以sp_开头,用来进行系统的各项设定.取得信息.相关管理工作。</p><h3 id="本地存储过程"><a href="#本地存储过程" class="headerlink" title="本地存储过程"></a>本地存储过程</h3><p>用户创建的存储过程是由用户创建并完成某一特定功能的存储过程，事实上一般所说的存储过程就是指本地存储过程。</p><h3 id="临时存储过程"><a href="#临时存储过程" class="headerlink" title="临时存储过程"></a>临时存储过程</h3><p>分为两种存储过程：<br>一是本地临时存储过程，以井字号(#)作为其名称的第一个字符，则该存储过程将成为一个存放在tempdb数据库中的本地临时存储过程，且只有创建它的用户才能执行它;<br>二是全局临时存储过程，以两个井字号(##)号开始，则该存储过程将成为一个存储在tempdb数据库中的全局临时存储过程，全局临时存储过程一旦创建，以后连接到服务器的任意用户都可以执行它，而且不需要特定的权限。</p><h3 id="远程存储过程"><a href="#远程存储过程" class="headerlink" title="远程存储过程"></a>远程存储过程</h3><p>在SQL Server2005中，远程存储过程(Remote Stored Procedures)是位于远程服务器上的存储过程，通常可以使用分布式查询和EXECUTE命令执行一个远程存储过程。</p><h3 id="扩展存储过程"><a href="#扩展存储过程" class="headerlink" title="扩展存储过程"></a>扩展存储过程</h3><p>扩展存储过程(Extended Stored Procedures)是用户可以使用外部程序语言编写的存储过程，而且扩展存储过程的名称通常以xp_开头。</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h3><p>1.基本语法：exec sp_name [参数名]</p><h3 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h3><p>drop procedure sp_name<br><strong>不能在一个存储过程中删除另一个存储过程，只能调用另一个存储过程</strong></p><h3 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h3><p>show procedure status <strong>显示数据库中所有存储的存储过程基本信息，包括所属数据库，存储过程名称，创建时间等</strong><br>show create procedure sp_name <strong>显示某一个mysql存储过程的详细信息</strong><br>exec sp_helptext sp_name <strong>显示你这个sp_name这个对象创建文本</strong></p><h2 id="存储过程的优缺点"><a href="#存储过程的优缺点" class="headerlink" title="存储过程的优缺点"></a>存储过程的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>①重复使用。存储过程可以重复使用，从而可以减少数据库开发人员的工作量。<br>②减少网络流量。存储过程位于服务器上，调用的时候只需要传递存储过程的名称以及参数就可以了，因此降低了网络传输的数据量。<br>③安全性。参数化的存储过程可以防止SQL注入式攻击，而且可以将Grant、Deny以及Revoke权限应用于存储过程。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>1：调试麻烦，但是用 PL/SQL Developer 调试很方便！弥补这个缺点。<br>2：移植问题，数据库端代码当然是与数据库相关的。但是如果是做工程型项目，基本不存在移植问题。<br>3：重新编译问题，因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存储过程、包将需要重新编译（不过也可以设置成运行时刻自动编译）。<br>4：如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，接着就是系统的相关问题了，最后如果用户想维护该系统可以说是很难很难、而且代价是空前的，维护起来更麻烦。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="数据库存储过程"><a href="#数据库存储过程" class="headerlink" title="数据库存储过程"></a>数据库存储过程</h3><p>数据库存储过程的实质就是部署在数据库端的一组定义代码以及SQL。将常用的或很复杂的工作，预先用SQL语句写好并用一个指定的名称存储起来，那么以后要叫数据库提供与已定义好的存储过程的功能相同的服务时，只需调用execute，即可自动完成命令。<br>利用SQL的语言可以编写对于数据库访问的存储过程，其语法如下：<br>CREATE PROC[EDURE] procedure_name [;number]<br>[<br>{@parameter data_type} ][VARYING] [= default] [OUTPUT]<br>][,…n]<br>[WITH<br>{RECOMPILE<br>| ENCRYPTION<br>| RECOMPILE, ENCRYPTION<br>}]<br>[FOR REPLICATION]<br>AS<br>sql_statement […n]<br>[ ]内的内容是可选项，而（）内的内容是必选项，<br>例：若用户想建立一个删除表tmp中的记录的存储过程Select_delete可写为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Create</span> Proc select_del <span class="keyword">As</span></span><br><span class="line"><span class="keyword">Delete</span> tmp</span><br></pre></td></tr></table></figure><p>例：用户想查询tmp表中某年的数据的存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> proc select_query @<span class="keyword">year</span> <span class="built_in">int</span> <span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tmp <span class="keyword">where</span> <span class="keyword">year</span>=@<span class="keyword">year</span></span><br></pre></td></tr></table></figure><p>在这里@year是存储过程的参数</p><h3 id="Oracle中的存储过程"><a href="#Oracle中的存储过程" class="headerlink" title="Oracle中的存储过程"></a>Oracle中的存储过程</h3><p>1.创建过程<br>与其它的数据库系统一样，Oracle的存储过程是用PL/SQL语言编写的能完成一定处理功能的存储在数据库字典中的程序。<br>语法:<br>create [or replace] procedure procedure_name<br>[ (argment [ { in| in out }] type,<br>argment [ { in | out | in out } ] type<br>{ is | as }<br>&lt;类型.变量的说明&gt;<br>(注:不用 declare语句 )<br>Begin<br>&lt;执行部分&gt;<br>exception<br>&lt;可选的异常处理说明&gt;<br>end;<br>1.1 这里的IN表示向存储过程传递参数，OUT表示从存储过程返回参数。而IN OUT 表示传递参数和返回参数；<br>1.2 在存储过程内的参数只能指定参数类型；不能指定长度；<br>1.3 在AS或IS 后声明要用到的变量名称和变量类型及长度；<br>1.4 在AS或IS 后声明变量不要加declare 语句。<br>2.使用过程<br>存储过程建立完成后，只要通过授权，用户就可以在SQLPLUS 、Oracle开发工具或第三方开发工具来调用运行。Oracle 使用CALL 语句来实现对存储过程的调用。<br>语法：<br>call procedure_name( parameter1, parameter2…);<br>3.开发过程<br>如今的几大数据库厂商提供的编写存储过程的工具都没有统一，虽然它们的编写风格有些相似，但由于没有标准，所以各家的开发调试过程也不一样。下面编写PL/SQL存储过程、函数、包及触发器的步骤如下：<br>3.1 编辑存储过程源码使用文字编辑处理软件编辑存储过程源码，要用类似WORD文字处理软件进行编辑时，要将源码存为文本格式。<br>3.2 对存储过程程序进行解释在SQLPLUS或用调试工具将 存储过程程序进行解释；<br>在SQL&gt;下调试，可用start 或get 等Oracle命令来启动解释。如：<br>SQL&gt;start c:\stat1.sql<br>如果使用调试工具，可直接编辑和点击相应的按钮即可生成存储过程。 [1]<br>3.3 调试源码直到正确我们不能保证所写的存储过程达到一次就正确。所以这里的调试是每个程序员必须进行的工作之一。在SQLPLUS下来调试主要用的方法是：<br><strong>1．使用 SHOW ERROR命令来提示源码的错误位置；<br>2．使用 USER_ERRORS数据字典来查看各存储过程的错误位置。</strong><br>3.4 授权执行权给相关的用户或角色如果调试正确的存储过程没有进行授权，那就只有建立者本人才可以运行。所以作为应用系统的一部分的存储过程也必须进行授权才能达到要求。 在SQLPLUS下可以用GRANT命令来进行存储过程的运行授权。<br>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> system_privilege | <span class="keyword">role</span> <span class="keyword">TO</span> <span class="keyword">user</span> | <span class="keyword">role</span> | <span class="keyword">PUBLIC</span></span><br><span class="line">[<span class="keyword">WITH</span> <span class="keyword">ADMIN</span> <span class="keyword">OPTION</span>]</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> object_privilege | <span class="keyword">ALL</span> <span class="keyword">column</span> <span class="keyword">ON</span> schema.object</span><br><span class="line"><span class="keyword">TO</span> <span class="keyword">user</span> | <span class="keyword">role</span> | <span class="keyword">PUBLIC</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span></span><br></pre></td></tr></table></figure><p>其中<br>system_privilege: 系统权限<br>role: 角色名<br>user: 被授权的用户名<br>object_privilege: 所授予的权限名字，可以是<br>ALTER<br>DELETE<br>EXECUTE<br>INDEX<br>INSERT<br>REFERENCES<br>SELECT<br>UPDATE<br>Column: 列名<br>schema: 模式名<br>object: 对象名<br>4.数据字典<br>USER_SOURCE 用户的存储过程、函数的源代码字典<br>DBA_SOURCE 整个系统所有用户的存储过程、函数的源代码字典<br>ALL_SOURCE 当前用户能使用的存储过程(包括其她用户授权)、函数的源代码字典<br>USER_ERRORS 用户的存储过程、函数的源代码存在错误的信息字典<br>临时表<br>（针对SQL2000/2005）<br>可以创建本地和全局临时表。本地临时表仅在当前会话中可见；全局临时表在所有会话中都可见。<br>本地临时表的名称前面有一个编号符 (#table_name)，而全局临时表的名称前面有两个编号符 (##table_name)。<br>SQL 语句使用 CREATE TABLE 语句中为 table_name 指定的名称引用临时表：<br>CREATE TABLE #MyTempTable (cola INT PRIMARY KEY)<br>INSERT INTO #MyTempTable VALUES (1)<br>如果本地临时表由存储过程创建或由多个用户同时执行的应用程序创建，则 SQL Server 必须能够区分由不同用户创建的表。为此，SQL Server 在内部为每个本地临时表的表名追加一个数字后缀。存储在 tempdb 数据库的 sysobjects 表中的临时表，其全名由 CREATE TABLE 语句中指定的表名和系统生成的数字后缀组成。为了允许追加后缀，为本地临时表指定的表名 table_name 不能超过 116 个字符。<br>除非使用 DROP TABLE 语句显式除去临时表，否则临时表将在退出其作用域时由系统自动除去：<br>当存储过程完成时，将自动除去在存储过程中创建的本地临时表。由创建表的存储过程执行的所有嵌套存储过程都可以引用此表。但调用创建此表的存储过程的进程无法引用此表。<br>所有其它本地临时表在当前会话结束时自动除去。<br>全局临时表在创建此表的会话结束且其它任务停止对其引用时自动除去。任务与表之间的关联只在单个 Transact-SQL 语句的生存周期内保持。换言之，当创建全局临时表的会话结束时，最后一条引用此表的 Transact-SQL 语句完成后，将自动除去此表。</p><h2 id="存储过程的创建与查看"><a href="#存储过程的创建与查看" class="headerlink" title="存储过程的创建与查看"></a>存储过程的创建与查看</h2><p>创建存储过程<br>可以通过DMS或MySQL客户端登录到RDS， 创建存储过程。示例代码如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> TEST_PROC;</span><br><span class="line">DELIMITER //</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> TEST_PROC(<span class="keyword">IN</span> <span class="keyword">ID</span> <span class="built_in">int</span>,<span class="keyword">OUT</span> <span class="keyword">NAME</span> <span class="built_in">VARCHAR</span>(<span class="number">50</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">IF</span>(<span class="keyword">ID</span> = <span class="number">1</span>) <span class="keyword">THEN</span> <span class="keyword">SET</span> <span class="keyword">NAME</span> = ‘test1’;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">IF(ID = 2) THEN <span class="keyword">SET</span> <span class="keyword">NAME</span> = ‘test2’;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">version</span>();</span><br><span class="line"><span class="keyword">END</span> //;</span><br></pre></td></tr></table></figure><p>查看存储过程<br>在RDS for MySQL中，有两种方法查看数据库中的存储过程：<br>通过系统表查询<br>登录到数据库中，执行如下命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> mysql.proc <span class="keyword">where</span> db=’‘ <span class="keyword">and</span> <span class="keyword">type</span>=’<span class="keyword">procedure</span>’ <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span>;</span><br></pre></td></tr></table></figure><p>查看存储过程<br>通过show status查询<br>登录到数据库中，执行如下命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">procedure</span> <span class="keyword">status</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">procedure</span> \G;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;存储过程定义&quot;&gt;&lt;a href=&quot;#存储过程定义&quot; class=&quot;headerlink&quot; title=&quot;存储过程定义&quot;&gt;&lt;/a&gt;存储过程定义&lt;/h2&gt;&lt;p&gt;存储过程（Stored Procedure）是在大型数据库系统中，一组为了完成特定功能的SQL 语句集，它存
      
    
    </summary>
    
      <category term="数据库" scheme="https://51461.github.io/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="存储过程" scheme="https://51461.github.io/blog/tags/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
    
      <category term="数据库" scheme="https://51461.github.io/blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>linux集群环境</title>
    <link href="https://51461.github.io/blog/2019/07/03/java02/"/>
    <id>https://51461.github.io/blog/2019/07/03/java02/</id>
    <published>2019-07-03T07:50:48.000Z</published>
    <updated>2019-07-08T12:07:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="修改IP为静态IP"><a href="#修改IP为静态IP" class="headerlink" title="修改IP为静态IP"></a>修改IP为静态IP</h2><p><strong>修改配置文件</strong></p><p><strong><code>cd /etc/sysconfig/network-scripts</code>进入网络配置目录</strong><br><strong><code>dir ifcfg*</code>找到网卡配置文件</strong><br><strong><code>ifcfg-ens33</code>找到版本最新的文件并修改</strong><br><strong><code>vim ifcfg-ens33</code></strong></p><p><strong>配置文件内容</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TYPE=Ethernet</span><br><span class="line">BOOTPROTO=static#改成static，针对NAT</span><br><span class="line">NAME=eno16777736</span><br><span class="line">UUID=4cc9c89b-cf9e-4847-b9ea-ac713baf4cc8</span><br><span class="line">DEVICE=eno16777736</span><br><span class="line">DNS1=114.114.114.114#和网关相同</span><br><span class="line">ONBOOT=yes#开机启动此网卡</span><br><span class="line">IPADDR=192.168.65.161#固定IP地址192.168.65(网段).***</span><br><span class="line">NETMASK=255.255.255.0#子网掩码</span><br><span class="line">GATEWAY=192.168.65.2#网关和NAT自动配置的相同，不同则无法登录</span><br></pre></td></tr></table></figure><p><strong>重启网络</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service network restart#重启网络</span><br><span class="line">systemctl restart network.service#重启网络centos7</span><br></pre></td></tr></table></figure><p><strong>查看IP</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr#查看IP地址 ip add</span><br></pre></td></tr></table></figure><h2 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h2><p><strong><code>systemctl stop firewalld.service</code>关闭防火墙服务</strong><br><strong><code>systemctl disable firewalld.service</code>禁止防火墙开启启动</strong><br><strong><code>systemctl restart iptables.service</code>重启防火墙使配置生效</strong><br><strong><code>systemctl enable iptables.service</code>设置防火墙开机启动</strong><br><strong><code>firewall-cmd --state</code>检查防火墙状态</strong><br><strong><code>yum install -y lrzsz</code>下载安装上传文件插件</strong></p><h2 id="修改主机名"><a href="#修改主机名" class="headerlink" title="修改主机名"></a>修改主机名</h2><p><strong><code>vim /etc/hostname</code>删掉原内容,修改为想要的主机名</strong></p><p><strong>Hostname为内核属性需要重启才能生效，不想重启可以定义临时主机名</strong></p><p><strong><code>hostname hadoop01(主机名)</code>设置临时主机名</strong><br><strong><code>hostname</code>查看主机名</strong></p><h2 id="修改host文件"><a href="#修改host文件" class="headerlink" title="修改host文件"></a>修改host文件</h2><p><strong><code>vi /etc/hosts</code> ****删掉原来所有内容，改为以下</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1   localhost</span><br><span class="line">::1        localhost</span><br><span class="line"><span class="meta">#</span><span class="bash">（集群主机IP） （主机名）</span></span><br><span class="line">192.168.47.161 hadoop01</span><br><span class="line">192.168.47.162 hadoop02</span><br><span class="line">192.168.47.163 hadoop03</span><br></pre></td></tr></table></figure><h2 id="设置免密登录"><a href="#设置免密登录" class="headerlink" title="设置免密登录"></a>设置免密登录</h2><p><strong>每台都执行以下操作</strong><br><strong><code>ssh-keygen</code></strong><br><strong>然后三次直接回车不输入任何内容</strong><br><strong>得到秘钥后执行：</strong><br><strong><code>ssh-copy-id root@hadoop01    #(主机名)hadoop02、hadoop03</code>（本机也要发）</strong></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><strong><code>ssh hadoop02 #随意一个其他主机名</code>不需要输入密码直接进入说明成功，exit退出</strong></p><h2 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h2><p><strong>在用户目录 ~  中编辑go文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim go</span><br><span class="line"><span class="meta">#</span><span class="bash">编辑内容为</span></span><br><span class="line">cd /usr/local/src</span><br><span class="line"><span class="meta">#</span><span class="bash">保存后执行 . go即可到达指定目录</span></span><br></pre></td></tr></table></figure><p><strong><code>/usr/local/src</code>下创建目录java——<code>mkdir java</code></strong></p><p><strong>上传安装包并解压</strong></p><p><strong><code>tar -zxvf jdk-8u65-linux-x64.tar.gz</code>解压JDK</strong></p><p><strong><code>scp -r java/ root@hadoop02（主机名）:/usr/local/src</code>发送给集群其他主机</strong></p><p><strong>修改环境变量<code>vim /etc/profile</code></strong></p><p><strong>文档最后添加</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">set</span> java environment</span></span><br><span class="line">JAVA_HOME=/usr/local/src/java/jdk1.8.0_65#jdk路径</span><br><span class="line">JAVA_BIN=/usr/local/src/java/jdk1.8.0_65/bin #jdk下bin路径</span><br><span class="line">PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">export JAVA_HOME JAVA_BIN PATH CLASSPATH</span><br></pre></td></tr></table></figure><p><strong><code>source    /etc/profile</code>加载环境变量</strong></p><p><strong>测试<code>java -version</code></strong></p><p><strong><code>scp /etc/profile root@hadoop02（主机名）:/etc</code>发送给集群其他主机</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;修改IP为静态IP&quot;&gt;&lt;a href=&quot;#修改IP为静态IP&quot; class=&quot;headerlink&quot; title=&quot;修改IP为静态IP&quot;&gt;&lt;/a&gt;修改IP为静态IP&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;修改配置文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;co
      
    
    </summary>
    
      <category term="linux" scheme="https://51461.github.io/blog/categories/linux/"/>
    
    
      <category term="linux" scheme="https://51461.github.io/blog/tags/linux/"/>
    
      <category term="集群" scheme="https://51461.github.io/blog/tags/%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title>六大设计原则</title>
    <link href="https://51461.github.io/blog/2019/07/01/liudayuanze/"/>
    <id>https://51461.github.io/blog/2019/07/01/liudayuanze/</id>
    <published>2019-07-01T08:12:20.000Z</published>
    <updated>2019-07-03T07:27:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单一职责原则（SPR）"><a href="#单一职责原则（SPR）" class="headerlink" title="单一职责原则（SPR）"></a>单一职责原则（SPR）</h2><p><strong>单一职责的原则定义是：<font color="orange">应该有且仅有一个原因引起类的变更</font></strong></p><p><strong>单一职责原则要求一个接口或类只有一个原因引起变化，也就是一个接口或类只有一个职责，他就负责一件事情</strong></p><h3 id="单一职责原则的好处"><a href="#单一职责原则的好处" class="headerlink" title="单一职责原则的好处"></a>单一职责原则的好处</h3><p><strong>1.类的复杂性降低，实现什么职责都有清晰明确的定义</strong></p><p><strong>2.可读性提高，可维护性提高，复杂性降低</strong></p><p><strong>3.变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对应的实现类有影响，对其他接口无影响，这对系统的扩展性、维护性都有非常大的帮助</strong></p><h3 id="单一职责的使用"><a href="#单一职责的使用" class="headerlink" title="单一职责的使用"></a>单一职责的使用</h3><p><strong>单一原则提出了一个编写程序的标准，用“职责”或“变化原因”来衡量接口或类设计得是否优良，但是“职责”和“变化原因”都是不可度量的，因项目而异，因环境而异。</strong></p><p><strong>对于单一职责原则，接口一定要做到单一职责，类的设计尽可能做到单一职责</strong></p><h2 id="里式替换原则（LSP）"><a href="#里式替换原则（LSP）" class="headerlink" title="里式替换原则（LSP）"></a>里式替换原则（LSP）</h2><h3 id="继承的优缺点"><a href="#继承的优缺点" class="headerlink" title="继承的优缺点"></a>继承的优缺点</h3><h4 id="继承的优点"><a href="#继承的优点" class="headerlink" title="继承的优点"></a>继承的优点</h4><p><strong>1.代码共享，减少创造类的工作量，每个子类都有父类的方法和属性</strong></p><p><strong>2.提高代码的重用性</strong></p><p><strong>3.子类保存父类的共性，同时拥有自己的特性</strong></p><p><strong>4.提高代码可扩展性，实现父类的方法就可以“为所欲为”了，市场上大多开源框架的扩展接口都是通过继承父类实现</strong></p><p><strong>5.提高产品或项目的开放性</strong></p><h4 id="继承的缺点"><a href="#继承的缺点" class="headerlink" title="继承的缺点"></a>继承的缺点</h4><p><strong>1.只要继承就必须拥有父类所有的属性和方法</strong></p><p><strong>2.降低代码的灵活性，子类必须拥有父类的所有属性和方法，让子类多了些约束</strong></p><p><strong>3.增强了耦合性，当父类的常量、变量和方法被修改时，必须要考虑子类的修改，而且在缺乏规范的环境下，可能会需要重构大片的代码</strong></p><h3 id="里式替换原则定义"><a href="#里式替换原则定义" class="headerlink" title="里式替换原则定义"></a>里式替换原则定义</h3><p><strong>如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都替换成o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型</strong></p><p><strong>所有引用基类的地方必须能透明的使用期子类的对象</strong></p><p><strong>通俗来讲就是只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本不需要知道是父类还是子类。但是，反过来就不行了，有子类出现的地方，父类未必就能适应。</strong></p><h3 id="里式替换原则的含义"><a href="#里式替换原则的含义" class="headerlink" title="里式替换原则的含义"></a>里式替换原则的含义</h3><h4 id="子类必须完全实现父类的方法"><a href="#子类必须完全实现父类的方法" class="headerlink" title="子类必须完全实现父类的方法"></a>子类必须完全实现父类的方法</h4><p><strong>以FPS类游戏为例，描述一下里面用到的枪：</strong><br><img src="https://s2.ax1x.com/2019/07/01/Z87ICd.jpg" alt><br><strong>枪的主要职责是射击，如何射击在各个具体子类定义</strong><br><strong>枪支的抽象类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractGun</span> </span>&#123;      </span><br><span class="line"><span class="comment">//枪用来干什么的？杀敌！      </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">shoot</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>手枪、步枪、机枪的实现类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handgun</span> <span class="keyword">extends</span> <span class="title">AbstractGun</span> </span>&#123;          </span><br><span class="line">    <span class="comment">//手枪的特点是携带方便，射程短     </span></span><br><span class="line">    <span class="meta">@Override</span>      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shoot</span><span class="params">()</span> </span>&#123;              </span><br><span class="line">        System.out.println(<span class="string">"手枪射击..."</span>);      </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rifle</span> <span class="keyword">extends</span> <span class="title">AbstractGun</span></span>&#123;       </span><br><span class="line">    <span class="comment">//步枪的特点是射程远，威力大      </span></span><br><span class="line">    <span class="meta">@Override</span>      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shoot</span><span class="params">()</span></span>&#123;              </span><br><span class="line">        System.out.println(<span class="string">"步枪射击..."</span>);      </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MachineGun</span> <span class="keyword">extends</span> <span class="title">AbstractGun</span></span>&#123;          </span><br><span class="line">    <span class="meta">@Override</span>       </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shoot</span><span class="params">()</span></span>&#123;              </span><br><span class="line">        System.out.println(<span class="string">"机枪扫射..."</span>);      </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>士兵的实现类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Soldier</span> </span>&#123;      </span><br><span class="line">    <span class="comment">//定义士兵的枪支      </span></span><br><span class="line">    <span class="keyword">private</span> AbstractGun gun;      </span><br><span class="line">    <span class="comment">//给士兵一支枪      </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGun</span><span class="params">(AbstractGun _gun)</span></span>&#123;              </span><br><span class="line">        <span class="keyword">this</span>.gun = _gun;       </span><br><span class="line">    &#125;      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">killEnemy</span><span class="params">()</span></span>&#123;              </span><br><span class="line">        System.out.println(<span class="string">"士兵开始杀敌人..."</span>);              </span><br><span class="line">        gun.shoot();      </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;              </span><br><span class="line">        <span class="comment">//产生三毛这个士兵              </span></span><br><span class="line">        Soldier sanMao = <span class="keyword">new</span> Soldier();             </span><br><span class="line">        <span class="comment">//给三毛一支枪              </span></span><br><span class="line">        sanMao.setGun(<span class="keyword">new</span> Rifle());              </span><br><span class="line">        sanMao.killEnemy();      </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">士兵开始杀敌人...</span><br><span class="line">步枪射击...</span><br></pre></td></tr></table></figure><p><strong>如果要使用机枪可以直接把<code>sanMao.setGun(new Rifle());</code>改为<code>sanMao.setGun(new MachineGun());</code>即可，在编写程序时士兵类根本不需要知道是哪个子类(枪)被传入</strong></p><p><strong>注意    在类中调用其他类时务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了LSP原则</strong><br><strong>如果子类不能完整的实现父类方法，或者某些父类方法在子类中发生“畸变”，则建议断开继承关系，采用依赖、聚集、组合等关系代替继承</strong></p><h4 id="子类可以有自己的特性"><a href="#子类可以有自己的特性" class="headerlink" title="子类可以有自己的特性"></a>子类可以有自己的特性</h4><p><strong>子类可以有自己的方法和属性，LSP可以正着用，但是不能反过来用，在子类出现的地方，父类未必可以使用。还是以FPS游戏为例，步枪可分为AK47、AUG狙击步枪等，把这两把枪引入之后的子类图：</strong><br><img src="https://s2.ax1x.com/2019/07/01/Z8vrXd.jpg" alt><br><strong>AUG狙击步枪类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AUG</span> <span class="keyword">extends</span> <span class="title">Rifle</span> </span>&#123;      </span><br><span class="line">    <span class="comment">//狙击枪都携带一个精准的望远镜      </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zoomOut</span><span class="params">()</span></span>&#123;              </span><br><span class="line">        System.out.println(<span class="string">"通过望远镜察看敌人..."</span>);      </span><br><span class="line">    &#125;      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shoot</span><span class="params">()</span></span>&#123;              </span><br><span class="line">        System.out.println(<span class="string">"AUG射击..."</span>);      </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>狙击手类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Snipper</span> </span>&#123;              </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">killEnemy</span><span class="params">(AUG aug)</span></span>&#123;              </span><br><span class="line">        <span class="comment">//首先看看敌人的情况，别杀死敌人，自己也被人干掉              </span></span><br><span class="line">        aug.zoomOut();              </span><br><span class="line">        <span class="comment">//开始射击              </span></span><br><span class="line">        aug.shoot();      </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;       </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;              </span><br><span class="line">        <span class="comment">//产生三毛这个狙击手              </span></span><br><span class="line">        Snipper sanMao = <span class="keyword">new</span> Snipper();              </span><br><span class="line">        sanMao.setRifle(<span class="keyword">new</span> AUG());              </span><br><span class="line">        sanMao.killEnemy();      </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通过望远镜察看敌人... </span><br><span class="line">AUG射击...</span><br></pre></td></tr></table></figure><p><strong>在这里如果换成了父类会在运行期抛出java.lang.ClassCastException异常，也就是向下转型不安全</strong></p><h4 id="覆盖或实现父类的方法时输入参数可以被放大"><a href="#覆盖或实现父类的方法时输入参数可以被放大" class="headerlink" title="覆盖或实现父类的方法时输入参数可以被放大"></a>覆盖或实现父类的方法时输入参数可以被放大</h4><p><strong>里式替换原则要求定制一个契约，就是父类或接口，这种设计方法也叫做Design by Contract（契约设计），与LSP有异曲同工之妙。契约制定了，也就同时制定了前置条件和后置条件，前置条件就是你要让我执行，就必须满足我的条件；后置条件就是我执行完了需要反馈，标准是什么。</strong></p><p><strong>子类中方法的前置条件必须与超类中被覆写的方法的前置条件相同或者更宽松</strong></p><h4 id="覆盖或实现父类的方法时输出结果可以被缩小"><a href="#覆盖或实现父类的方法时输出结果可以被缩小" class="headerlink" title="覆盖或实现父类的方法时输出结果可以被缩小"></a>覆盖或实现父类的方法时输出结果可以被缩小</h4><p><strong>父类的一个方法的返回值是一个类型T，子类的相同方法（重载或覆写）的返回值为S，那么里氏替换原则就要求S必须小于等于T，也就是说，要么S和T是同一个类型，要么S是T的子类</strong></p><p><strong><font color="orange">覆写</font>，父类和子类的同名方法的输入参数是相同的，两个方法的范围值S小于等于T，这是覆写的要求，这才是重中之重，子类覆写父类的方法，天经地义。</strong></p><p><strong><font color="orange">重载</font>，则要求方法的输入参数类型或数量不相同，在里氏替换原则要求下，就是子类的输入参数宽于或等于父类的输入参数，也就是说你写的这个方法是不会被调用的。</strong></p><h3 id="LSP的最佳使用"><a href="#LSP的最佳使用" class="headerlink" title="LSP的最佳使用"></a>LSP的最佳使用</h3><p><strong>在项目中，采用里氏替换原则时，尽量避免子类的“个性”，一旦子类有“个性”，这个子类和父类之间的关系就很难调和了，把子类当做父类使用，子类的“个性”被抹杀——委屈了点；把子类单独作为一个业务来使用，则会让代码间的耦合关系变得扑朔迷离——缺乏类替换的标准。</strong></p><h2 id="依赖倒置原则（DIP）"><a href="#依赖倒置原则（DIP）" class="headerlink" title="依赖倒置原则（DIP）"></a>依赖倒置原则（DIP）</h2><h3 id="依赖倒置原则定义"><a href="#依赖倒置原则定义" class="headerlink" title="依赖倒置原则定义"></a>依赖倒置原则定义</h3><p><strong>1.高层模块不应该依赖低层模块，两者都应该依赖其抽象</strong></p><p><strong>2.抽象不应该依赖细节</strong></p><p><strong>3.细节应该依赖抽象</strong></p><hr><p><strong>不可分割的原子逻辑就是低层模块，原子逻辑再组装的就是高层模块</strong><br><strong><font color="f05f00">抽象</font>就是指接口或抽象类，两者都是<font color="f05f00">不能直接被实例化</font>的</strong><br><strong><font color="f05f00">细节</font>就是实现类，实现接口或继承抽象类而生成的类就是细节，其<font color="f05f00">特点是可以直接实例化</font>，可以直接new一个对象。</strong></p><hr><h4 id="依赖倒置原则在Java中的表现"><a href="#依赖倒置原则在Java中的表现" class="headerlink" title="依赖倒置原则在Java中的表现"></a>依赖倒置原则在Java中的表现</h4><p><strong>1.模块间的依赖通过抽象发生，实现类之间不发生之间的依赖关系，其依赖关系是通过接口或抽象类产生的</strong></p><p><strong>2.接口或抽象类不依赖于实现类</strong></p><p><strong>3.实现类依赖接口或抽象类</strong></p><p><strong>总而言之就是<font color="f05f00">“面向接口编程”</font>——OOD的精髓之一</strong></p><h3 id="依赖倒置原则的优点"><a href="#依赖倒置原则的优点" class="headerlink" title="依赖倒置原则的优点"></a>依赖倒置原则的优点</h3><p><strong>1.减少类间的耦合性</strong></p><p><strong>2.提高系统的稳定性</strong></p><p><strong>3.降低并行开发引起的风险</strong></p><p><strong>4.提高代码的可读性和可维护性</strong></p><h3 id="依赖的三种写法"><a href="#依赖的三种写法" class="headerlink" title="依赖的三种写法"></a>依赖的三种写法</h3><p><strong>1.构造函数传递依赖对象</strong></p><p><strong>2.Setter方法传递依赖对象</strong></p><p><strong>3.接口声明依赖对象</strong></p><h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p><strong>实例接口，在java中声明一个类，然后用new关键字产生一个实例，它是对一个类型的事物的描述，也是一种接口</strong></p><p><strong>类接口，java中用interface关键字定义的接口</strong></p><h3 id="接口隔离原则的定义"><a href="#接口隔离原则的定义" class="headerlink" title="接口隔离原则的定义"></a>接口隔离原则的定义</h3><p><strong>1.客户端不应该依赖它不需要的接口</strong></p><p><strong>2.类间的依赖关系应该建立在最小的接口上</strong></p><p><strong>建立单一接口，不要建立臃肿庞大的接口，通俗来讲就是接口尽量细化，同时接口中的方法尽量少</strong></p><h4 id="接口隔离原则的4层含义"><a href="#接口隔离原则的4层含义" class="headerlink" title="接口隔离原则的4层含义"></a>接口隔离原则的4层含义</h4><p><strong>1.接口要尽量小</strong><br><strong>不出现臃肿的接口，在拆分之前首先得保证它遵守单一职责原则</strong></p><p><strong>2.接口要高内聚</strong><br><strong>高内聚就是提高接口、类、模块的处理能力，减少对外的交互。应用到接口隔离原则就是在接口中尽量少公布public方法，接口是对外的承诺，承诺越少对系统开发越有利，变更的风险也就越少</strong></p><p><strong>3.定制服务</strong><br><strong>一个系统或系统内的模块之间必然会有耦合，有耦合就要有相互访问的接口（并不一定就是Java中定义的Interface，也可能是一个类或单纯的数据交换），我们设计时就需要为各个访问者（即客户端）定制服务</strong><br><strong>定制服务就是单独为一个个体提供优良的服务。我们在做系统设计时也需要考虑对系统之间或模块之间的接口采用定制服务。采用定制服务就必然有一个要求：<font color="orange">只提供访问者需要的方法</font>。</strong></p><p><strong>4.接口设计是有限度的</strong><br><strong>接口设计粒度越小，系统越灵活</strong></p><h3 id="接口隔离原则最佳使用"><a href="#接口隔离原则最佳使用" class="headerlink" title="接口隔离原则最佳使用"></a>接口隔离原则最佳使用</h3><p><strong>一个接口只服务于一个子模块或业务逻辑</strong></p><p><strong>通过业务逻辑压缩接口中的public方法，接口时常去回顾，尽量让接口达到“满身筋骨肉”，而不是“肥嘟嘟”的一大堆方法</strong></p><p><strong>已经被污染了的接口，尽量去修改，若变更的风险较大，则采用适配器模式进行转化处理</strong></p><p><strong>了解环境，拒绝盲从。每个项目或产品都有特定的环境因素，别看到大师是这样做的你就照抄。千万别，环境不同，接口拆分的标准就不同。深入了解业务逻辑，最好的接口设计就出自你的手中！</strong></p><h2 id="迪米特法则（LoD）"><a href="#迪米特法则（LoD）" class="headerlink" title="迪米特法则（LoD）"></a>迪米特法则（LoD）</h2><p><strong>也被称为最少知识原则（LKP）</strong></p><p><strong>也被称为最少知识原则</strong></p><p><strong>一个对象应该对其他对象有最少的了解。</strong><br><strong>通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少，你（被耦合或调用的类）的内部是如何复杂都和我没关系，那是你的事情，我就知道你提供的这么多public方法，我就调用这么多，其他的我一概不关心。</strong></p><h3 id="迪米特法则的4层含义"><a href="#迪米特法则的4层含义" class="headerlink" title="迪米特法则的4层含义"></a>迪米特法则的4层含义</h3><p><strong>1.只和朋友交流</strong></p><p><strong>两个对象之间的耦合就会成为朋友关系</strong><br><strong>朋友类的定义：出现在成员变量、方法的输入输出参数中的类称为成员朋友类，而出现在方法体内部的类不属于朋友类</strong></p><p><strong>2.朋友间也是有距离的</strong></p><p><strong>一个类公开的public属性或方法越多，修改时涉及到的面越广，变更引起的风险扩散也就越大。因此为了保持朋友类间的距离，在设计时需要反复衡量，是否可以修改为private、package-private（包类型，不加访问权限时默认为包类型）、protected等访问权限，是否可以加上final关键字等。</strong><br><strong>迪米特法则要求类尽量不要对外公布太多的public方法和非静态的public变量，尽量多使用private、package-private、protected等访问权限</strong></p><p><strong>3.是自己的就是自己的</strong></p><p><strong>如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，那就放置在本类中。</strong></p><p><strong>4.谨慎使用Serializable</strong></p><h3 id="迪米特法则的最佳使用"><a href="#迪米特法则的最佳使用" class="headerlink" title="迪米特法则的最佳使用"></a>迪米特法则的最佳使用</h3><p><strong>迪米特法则的核心观念就是类间解耦，弱耦合，只有弱耦合了以后，类的复用率在可以提高。其要求的结果就是产生了大量的中转或跳转类，导致系统的复杂性提高，同时也为维护带来了难度。在采用迪米特法则时，需要反复权衡，<font color="f05ff0">既做到让结构清晰，又做到高内聚低耦合</font></strong></p><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><h3 id="开闭原则的定义"><a href="#开闭原则的定义" class="headerlink" title="开闭原则的定义"></a>开闭原则的定义</h3><p><strong>一个软件实体如类、模块、函数应该对外扩展开放，对修改类关闭</strong><br><strong>也就是说，一个软件实体应该通过扩展来实现变化，而不是通过修改已有代码来实现变化。</strong></p><h4 id="软件实体"><a href="#软件实体" class="headerlink" title="软件实体"></a>软件实体</h4><p><strong>项目或软件产品中按照一定的逻辑规则划分的模块</strong><br><strong>抽象和类</strong><br><strong>方法</strong></p><hr><p><strong>开闭原则对扩展开放，对修改关闭，并不意味着不做任何修改，低层模块的变更，必然要有高层模块进行耦合，否则就是一个孤立无意义的代码片段</strong></p><hr><h3 id="开闭原则的好处"><a href="#开闭原则的好处" class="headerlink" title="开闭原则的好处"></a>开闭原则的好处</h3><p><strong>1.开闭原则对测试的影响</strong></p><p><strong>2.开闭原则可以提高复用性</strong></p><p><strong>3.开闭原则可以提高可维护性</strong></p><p><strong>4.面向对象开发的要求</strong></p><h3 id="如何使用开闭原则"><a href="#如何使用开闭原则" class="headerlink" title="如何使用开闭原则"></a>如何使用开闭原则</h3><p><strong>1.抽象约束</strong><br><strong>抽象是对一组事物的通用描述，没有具体的实现，也就表示它可以有非常多的可能性，可以跟随需求的变化而变化。因此，通过接口或抽象类可以约束一组可能变化的行为，并且能够实现对扩展开放。</strong></p><p><strong>2.元数据（metadata）控制模块行为</strong><br><strong>元数据就是用来描述环境和数据的数据，通俗来说就是配置参数</strong></p><p><strong>3.制定项目章程</strong><br><strong>章程中指定了所有人员必须遵守的约定，对项目来说，约定优于配置。</strong></p><p><strong>4.封装变化</strong><br><strong>对变化的封装包含两层含义：第一，将相同的变化封装到一个接口或抽象类中。第二，将不同变化封装到不同的接口或抽象类中，不应该有两个不同的变化出现在同一接口或抽象类中。</strong><br><strong>封装变化也就是封装可能发生的变化</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;单一职责原则（SPR）&quot;&gt;&lt;a href=&quot;#单一职责原则（SPR）&quot; class=&quot;headerlink&quot; title=&quot;单一职责原则（SPR）&quot;&gt;&lt;/a&gt;单一职责原则（SPR）&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;单一职责的原则定义是：&lt;font color=&quot;or
      
    
    </summary>
    
      <category term="设计模式" scheme="https://51461.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="https://51461.github.io/blog/tags/java/"/>
    
      <category term="设计模式" scheme="https://51461.github.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>常用的算法思想——2</title>
    <link href="https://51461.github.io/blog/2019/06/29/suanfan002/"/>
    <id>https://51461.github.io/blog/2019/06/29/suanfan002/</id>
    <published>2019-06-29T12:39:04.000Z</published>
    <updated>2019-06-29T13:25:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p><strong>贪心算法也被成为“贪婪算法”，它在求解问题时总想用当前看来是最好的方法来实现。这种算法不从整体最优上考虑问题，仅仅是在某种意义上的局部最优求解。</strong></p><h3 id="贪心算法基础"><a href="#贪心算法基础" class="headerlink" title="贪心算法基础"></a>贪心算法基础</h3><p><strong>贪心算法从问题的某一个初始解出发，逐步逼近给定的目标，以便尽快求出更好的解。当达到算法中的某一步不能再继续前进时就停止算法，给出一个近似解。</strong></p><h3 id="贪心算法的问题"><a href="#贪心算法的问题" class="headerlink" title="贪心算法的问题"></a>贪心算法的问题</h3><p><strong>1.不能保证最后的解是最优解</strong></p><p><strong>2.不能用来求最大或最小解问题</strong></p><p><strong>3.只能求满足某些约束条件的可行解的范围</strong></p><h3 id="贪心算法的基本思路"><a href="#贪心算法的基本思路" class="headerlink" title="贪心算法的基本思路"></a>贪心算法的基本思路</h3><p><strong>1.建立数学模型来描述问题</strong></p><p><strong>2.把求解的问题分成若干个子问题</strong></p><p><strong>3.对每一个子问题求解，得到子问题的局部最优解</strong></p><p><strong>4.把子问题的局部最优解合并成原来问题的一个解</strong></p><h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><p><strong>1.从问题的某一初始解出发</strong></p><p><strong>2.while能向给定总目标前进一步</strong></p><p><strong>3.求出可行解的一个解元素</strong></p><p><strong>4.由所有解元素组合成问题的一个可行解</strong></p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><h4 id="“装箱”问题"><a href="#“装箱”问题" class="headerlink" title="“装箱”问题"></a>“装箱”问题</h4><p><strong>假设有编号分别为0,1…，n-1的n种物品，体积分别为V0,V1…，Vn-1。将这n种物品装到容量都为V的若干箱子里，约定这n种物品体积都不超过V，即对于0&lt;=i&lt;n,有0&lt;V1&lt;=V。不同的装箱方案所需要箱子可能不同。装箱问题要求用最少的箱子装下这n种物品</strong></p><h4 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h4><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;贪心算法&quot;&gt;&lt;a href=&quot;#贪心算法&quot; class=&quot;headerlink&quot; title=&quot;贪心算法&quot;&gt;&lt;/a&gt;贪心算法&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;贪心算法也被成为“贪婪算法”，它在求解问题时总想用当前看来是最好的方法来实现。这种算法不从整体最优上考虑问题
      
    
    </summary>
    
      <category term="算法" scheme="https://51461.github.io/blog/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="https://51461.github.io/blog/tags/java/"/>
    
      <category term="算法" scheme="https://51461.github.io/blog/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="https://51461.github.io/blog/2019/06/29/shejimoshi/"/>
    <id>https://51461.github.io/blog/2019/06/29/shejimoshi/</id>
    <published>2019-06-29T12:04:56.000Z</published>
    <updated>2019-07-01T08:13:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p><strong>确保一个类只有一个实例，并提供该实例的全局访问点</strong></p><p><strong>使用一个私有构造函数、一个私有静态变量以及一个公有静态函数来实现。</strong></p><p><strong>私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。</strong></p><h3 id="懒汉式——线程不安全"><a href="#懒汉式——线程不安全" class="headerlink" title="懒汉式——线程不安全"></a>懒汉式——线程不安全</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>私有静态变量 uniqueInstance 被延迟实例化，这样做的好处是，如果没有用到该类，那么就不会实例化 uniqueInstance，从而节约资源。</strong></p><p><strong>这个实现在多线程环境下是不安全的，如果多个线程能够同时进入 <code>if (uniqueInstance == null)</code> ，并且此时 uniqueInstance 为 null，那么会有多个线程执行 <code>uniqueInstance = new Singleton();</code> 语句，这将导致实例化多次 uniqueInstance。</strong></p><h3 id="饿汉式——线程安全"><a href="#饿汉式——线程安全" class="headerlink" title="饿汉式——线程安全"></a>饿汉式——线程安全</h3><p><strong>线程不安全问题主要是由于 uniqueInstance 被实例化多次，采取直接实例化 uniqueInstance 的方式就不会产生线程不安全问题。</strong></p><p><strong>但是直接实例化的方式也丢失了延迟实例化带来的节约资源的好处。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance = <span class="keyword">new</span> Singleton();</span><br></pre></td></tr></table></figure><h3 id="懒汉式——线程安全"><a href="#懒汉式——线程安全" class="headerlink" title="懒汉式——线程安全"></a>懒汉式——线程安全</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>只需要对 getUniqueInstance() 方法加锁，那么在一个时间点只能有一个线程能够进入该方法，从而避免了实例化多次 uniqueInstance。</strong></p><p><strong>但是当一个线程进入该方法之后，其它试图进入该方法的线程都必须等待，即使 uniqueInstance 已经被实例化了。这会让线程阻塞时间过长，因此该方法有性能问题，不推荐使用。</strong></p><h3 id="双重锁——线程安全"><a href="#双重锁——线程安全" class="headerlink" title="双重锁——线程安全"></a>双重锁——线程安全</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>uniqueInstance 只需要被实例化一次，之后就可以直接使用了。加锁操作只需要对实例化那部分的代码进行，只有当 uniqueInstance 没有被实例化时，才需要进行加锁。</strong></p><p><strong>双重校验锁先判断 uniqueInstance 是否已经被实例化，如果没有被实例化，那么才对实例化语句进行加锁。</strong></p><h3 id="静态内部类实现"><a href="#静态内部类实现" class="headerlink" title="静态内部类实现"></a>静态内部类实现</h3><p><strong>当 Singleton 类被加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 <code>getUniqueInstance()</code> 方法从而触发 <code>SingletonHolder.INSTANCE</code> 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。</strong></p><p><strong>这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举实现"><a href="#枚举实现" class="headerlink" title="枚举实现"></a>枚举实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String objName;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getObjName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> objName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObjName</span><span class="params">(String objName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.objName = objName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单例测试</span></span><br><span class="line">        Singleton firstSingleton = Singleton.INSTANCE;</span><br><span class="line">        firstSingleton.setObjName(<span class="string">"firstName"</span>);</span><br><span class="line">        System.out.println(firstSingleton.getObjName());</span><br><span class="line">        Singleton secondSingleton = Singleton.INSTANCE;</span><br><span class="line">        secondSingleton.setObjName(<span class="string">"secondName"</span>);</span><br><span class="line">        System.out.println(firstSingleton.getObjName());</span><br><span class="line">        System.out.println(secondSingleton.getObjName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反射获取实例测试</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Singleton[] enumConstants = Singleton.class.getEnumConstants();</span><br><span class="line">            <span class="keyword">for</span> (Singleton enumConstant : enumConstants) &#123;</span><br><span class="line">                System.out.println(enumConstant.getObjName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>该实现可以防止反射攻击。在其它实现中，通过 setAccessible() 方法可以将私有构造函数的访问级别设置为 public，然后调用构造函数从而实例化对象，如果要防止这种攻击，需要在构造函数中添加防止多次实例化的代码。该实现是由 JVM 保证只会实例化一次，因此不会出现上述的反射攻击。</strong></p><p><strong>该实现在多次序列化和序列化之后，不会得到多个实例。而其它实现需要使用 transient 修饰所有字段，并且实现序列化和反序列化的方法。</strong></p><p><strong>测试结果：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">firstName</span><br><span class="line">secondName</span><br><span class="line">secondName</span><br><span class="line">secondName</span><br></pre></td></tr></table></figure><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p><strong>在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。</strong></p><p><strong>简单工厂把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化。</strong></p><p><strong>这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类。客户类往往有多个，如果不使用简单工厂，那么所有的客户类都要知道所有子类的细节。而且一旦子类发生改变，例如增加子类，那么所有的客户类都要进行修改。</strong></p><h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h2><p><strong>定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。</strong></p><p><strong>在简单工厂中，创建对象的是另一个类，而在工厂方法中，是由子类来创建对象。</strong></p><h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><p><strong>提供一个接口，用于创建<font color="orange">相关的对象家族</font>。</strong></p><p><strong>抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同。</strong></p><p><strong>抽象工厂模式用到了工厂方法模式来创建单一对象，AbstractFactory 中的 createProductA() 和 createProductB() 方法都是让子类来实现，这两个方法单独来看就是在创建一个对象，这符合工厂方法模式的定义。</strong></p><p><strong>至于创建对象的家族这一概念是在 Client 体现，Client 要通过 AbstractFactory 同时调用两个方法来创建出两个对象，在这里这两个对象就有很大的相关性，Client 需要同时创建出这两个对象。</strong></p><p><strong>从高层次来看，抽象工厂使用了组合，即 Cilent 组合了 AbstractFactory，而工厂方法模式使用了继承。</strong></p><hr><p>工厂模式小demo（<a href="https://github.com/51461/factory" target="_blank" rel="noopener">https://github.com/51461/factory</a> ）</p><hr><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;确保一个类只有一个实例，并提供该实例的全局访问点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用一个私
      
    
    </summary>
    
      <category term="设计模式" scheme="https://51461.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="https://51461.github.io/blog/tags/java/"/>
    
      <category term="设计模式" scheme="https://51461.github.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Git常用密令</title>
    <link href="https://51461.github.io/blog/2019/06/29/git/"/>
    <id>https://51461.github.io/blog/2019/06/29/git/</id>
    <published>2019-06-29T11:06:02.000Z</published>
    <updated>2019-07-01T05:30:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="新建本地代码库"><a href="#新建本地代码库" class="headerlink" title="新建本地代码库"></a>新建本地代码库</h2><p><strong>git  init   在当前目录下新建一个git代码库</strong></p><p><strong>git init [project-name]  新建一个目录，将其初始化为Git代码库</strong></p><p><strong>git  clone[url]   下载一个项目和它的整个代码历史</strong></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p><strong># 显示当前的Git配置</strong><br><strong>git  config --list</strong></p><p><strong># 编辑Git配置文件</strong><br><strong>git config -e [--global]</strong></p><p><strong># 设置提交代码时的用户信息</strong><br><strong>git config [--global] user.name “[name]”</strong><br><strong>git config [--global] user.email “[email address]”</strong></p><h2 id="生成ssh密钥"><a href="#生成ssh密钥" class="headerlink" title="生成ssh密钥"></a>生成ssh密钥</h2><p><strong>ssh-keygen -t rsa -C “[email address]”</strong></p><h2 id="增加-删除文件"><a href="#增加-删除文件" class="headerlink" title="增加/删除文件"></a>增加/删除文件</h2><p><strong>git  add[file1][file2]…   添加指定文件到暂存区</strong></p><p><strong>git  add  .           添加当前目录的所有文件到暂存区</strong></p><p><strong>git add -p   添加每个变化前，都会要求确认对于同一个文件的多处变化，可以实现分次提交</strong></p><p><strong>git rm [file1] [file2] …  删除工作区文件，并且将这次删除放入暂存区</strong></p><p><strong>git rm --cached [file]  停止追踪指定文件，但该文件会保留在工作区</strong></p><p><strong>git mv [file-original] [file-renamed]  更改文件名，并且将这个改名放入暂存区</strong></p><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h2><p><strong>git  commit -m[message]  提交暂存区到仓库区</strong></p><p><strong>git  commit  [file1][file2]… -m[message]  提交暂存区的指定文件到仓库区</strong></p><p><strong>$ git commit -a  提交工作区自上次commit之后的变化，直接到仓库区</strong></p><p><strong>git commit -v  提交时显示所有diff信息</strong></p><p><strong>git commit --amend -m [message]  使用一次新的commit，替代上一次提交,如果代码没有任何新变化，则用来改写上一次commit的提交信息</strong></p><p><strong>git commit --amend [file1] [file2] …   重做上一次commit，并包括指定文件的新变化</strong></p><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p><strong>git  branch                  列出所有本地分支</strong><br><strong>git branch -r    列出远程所有分支</strong><br><strong>git  branch  -a              列出所有本地分支和远程分支</strong><br><strong>git  branch [branch-name]    新建一个分支但依然停留在当前分支</strong><br><strong>git  checkout -b   [branch]   新建一个分支并切换到该分支</strong><br><strong>git  checkout    [branch-name]   切换到指定分支并更新工作区</strong><br><strong>git  checkout -b   [branch]   新建一个分支并切换到该分支</strong><br><strong>git branch [branch] [commit]   新建一个分支，指向指定commit</strong><br><strong>git branch --track [branch] [remote-branch]    新建一个分支，与指定的远程分支建立追踪关系</strong><br><strong>git checkout [branch-name]   切换到指定分支，并更新工作区</strong><br><strong>git  checkout -              切换到上一个分支</strong><br><strong>git branch --set-upstream [branch] [remote-branch]  建立追踪关系，在现有分支与指定的远程分支之间</strong><br><strong>git merge [branch]   合并指定分支到当前分支</strong><br><strong>git cherry-pick [commit]  选择一个commit，合并进当前分支</strong><br><strong>git  branch   -d[branch-name] 删除分支</strong><br><strong>git push origin --delete [branch-name]  删除远程分支</strong><br><strong>git branch -dr [remote/branch]   删除远程分支</strong></p><h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><p><strong>git  status        查看有变更的文件</strong><br><strong>git  log          查看当前分支的版本历史</strong><br><strong>git log --stat   显示commit历史，以及每次commit发生变更的文件</strong><br><strong>git log -S [keyword]   搜索提交历史，根据关键词</strong><br><strong>git log [tag] HEAD --pretty=format:%s   显示某个commit之后的所有变动，每个commit占据一行</strong><br><strong>git log [tag] HEAD --grep feature  显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件</strong><br><strong>显示某个文件的版本历史，包括文件改名<br><code>git log --follow [file]</code><br><code>git whatchanged [file]</code></strong><br><strong>git log -p [file]   显示指定文件相关的每一次diff</strong><br><strong>git log -5 --pretty --oneline   显示过去5次提交</strong><br><strong>git shortlog -sn   显示所有提交过的用户，按提交次数排序</strong><br><strong>git blame [file]   显示指定文件是什么人在什么时间修改过</strong><br><strong>git  diff          显示暂存区和工作区的差异</strong><br><strong>显示暂存区和上一个commit的差异<code>$ git diff --cached [file]</code></strong><br><strong>显示工作区与当前分支最新commit之间的差异<code>$ git diff HEAD</code></strong><br><strong>显示两次提交之间的差异<code>$ git diff [first-branch]...[second-branch]</code></strong><br><strong>显示今天你写了多少行代码<code>$ git diff --shortstat &quot;@{0 day ago}&quot;</code></strong><br><strong>git  show[commit]      显示每次提交的元数据和内容变化</strong><br><strong>git show --name-only [commit]   显示某次提交发生变化的文件</strong><br><strong>git show [commit]:[filename]   显示某次提交时，某个文件的内容</strong><br><strong>git  rebase [branch]   从本地master拉取代码更新当前分支branch 一般为master</strong></p><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p><strong># 列出所有tag<code>$ git tag</code></strong></p><p><strong>新建一个tag在当前commit<code>$ git tag [tag]</code></strong></p><p><strong>新建一个tag在指定commit<code>$ git tag [tag] [commit]</code></strong></p><p><strong>删除本地tag<code>$ git tag -d [tag]</code></strong></p><p><strong>删除远程tag</strong><code>$ git push origin :refs/tags/[tagName]</code>**</p><p><strong>查看tag信息<code>$ git show [tag]</code></strong></p><p><strong>提交指定tag<code>$ git push [remote] [tag]</code></strong></p><p><strong>提交所有tag<code>git push [remote] --tags</code></strong></p><p><strong>新建一个分支，指向某个tag<code>$ git checkout -b [branch] [tag]</code></strong></p><h2 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h2><p><strong>git  pull [remote][branch]       取回远程仓库变化，并与本地分支合并</strong></p><p><strong>git  push  [remote][branch]     上传本地指定的分支到远程仓库</strong></p><p><strong>git fetch [remote]   下载远程仓库的所有变动</strong></p><p><strong>git remote -v   显示所有远程仓库</strong></p><p><strong>显示某个远程仓库的信息</strong><br><strong>$ git remote show [remote]</strong></p><p><strong>增加一个新的远程仓库，并命名</strong><br><strong>$ git remote add [shortname] [url]</strong></p><p><strong>取回远程仓库的变化，并与本地分支合并</strong><br><strong>$ git pull [remote]\ [branch]</strong></p><p> <strong>上传本地指定分支到远程仓库</strong><br><strong>$ git push [remote] [branch]</strong></p><p><strong>强行推送当前分支到远程仓库，即使有冲突</strong><br><strong>$ git push [remote] --force</strong></p><p><strong>推送所有分支到远程仓库</strong><br><strong>$ git push [remote] --all</strong></p><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><p><strong>恢复暂存区的指定文件到工作区</strong><br><strong>$ git checkout [file]</strong></p><p><strong>恢复某个commit的指定文件到暂存区和工作区</strong><br><strong>$ git checkout [commit] [file]</strong></p><p><strong>恢复暂存区的所有文件到工作区</strong><br><strong>$ git checkout .</strong></p><p><strong>重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</strong><br><strong>$ git reset [file]</strong></p><p><strong>重置暂存区与工作区，与上一次commit保持一致</strong><br><strong>$ git reset --hard</strong></p><p><strong>重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</strong><br><strong>$ git reset [commit]</strong></p><p><strong>重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</strong><br><strong>$ git reset --hard [commit]</strong></p><p><strong>重置当前HEAD为指定commit，但保持暂存区和工作区不变</strong><br><strong>$ git reset --keep [commit]</strong></p><p><strong>新建一个commit，用来撤销指定commit,后者的所有变化都将被前者抵消，并且应用到当前分支</strong><br><strong>$ git revert [commit]</strong></p><p><strong>暂时将未提交的变化移除，稍后再移入</strong><br><strong>$ git stash</strong><br><strong>$ git stash pop</strong></p><h2 id="graph"><a href="#graph" class="headerlink" title="graph"></a>graph</h2><p><strong>列表工具，使用方式：<code>git log --graph</code></strong></p><h2 id="gitk"><a href="#gitk" class="headerlink" title="gitk"></a>gitk</h2><p><strong>可视化工具，直接在gitbase输入gitk即可</strong></p><hr><p><strong>git详细介绍： <a href="https://git-scm.com/book/zh/v1" target="_blank" rel="noopener">https://git-scm.com/book/zh/v1</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;新建本地代码库&quot;&gt;&lt;a href=&quot;#新建本地代码库&quot; class=&quot;headerlink&quot; title=&quot;新建本地代码库&quot;&gt;&lt;/a&gt;新建本地代码库&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;git  init   在当前目录下新建一个git代码库&lt;/strong&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="Git" scheme="https://51461.github.io/blog/categories/Git/"/>
    
    
      <category term="Git" scheme="https://51461.github.io/blog/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>jvm&amp;GC基础</title>
    <link href="https://51461.github.io/blog/2019/06/29/jvm/"/>
    <id>https://51461.github.io/blog/2019/06/29/jvm/</id>
    <published>2019-06-29T08:08:30.000Z</published>
    <updated>2019-06-29T11:02:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>JVM是Java语言可以跨平台、保持高发展的根本，没有了JVM，java语言将失去语言环境</strong></p><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="JVM虚拟机栈"><a href="#JVM虚拟机栈" class="headerlink" title="JVM虚拟机栈"></a>JVM虚拟机栈</h3><p><strong>每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</strong></p><p><strong>可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小</strong><br><strong><code>java -Xss2M HackTheJava</code></strong></p><p><strong>该区域可能抛出以下异常：</strong></p><ul><li><strong>当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；</strong></li><li><strong>栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常</strong></li></ul><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p><strong>本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。</strong></p><p><strong>本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。</strong></p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p><strong>所有对象都在这里分配内存，是垃圾收集的主要区域（”GC 堆”）。</strong></p><p><strong>现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块：</strong></p><ul><li><strong>新生代（Young Generation）</strong></li><li><strong>老年代（Old Generation）</strong></li></ul><p><strong>堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。</strong></p><p><strong>可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xms1M -Xmx2M HackTheJava</span><br></pre></td></tr></table></figure><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p><strong>用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</strong></p><p><strong>和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。</strong></p><p><strong>对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。</strong></p><p><strong>HotSpot 虚拟机把它当成<font color="orange">永久代</font>来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，<font color="orange">从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中</font>。</strong></p><p><strong>方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等放入堆中。</strong></p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p><strong>运行时常量池是方法区的一部分。</strong></p><p><strong>Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。</strong></p><p><strong>除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。</strong></p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p><strong>在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。</strong></p><h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><p><strong><font color="orange">Serial GC</font>:JDK1.3.1,串行方式回收，它是单线程的收集器，只会使用一个线程进行垃圾收集工作。它的优点是简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。它是 Client 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。</strong><br><strong><font color="ff5f0">最小化了使用内存和并行开销</font></strong></p><p><strong><font color="orange">Parallel GC</font>：其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器。JDK6之后成为默认GC，<font color="ff5f0">最大化应用程序的吞吐量</font></strong></p><p><strong><font color="orange">Concurrent Mark Sweep GC</font>：在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。<font color="ff5f0">最小化GC中断或停顿时间</font></strong></p><p><strong><font color="orange">Garbage First</font>：<font color="f05f00">G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离</font>。通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。</strong></p><h2 id="判断回收算法"><a href="#判断回收算法" class="headerlink" title="判断回收算法"></a>判断回收算法</h2><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p><strong>为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。</strong></p><p><strong>在<font color="blue">两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收</font>。正是因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。</strong></p><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p><strong>以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。</strong></p><p><strong>Java 虚拟机使用该算法来判断对象是否可被回收，GC Roots 一般包含以下内容：</strong></p><ul><li><strong>虚拟机栈中局部变量表中引用的对象</strong></li><li><strong>本地方法栈中 JNI 中引用的对象</strong></li><li><strong>方法区中类静态属性引用的对象</strong></li><li><strong>方法区中的常量引用的对象</strong></li></ul><h3 id="方法区的回收"><a href="#方法区的回收" class="headerlink" title="方法区的回收"></a>方法区的回收</h3><p><strong>因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。</strong></p><p><strong>主要是对常量池的回收和对类的卸载。</strong></p><p><strong>为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。</strong></p><p><strong>类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载：</strong></p><ul><li><strong>该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。</strong></li><li><strong>加载该类的 ClassLoader 已经被回收。</strong></li><li><strong>该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。</strong></li></ul><h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h3><p><strong>类似 C++ 的析构函数，用于关闭外部资源。但是 try-finally 等方式可以做得更好，并且该方法运行代价很高，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。</strong></p><p><strong>当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会再调用该方法。</strong></p><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p><strong>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。</strong></p><h3 id="1-强引用"><a href="#1-强引用" class="headerlink" title="1.强引用"></a>1.强引用</h3><p><strong>被强引用关联的对象不会被回收。</strong><br><strong>使用 new 一个新对象的方式来创建强引用。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><h3 id="2-软引用"><a href="#2-软引用" class="headerlink" title="2.软引用"></a>2.软引用</h3><p><strong>被软引用关联的对象只有在内存不够的情况下才会被回收。</strong><br><strong>使用 SoftReference 类来创建软引用。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> SoftReference&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>;  <span class="comment">// 使对象只被软引用关联</span></span><br></pre></td></tr></table></figure><h3 id="3-弱引用"><a href="#3-弱引用" class="headerlink" title="3.弱引用"></a>3.弱引用</h3><p><strong>被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。</strong><br><strong>使用 WeakReference 类来创建弱引用。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> WeakReference&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>; <span class="comment">//使对象只被弱引用关联</span></span><br></pre></td></tr></table></figure><h3 id="4-虚引用"><a href="#4-虚引用" class="headerlink" title="4.虚引用"></a>4.虚引用</h3><p><strong>又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。</strong><br><strong>为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。</strong><br><strong>使用 PhantomReference 来创建虚引用。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> PhantomReference&lt;Object&gt;(obj, <span class="keyword">null</span>);</span><br><span class="line">obj = <span class="keyword">null</span>; <span class="comment">//使对象被虚引用关联</span></span><br></pre></td></tr></table></figure><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记——清除"><a href="#标记——清除" class="headerlink" title="标记——清除"></a>标记——清除</h3><p><strong>在<font color="orange">标记阶段</font>，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。</strong></p><p><strong>在<font color="orange">清除阶段</font>，会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。回收对象就是把对象作为分块，连接到被称为 “空闲链表” 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。</strong></p><p><strong>在<font color="orange">分配</font>时，程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block。如果它找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 (block - size) 的两部分，返回大小为 size 的分块，并把大小为 (block - size) 的块返回给空闲链表。</strong></p><p><strong>缺点：</strong><br><strong>- 标记和清除过程效率都不高；</strong><br><strong>- 会产生大量不连续的内存碎片，导致无法给大对象分配内存。</strong></p><h3 id="标记——整理"><a href="#标记——整理" class="headerlink" title="标记——整理"></a>标记——整理</h3><p><strong>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</strong></p><p><strong>优点: 不会产生内存碎片</strong></p><p><strong>缺点: 需要移动大量对象，处理效率比较低</strong></p><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p><strong>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。</strong></p><p><strong><font color="orange">缺点是只使用了内存的一半。</font></strong></p><p><strong>现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。</strong></p><p><strong>HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。</strong></p><h3 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h3><p><strong>现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。</strong></p><p><strong>一般将堆分为新生代和老年代。</strong><br><strong>- 新生代使用：复制算法</strong><br><strong>- 老年代使用：标记 - 清除 或者 标记 - 整理 算法</strong></p><h3 id="GC回收器回收过程"><a href="#GC回收器回收过程" class="headerlink" title="GC回收器回收过程"></a>GC回收器回收过程</h3><h4 id="G1-Garbage-First"><a href="#G1-Garbage-First" class="headerlink" title="G1(Garbage First)"></a>G1(Garbage First)</h4><p><strong>1. <font color="orange">初始标记</font></strong><br><strong>2. <font color="orange">并发标记</font></strong><br><strong>3. <font color="orange">最终标记</font>：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。</strong><br><strong>4. <font color="orange">筛选回收</font>：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</strong></p><p><strong>特点：</strong><br><strong>1. <font color="orange">空间整合</font>：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</strong><br><strong>2. <font color="orange">可预测的停顿</font>：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</strong></p><h4 id="CMS-Concurrent-Mark-Sweep-GC"><a href="#CMS-Concurrent-Mark-Sweep-GC" class="headerlink" title="CMS(Concurrent Mark Sweep GC)"></a>CMS(Concurrent Mark Sweep GC)</h4><p><strong>1. <font color="orange">初始标记</font>：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。</strong><br><strong>2. <font color="orange">并发标记</font>：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。</strong><br><strong>3. <font color="orange">重新标记</font>：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</strong><br><strong>4. <font color="orange">并发清除</font>：不需要停顿</strong><br><strong>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。</strong></p><p><strong>缺点：</strong></p><p><strong>1.<font color="orange"> 吞吐量低</font>：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</strong><br><strong>2. <font color="orange">无法处理浮动垃圾</font>，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。</strong><br><strong>3. <font color="orange">标记 - 清除算法导致的空间碎片</font>，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</strong></p><h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><h3 id="Minor-GC-和-Full-GC"><a href="#Minor-GC-和-Full-GC" class="headerlink" title="Minor GC 和 Full GC"></a>Minor GC 和 Full GC</h3><p><strong>Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快</strong><br><strong>Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多</strong></p><h3 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h3><h4 id="1-对象优先在-Eden-分配"><a href="#1-对象优先在-Eden-分配" class="headerlink" title="1.对象优先在 Eden 分配"></a>1.对象优先在 Eden 分配</h4><p><strong>大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。</strong></p><h4 id="2-大对象直接进入老年代"><a href="#2-大对象直接进入老年代" class="headerlink" title="2.大对象直接进入老年代"></a>2.大对象直接进入老年代</h4><p><strong>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。</strong></p><p><strong>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。</strong></p><p><strong>-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。</strong></p><h4 id="3-长期存活的对象进入老年代"><a href="#3-长期存活的对象进入老年代" class="headerlink" title="3. 长期存活的对象进入老年代"></a>3. 长期存活的对象进入老年代</h4><p><strong>为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。</strong></p><p><strong>-XX:MaxTenuringThreshold 用来定义年龄的阈值。</strong></p><h4 id="4-动态对象年龄判定"><a href="#4-动态对象年龄判定" class="headerlink" title="4. 动态对象年龄判定"></a>4. 动态对象年龄判定</h4><p><strong>虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。</strong></p><h4 id="5-空间分配担保"><a href="#5-空间分配担保" class="headerlink" title="5. 空间分配担保"></a>5. 空间分配担保</h4><p><strong>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。</strong></p><p><strong>如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。</strong></p><h3 id="Full-GC-的触发条件"><a href="#Full-GC-的触发条件" class="headerlink" title="Full GC 的触发条件"></a>Full GC 的触发条件</h3><p><strong>对于 Minor GC，其触发条件非常简单，当Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：</strong></p><h4 id="调用-System-gc"><a href="#调用-System-gc" class="headerlink" title="调用 System.gc()"></a>调用 System.gc()</h4><p>只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p><h4 id="老年代空间不足"><a href="#老年代空间不足" class="headerlink" title="老年代空间不足"></a>老年代空间不足</h4><p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。</p><p>为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</p><h4 id="空间分配担保失败"><a href="#空间分配担保失败" class="headerlink" title="空间分配担保失败"></a>空间分配担保失败</h4><p>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。具体内容请参考上面的第 5 小节。</p><h4 id="JDK-1-7-及以前的永久代空间不足"><a href="#JDK-1-7-及以前的永久代空间不足" class="headerlink" title="JDK 1.7 及以前的永久代空间不足"></a>JDK 1.7 及以前的永久代空间不足</h4><p>在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。</p><p>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。</p><p>为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。</p><h4 id="Concurrent-Mode-Failure"><a href="#Concurrent-Mode-Failure" class="headerlink" title="Concurrent Mode Failure"></a>Concurrent Mode Failure</h4><p>执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。</p><h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><ul><li><strong>加载（Loading）</strong></li><li><strong>验证（Verification）</strong></li><li><strong>准备（Preparation）</strong></li><li><strong>解析（Resolution）</strong></li><li><strong>初始化（Initialization）</strong></li><li><strong>使用（Using）</strong></li><li><strong>卸载（Unloading）</strong><h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3></li></ul><p><strong>包含了加载、验证、准备、解析和初始化这 5 个阶段。</strong></p><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p><strong>加载是类加载的一个阶段，注意不要混淆。</strong></p><p><strong>加载过程完成以下三件事：</strong></p><ul><li><strong>通过类的完全限定名称获取定义该类的二进制字节流。</strong></li><li><strong>将该字节流表示的静态存储结构转换为方法区的运行时存储结构。</strong></li><li><strong>在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。</strong></li></ul><p><strong>其中二进制字节流可以从以下方式中获取：</strong></p><ul><li><strong>从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。</strong></li><li><strong>从网络中获取，最典型的应用是 Applet。</strong></li><li><strong>运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。</strong></li><li><strong>由其他文件生成，例如由 JSP 文件生成对应的 Class 类。</strong></li></ul><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p><strong>确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</strong></p><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p><strong>类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。</strong></p><p><strong>实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。</strong></p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p><strong>将常量池的符号引用替换为直接引用的过程。</strong></p><p><strong>其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。</strong></p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p><strong>初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行类构造器 <clinit>() 方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。</clinit></strong></p><h3 id="类初始化时机"><a href="#类初始化时机" class="headerlink" title="类初始化时机"></a>类初始化时机</h3><p><strong>主动引用时必须初始化，被动引用不会触动初始化</strong></p><h4 id="主动引用"><a href="#主动引用" class="headerlink" title="主动引用"></a>主动引用</h4><ul><li><strong>遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。</strong></li><li><strong>使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。</strong></li><li><strong>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</strong></li><li><strong>当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类；</strong></li><li><strong>当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；</strong></li></ul><h4 id="被动引用"><a href="#被动引用" class="headerlink" title="被动引用"></a>被动引用</h4><ul><li><strong>通过子类引用父类的静态字段，不会导致子类初始化。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(SubClass.value);  <span class="comment">// value 字段在 SuperClass 中定义</span></span><br></pre></td></tr></table></figure><ul><li><strong>通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SuperClass[] sca = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><ul><li><strong>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ConstClass.HELLOWORLD);</span><br></pre></td></tr></table></figure><h3 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h3><p><strong>从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器：</strong></p><ul><li><strong>启动类加载器（Bootstrap ClassLoader），使用 C++ 实现，是虚拟机自身的一部分；</strong></li><li><strong>所有其它类的加载器，使用 Java 实现，独立于虚拟机，继承自抽象类 java.lang.ClassLoader。</strong></li></ul><p><strong>从 Java 开发人员的角度看，类加载器可以划分得更细致一些：</strong></p><ul><li><strong>启动类加载器（Bootstrap ClassLoader）此类加载器负责将存放在 <jre_home>\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。</jre_home></strong></li><li><strong>扩展类加载器（Extension ClassLoader）这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 <java_home>/lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。</java_home></strong></li><li><strong>应用程序类加载器（Application ClassLoader）这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</strong>  </li></ul><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p><strong>该模型要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。这里的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）。</strong></p><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p><strong>一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。</strong></p><h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><p><strong>使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。</strong></p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass() 方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出 ClassNotFoundException，此时尝试自己去加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The parent class loader for delegation</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h4><p>以下代码中的 FileSystemClassLoader 是自定义类加载器，继承自 java.lang.ClassLoader，用于加载文件系统上的类。它首先根据类的全名在文件系统上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 defineClass() 方法来把这些字节代码转换成 java.lang.Class 类的实例。</p><p>java.lang.ClassLoader 的 loadClass() 实现了双亲委派模型的逻辑，自定义类加载器一般不去重写它，但是需要重写 findClass() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSystemClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String rootDir;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileSystemClassLoader</span><span class="params">(String rootDir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rootDir = rootDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] classData = getClassData(name);</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getClassData(String className) &#123;</span><br><span class="line">        String path = classNameToPath(className);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream ins = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> bufferSize = <span class="number">4096</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[bufferSize];</span><br><span class="line">            <span class="keyword">int</span> bytesNumRead;</span><br><span class="line">            <span class="keyword">while</span> ((bytesNumRead = ins.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, bytesNumRead);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">classNameToPath</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rootDir + File.separatorChar</span><br><span class="line">                + className.replace(<span class="string">'.'</span>, File.separatorChar) + <span class="string">".class"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>摘自</strong><a href="https://cyc2018.github.io/CS-Notes/#/notes/Java%20虚拟机" target="_blank" rel="noopener">https://cyc2018.github.io/CS-Notes/#/notes/Java%20虚拟机</a>    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;JVM是Java语言可以跨平台、保持高发展的根本，没有了JVM，java语言将失去语言环境&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;JVM&quot;&gt;&lt;a href=&quot;#JVM&quot; class=&quot;headerlink&quot; title=&quot;JVM&quot;&gt;&lt;/a&gt;JVM&lt;/h2
      
    
    </summary>
    
      <category term="JVM" scheme="https://51461.github.io/blog/categories/JVM/"/>
    
    
      <category term="java" scheme="https://51461.github.io/blog/tags/java/"/>
    
      <category term="JVM" scheme="https://51461.github.io/blog/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>注册中心——zookeeper</title>
    <link href="https://51461.github.io/blog/2019/06/26/zookeeper/"/>
    <id>https://51461.github.io/blog/2019/06/26/zookeeper/</id>
    <published>2019-06-26T12:07:46.000Z</published>
    <updated>2019-06-27T13:03:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="zookeeper的介绍"><a href="#zookeeper的介绍" class="headerlink" title="zookeeper的介绍"></a>zookeeper的介绍</h2><p>ZooKeeper是一个<a href="https://baike.baidu.com/item/分布式/19276232" target="_blank" rel="noopener">分布式</a>的，开放源码的<a href="https://baike.baidu.com/item/分布式应用程序/9854429" target="_blank" rel="noopener"><strong>分布式应用程序</strong></a><strong>协调服务</strong>，是<a href="https://baike.baidu.com/item/Google" target="_blank" rel="noopener">Google</a>的Chubby一个<a href="https://baike.baidu.com/item/开源/246339" target="_blank" rel="noopener">开源</a>的实现，是Hadoop和Hbase的重要组件。<strong>它是一个为分布式应用提供一致性服务的软件</strong>，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。</p><p>ZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。</p><p>ZooKeeper包含一个简单的原语集，  提供Java和C的接口。</p><p>ZooKeeper代码版本中，提供了分布式独享锁、选举、队列的接口，代码在zookeeper-3.4.3\src\recipes。其中分布锁和队列有<a href="https://baike.baidu.com/item/Java/85979" target="_blank" rel="noopener">Java</a>和C两个版本，选举只有Java版本。</p><p>总结:zookeeper是服务的协调调度服务器!!!</p><h2 id="zookeeper的安装使用"><a href="#zookeeper的安装使用" class="headerlink" title="zookeeper的安装使用"></a>zookeeper的安装使用</h2><h3 id="zookeeper的下载"><a href="#zookeeper的下载" class="headerlink" title="zookeeper的下载"></a>zookeeper的下载</h3><p><strong>网址: <a href="http://zookeeper.apache.org/releases.html" target="_blank" rel="noopener">http://zookeeper.apache.org/releases.html</a>.</strong><br>*<em><a href="http://mirrors.hust.edu.cn/apache/zookeeper/" target="_blank" rel="noopener">http://mirrors.hust.edu.cn/apache/zookeeper/</a> *</em></p><h3 id="zookeeper的安装"><a href="#zookeeper的安装" class="headerlink" title="zookeeper的安装"></a>zookeeper的安装</h3><h4 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h4><p><strong>将JDK1.8文件上传到Linux操作系统中/src/usr/local/java/文件下.</strong><br><img src="https://s2.ax1x.com/2019/06/26/ZmEtYD.md.png" alt></p><p><strong>1.解压文件</strong><br><strong><code>tar -xvf jdk-8u51-linux-x64.tar.gz</code></strong></p><p><strong>2.配置环境变量编辑环境变量配置文件</strong><br><strong><code>vim /etc/profile</code></strong><br><img src="https://s2.ax1x.com/2019/06/26/ZmEdld.md.png" alt></p><p><strong>使JDK生效,之后检查jdk安装是否成功</strong><br><strong><code>source /etc/profile</code></strong><br><img src="https://s2.ax1x.com/2019/06/26/ZmEgfg.md.png" alt></p><h4 id="上传安装文件"><a href="#上传安装文件" class="headerlink" title="上传安装文件"></a>上传安装文件</h4><p><strong>说明:上传zookeeper安装文件.之后解压.</strong><br><img src="https://s2.ax1x.com/2019/06/26/ZmE5mq.png" alt><br><strong>解压目录:</strong><br><strong><code>tar -xvf zookeeper-3.4.8.tar.gz</code></strong></p><p><strong>在zk根目录下创建文件夹data/log</strong><br><strong><code>mkdir data log</code></strong></p><p><strong>复制配置文件并且修改名称</strong><br><strong><code>cp zoo_sample.cfg zoo.cfg</code></strong></p><p><strong>修改配置文件dataDir，dataLogDir为新建data/log路径</strong><br><img src="https://s2.ax1x.com/2019/06/26/ZmEXc9.md.png" alt></p><h4 id="启动zookeeper"><a href="#启动zookeeper" class="headerlink" title="启动zookeeper"></a>启动zookeeper</h4><p><strong>zk启动关闭命令如下.</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sh zkServer.sh start     或者  ./zkServer.sh start</span><br><span class="line">sh zkServer.sh stop</span><br><span class="line">sh zkServer.sh status</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/06/26/ZmVaNT.md.png" alt></p><hr><h2 id="zookeeper集群"><a href="#zookeeper集群" class="headerlink" title="zookeeper集群"></a>zookeeper集群</h2><h3 id="准备文件夹"><a href="#准备文件夹" class="headerlink" title="准备文件夹"></a>准备文件夹</h3><p><strong>在zookeeper根目录中创建新的文件夹zkCluster.</strong><br><img src="https://s2.ax1x.com/2019/06/27/ZuaIfO.md.png" alt></p><p><strong>在zkCluster下创建zk1/zk2/zk3文件夹.</strong><br><img src="https://s2.ax1x.com/2019/06/27/ZuaO0I.png" alt><br><strong>在每个文件夹里创建data/log文件夹.</strong><br><strong><code>mkdir {zk1,zk2,zk3}/{data,log}</code></strong><br><img src="https://s2.ax1x.com/2019/06/27/Zuaxtf.md.png" alt></p><h3 id="添加myid文件"><a href="#添加myid文件" class="headerlink" title="添加myid文件"></a>添加myid文件</h3><p><strong>分别在zk1/zk2/zk3中的data文件夹中创建新的文件myid.其中的内容依次为1/2/3,与zk节点号对应.</strong><br><img src="https://s2.ax1x.com/2019/06/27/Zudn9U.md.png" alt><br><strong>编辑myid文件,定义编号.</strong><br><img src="https://s2.ax1x.com/2019/06/27/ZudyUP.md.png" alt></p><h3 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h3><p><strong>将zoo_sample.cfg 复制为zoo1.cfg之后修改配置文件.</strong><br><img src="https://s2.ax1x.com/2019/06/27/ZudOv4.md.png" alt></p><p><strong>修改zoo1.cfg</strong><br><img src="https://s2.ax1x.com/2019/06/27/ZuwSV1.md.png" alt></p><p><strong>配置完成后将zoo1.cfg复制2份.之后需要修改对应的文件夹目录.和不同的端口即可.</strong></p><h3 id="zookeeper集群测试"><a href="#zookeeper集群测试" class="headerlink" title="zookeeper集群测试"></a>zookeeper集群测试</h3><p><strong>通过下面的命令启动zk集群.</strong><br><strong><code>sh zkServer.sh start   zoo1.cfg</code> 启动</strong><br><strong><code>sh zkServer.sh stop    zoo1.cfg</code> 停止</strong><br><strong><code>sh zkServer.sh status  zoo1.cfg</code> 查看状态</strong></p><p><strong>检查主从关系,从机情况说明.</strong><br><img src="https://s2.ax1x.com/2019/06/27/ZuwssJ.png" alt><br><img src="https://s2.ax1x.com/2019/06/27/ZuwrM4.png" alt></p><p><strong>Zookeeper集群中leader负责监控集群状态,follower主要负责客户端链接获取服务列表信息.同时参与投票.</strong></p><h3 id="dubbo控制台"><a href="#dubbo控制台" class="headerlink" title="dubbo控制台"></a>dubbo控制台</h3><p><strong>dubbo控制台是监控服务的.修改dubbo的配置文件信息.改为zkIP地址和端口</strong></p><p><strong>修改配置文件信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dubbo.registry.address=zookeeper://192.168.175.126:2181(ip:端口)?backup=192.168.175.126:2182,192.168.175.126:2183</span><br><span class="line">dubbo.admin.root.password=root</span><br><span class="line">dubbo.admin.guest.password=guest</span><br></pre></td></tr></table></figure><p><strong>控制台展现</strong><br><strong>用户名和密码都是root 登录之后进入控制台.</strong></p><h4 id="dubbo提供者配置文件"><a href="#dubbo提供者配置文件" class="headerlink" title="dubbo提供者配置文件"></a>dubbo提供者配置文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 9000</span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    #引入druid数据源</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://127.0.0.1:3306/jtdb?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;allowMultiQueries=true</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">#Springboot整合dubbo  </span><br><span class="line">dubbo:</span><br><span class="line">  scan:</span><br><span class="line">    basePackages: com.compent #包扫描dubbo的service注解</span><br><span class="line">  application:</span><br><span class="line">    name: provider-user  #提供者服务名称</span><br><span class="line">  registry:              #链接zookeeper</span><br><span class="line">    address: zookeeper://192.168.175.126:2181?backup=192.168.175.126:2182,192.168.175.126:2183</span><br><span class="line">  protocol:</span><br><span class="line">    name: dubbo </span><br><span class="line">    port: 20880   #服务通信端口 消费者链接提供者端口</span><br><span class="line">mybatis-plus:</span><br><span class="line">  type-aliases-package: com.jt.dubbo.pojo       #配置别名包路径</span><br><span class="line">  mapper-locations: classpath:/mybatis/mappers/*.xml  #添加mapper映射文件</span><br><span class="line">  configuration:</span><br><span class="line">    map-underscore-to-camel-case: true                #开启驼峰映射规则</span><br></pre></td></tr></table></figure><h4 id="dubbo消费者配置文件"><a href="#dubbo消费者配置文件" class="headerlink" title="dubbo消费者配置文件"></a>dubbo消费者配置文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 9001</span><br><span class="line">dubbo:</span><br><span class="line">  scan:</span><br><span class="line">    basePackages: com.compent</span><br><span class="line">  application:</span><br><span class="line">    name: consumer-user  #服务名称&quot;唯一&quot;</span><br><span class="line">  registry:</span><br><span class="line">    address: zookeeper://192.168.175.126:2181?backup=192.168.175.126:2182,192.168.175.126:2183</span><br></pre></td></tr></table></figure><p><strong>dubbo小demo（<a href="https://github.com/51461/dubbo-demo/" target="_blank" rel="noopener">https://github.com/51461/dubbo-demo/</a> ）</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;zookeeper的介绍&quot;&gt;&lt;a href=&quot;#zookeeper的介绍&quot; class=&quot;headerlink&quot; title=&quot;zookeeper的介绍&quot;&gt;&lt;/a&gt;zookeeper的介绍&lt;/h2&gt;&lt;p&gt;ZooKeeper是一个&lt;a href=&quot;https://b
      
    
    </summary>
    
      <category term="微服务" scheme="https://51461.github.io/blog/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="java" scheme="https://51461.github.io/blog/tags/java/"/>
    
      <category term="分布式" scheme="https://51461.github.io/blog/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>redis常用命令</title>
    <link href="https://51461.github.io/blog/2019/06/24/redis02/"/>
    <id>https://51461.github.io/blog/2019/06/24/redis02/</id>
    <published>2019-06-24T10:40:55.000Z</published>
    <updated>2019-06-24T10:47:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><table><thead><tr><th>命令</th><th>说明</th><th><strong>案例</strong></th></tr></thead><tbody><tr><td>set</td><td>添加key-value</td><td>set username admin</td></tr><tr><td>get</td><td>根据key获取数据</td><td>get username</td></tr><tr><td>strlen</td><td>获取key的长度</td><td>strlen key</td></tr><tr><td>exists</td><td>判断key是否存在</td><td>exists name 返回1存在  0不存在</td></tr><tr><td>del</td><td>删除redis中的key</td><td>del key</td></tr><tr><td>Keys</td><td>用于查询符合条件的key</td><td>keys * 查询redis中全部的keykeys n?me 使用占位符获取数据keys nam* 获取nam开头的数据</td></tr><tr><td>mset</td><td>赋值多个key-value</td><td>mset key1 value1 key2 value2 key3 value3</td></tr><tr><td>mget</td><td>获取多个key的值</td><td>mget key1 key2</td></tr><tr><td>append</td><td>对某个key的值进行追加</td><td>append key value</td></tr><tr><td>type</td><td>检查某个key的类型</td><td>type key</td></tr><tr><td>select</td><td>切换redis数据库</td><td>select 0-15 redis中共有16个数据库</td></tr><tr><td>flushdb</td><td>清空单个数据库</td><td>flushdb</td></tr><tr><td>flushall</td><td>清空全部数据库</td><td>flushall</td></tr><tr><td>incr</td><td>自动加1</td><td>incr key</td></tr><tr><td>decr</td><td>自动减1</td><td>decr key</td></tr><tr><td>incrby</td><td>指定数值添加</td><td>incrby 10</td></tr><tr><td>decrby</td><td>指定数值减</td><td>decrby 10</td></tr><tr><td>expire</td><td>指定key的生效时间 单位秒</td><td>expire key 20 key20秒后失效</td></tr><tr><td>pexpire</td><td>指定key的失效时间 单位毫秒</td><td>pexpire key 2000key 2000毫秒后失效</td></tr><tr><td>ttl</td><td>检查key的剩余存活时间</td><td>ttl key</td></tr><tr><td>persist</td><td>撤销key的失效时间</td><td>persist key</td></tr></tbody></table><h2 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a>Hash类型</h2><p><strong>说明:可以用散列类型保存对象和属性值</strong><br><strong>例子:User对象{id:2,name:小明,age:19}</strong></p><table><thead><tr><th>命令</th><th>说明</th><th><strong>案例</strong></th></tr></thead><tbody><tr><td>hset</td><td>为对象添加数据</td><td>hset key field value</td></tr><tr><td>hget</td><td>获取对象的属性值</td><td>hget key field</td></tr><tr><td>hexists</td><td>判断对象的属性是否存在</td><td>HEXISTS key field1表示存在  0表示不存在</td></tr><tr><td>hdel</td><td>删除hash中的属性</td><td>hdel user field [field …]</td></tr><tr><td>hgetall</td><td>获取hash全部元素和值</td><td>HGETALL key</td></tr><tr><td>hkyes</td><td>获取hash中的所有字段</td><td>HKEYS key</td></tr><tr><td>hlen</td><td>获取hash中所有属性的数量</td><td>hlen key</td></tr><tr><td>hmget</td><td>获取hash里面指定字段的值</td><td>hmget key field [field …]</td></tr><tr><td>hmset</td><td>为hash的多个字段设定值</td><td>hmset key field value [field value …]</td></tr><tr><td>hsetnx</td><td>设置hash的一个字段,只有当这个字段不存在时有效</td><td>HSETNX key field value</td></tr><tr><td>hstrlen</td><td>获取hash中指定key的长度</td><td>HSTRLEN key field</td></tr><tr><td>hvals</td><td>获取hash的所有值</td><td>HVALS user</td></tr></tbody></table><h2 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h2><p><strong>说明:Redis中的List集合是双端循环列表,分别可以从左右两个方向插入数据.</strong><br><strong>List集合可以当做队列使用,也可以当做栈使用</strong><br><strong>存入数据的方向和获取数据的方向相反</strong><br><strong>存入数据的方向和获取数据的方向相同</strong></p><table><thead><tr><th>命令</th><th>说明</th><th><strong>案例</strong></th></tr></thead><tbody><tr><td>lpush</td><td>从队列的左边入队一个或多个元素</td><td>LPUSH key value [value …]</td></tr><tr><td>rpush</td><td>从队列的右边入队一个或多个元素</td><td>RPUSH key value [value …]</td></tr><tr><td>lpop</td><td>从队列的左端出队一个元素</td><td>LPOP key</td></tr><tr><td>rpop</td><td>从队列的右端出队一个元素</td><td>RPOP key</td></tr><tr><td>lpushx</td><td>当队列存在时从队列的左侧入队一个元素</td><td>LPUSHX key value</td></tr><tr><td>rpushx</td><td>当队列存在时从队列的右侧入队一个元素</td><td>RPUSHx key value</td></tr><tr><td>lrange</td><td>从列表中获取指定返回的元素</td><td>LRANGE key start stop  Lrange key 0 -1 获取全部队列的数据</td></tr><tr><td>lrem</td><td>从存于 key 的列表里移除前 count 次出现的值为 value 的元素。 这个 count 参数通过下面几种方式影响这个操作：· count &gt; 0: 从头往尾移除值为 value 的元素。· count &lt; 0: 从尾往头移除值为 value 的元素。· count = 0: 移除所有值为 value 的元素。</td><td>LREM list -2 “hello” 会从存于 list 的列表里移除最后两个出现的 “hello”。需要注意的是，如果list里没有存在key就会被当作空list处理，所以当 key 不存在的时候，这个命令会返回 0。</td></tr><tr><td>Lset</td><td>设置 index 位置的list元素的值为 value</td><td>LSET key index value</td></tr></tbody></table><h2 id="事务命令"><a href="#事务命令" class="headerlink" title="事务命令"></a>事务命令</h2><p><strong>说明:redis中操作可以添加事务的支持.一项任务可以由多个redis命令完成,如果有一个命令失败导致入库失败时.需要实现事务回滚.</strong></p><table><thead><tr><th>命令</th><th>说明</th><th><strong>案例</strong></th></tr></thead><tbody><tr><td>multi</td><td>标记一个事务开始</td><td>127.0.0.1:6379&gt; MULTIOK</td></tr><tr><td>exec</td><td>执行所有multi之后发的命令</td><td>127.0.0.1:6379&gt; EXEC OK</td></tr><tr><td>discard</td><td>丢弃所有multi之后发的命令</td><td></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;String类型&quot;&gt;&lt;a href=&quot;#String类型&quot; class=&quot;headerlink&quot; title=&quot;String类型&quot;&gt;&lt;/a&gt;String类型&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;
      
    
    </summary>
    
      <category term="redis" scheme="https://51461.github.io/blog/categories/redis/"/>
    
    
      <category term="java" scheme="https://51461.github.io/blog/tags/java/"/>
    
      <category term="redis" scheme="https://51461.github.io/blog/tags/redis/"/>
    
      <category term="指令" scheme="https://51461.github.io/blog/tags/%E6%8C%87%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="https://51461.github.io/blog/2019/06/24/redis/"/>
    <id>https://51461.github.io/blog/2019/06/24/redis/</id>
    <published>2019-06-24T10:39:31.000Z</published>
    <updated>2019-06-25T00:32:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis介绍"><a href="#Redis介绍" class="headerlink" title="Redis介绍"></a>Redis介绍</h2><p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 <a href="#strings"><strong>字符串（strings）</strong></a>， <a href="#hashes"><strong>散列（hashes）</strong></a>， <a href="#lists"><strong>列表（lists）</strong></a>， <a href="#sets"><strong>集合（sets）</strong></a>， <a href="#sorted-sets"><strong>有序集合（sorted sets</strong>）</a> 与范围查询， <a href="#bitmaps">bitmaps</a>， <a href="#hyperloglogs">hyperloglogs</a> 和 <a href="http://www.redis.cn/commands/geoadd.html" target="_blank" rel="noopener">地理空间（geospatial）</a> 索引半径查询。 Redis 内置了 <a href="http://www.redis.cn/topics/replication.html" target="_blank" rel="noopener">复制（replication）</a>，<a href="http://www.redis.cn/commands/eval.html" target="_blank" rel="noopener">LUA脚本（Lua scripting）</a>， <a href="http://www.redis.cn/topics/lru-cache.html" target="_blank" rel="noopener">LRU驱动事件（LRU eviction）</a>，<a href="http://www.redis.cn/topics/transactions.html" target="_blank" rel="noopener">事务（transactions）</a> 和不同级别的 <a href="http://www.redis.cn/topics/persistence.html" target="_blank" rel="noopener">磁盘持久化（persistence）</a>， 并通过 <a href="http://www.redis.cn/topics/sentinel.html" target="_blank" rel="noopener">Redis哨兵（Sentinel）</a>和自动 <a href="http://www.redis.cn/topics/cluster-tutorial.html" target="_blank" rel="noopener">分区（Cluster）</a>提供高可用性（high availability）。</p><h2 id="Redis性能"><a href="#Redis性能" class="headerlink" title="Redis性能"></a>Redis性能</h2><p><strong>读:11.2万/秒</strong><br><strong>写:8.6万/秒</strong><br><strong>平均: 10万/秒 吞吐量</strong></p><h2 id="Redis安装和使用"><a href="#Redis安装和使用" class="headerlink" title="Redis安装和使用"></a>Redis安装和使用</h2><h3 id="安装redis"><a href="#安装redis" class="headerlink" title="安装redis"></a>安装redis</h3><p><strong>要求:命令的执行值redis的根目录中运行.</strong></p><p><strong>命令:</strong><br>​    <strong>1.make    表示编译文件</strong><br>​    <strong>2.make install  表示安装redis服务.</strong></p><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p><strong>vim redis.conf</strong></p><h4 id="去除IP绑定"><a href="#去除IP绑定" class="headerlink" title="去除IP绑定"></a>去除IP绑定</h4><p><strong>#bind 127.0.0.1（69行左右）</strong><br><img src="https://s2.ax1x.com/2019/06/24/ZAtNhq.png" alt></p><h4 id="关闭保护模式"><a href="#关闭保护模式" class="headerlink" title="关闭保护模式"></a>关闭保护模式</h4><p><strong>protected-mode no(88行左右)</strong><br><img src="https://s2.ax1x.com/2019/06/24/ZAtd3V.png" alt></p><h4 id="开启后台启动"><a href="#开启后台启动" class="headerlink" title="开启后台启动"></a>开启后台启动</h4><p><strong>daemonize yes(136行左右)</strong><br><img src="https://s2.ax1x.com/2019/06/24/ZAt7Ed.png" alt></p><h3 id="VIM常见报错"><a href="#VIM常见报错" class="headerlink" title="VIM常见报错"></a>VIM常见报错</h3><p><strong>报错演示：</strong><br><img src="https://s2.ax1x.com/2019/06/24/ZAUZWt.png" alt></p><p><strong>报错原因:在vim编辑状态下.程序异常外退出导致Linux程序启动保护模式.导致异常.</strong></p><p><strong>解决方案:</strong><br><strong>1. 根据选项  点击 D</strong><br><strong>2. 利用删除指令 直接删除临时文件 <code>rm –rf .xxxxxx.swap</code></strong></p><h3 id="Redis运行命令"><a href="#Redis运行命令" class="headerlink" title="Redis运行命令"></a>Redis运行命令</h3><h4 id="启动命令"><a href="#启动命令" class="headerlink" title="启动命令"></a>启动命令</h4><p><strong>Redis-server 忽略         一切加载都是默认项</strong><br><strong>Redis-server redis.conf  目的读取配置文件</strong></p><h4 id="进入客户端"><a href="#进入客户端" class="headerlink" title="进入客户端"></a>进入客户端</h4><p><strong>redis-cli –p  6379(端口号)</strong><br><strong>exit     退出客户端</strong><br><strong>ctrl + c 退出</strong><br><strong>简化:如果Redis默认的端口号为6379则命令可以简化</strong><br><strong>redis-cli</strong></p><h4 id="Redis关闭"><a href="#Redis关闭" class="headerlink" title="Redis关闭"></a>Redis关闭</h4><p><strong>redis-cli –p 6379（端口号） shutdown</strong><br><strong>kill -9 PID PID2</strong><br><strong>redis-cli shutdown  简化命令</strong></p><h2 id="Redis入门案例"><a href="#Redis入门案例" class="headerlink" title="Redis入门案例"></a>Redis入门案例</h2><h3 id="linux防火墙操作密令"><a href="#linux防火墙操作密令" class="headerlink" title="linux防火墙操作密令"></a>linux防火墙操作密令</h3><p><strong>连接虚拟机Redis要确保虚拟机防火墙关闭</strong><br><strong>1 关闭防火墙—–service iptables stop<br>2 启动防火墙—–service iptables start<br>3 重启防火墙—–service iptables restart<br>4 查看防火墙状态——service iptables status<br>5 永久关闭防火墙——chkconfig iptables off<br>6 永久关闭后启用——chkconfig iptables on</strong></p><h3 id="添加jar包文件"><a href="#添加jar包文件" class="headerlink" title="添加jar包文件"></a>添加jar包文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- jedis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jedis.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--添加spring-datajar包  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="入门案例——String"><a href="#入门案例——String" class="headerlink" title="入门案例——String"></a>入门案例——String</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 连接单台redis  </span></span><br><span class="line"><span class="comment"> * 参数介绍:</span></span><br><span class="line"><span class="comment"> * redisIP地址.</span></span><br><span class="line"><span class="comment"> *  redis:6379</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"192.168.126.166"</span>,<span class="number">6379</span>);</span><br><span class="line">jedis.set(<span class="string">"redis"</span>, <span class="string">"redis入门案例"</span>);</span><br><span class="line">System.out.println(<span class="string">"获取redis中的数据:"</span>+jedis.get(<span class="string">"redis"</span>));</span><br><span class="line"><span class="comment">//为数据设定超时时间  单位秒</span></span><br><span class="line">jedis.setex(<span class="string">"1804"</span>, <span class="number">100</span>, <span class="string">"1804班"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="入门案例——hash"><a href="#入门案例——hash" class="headerlink" title="入门案例——hash"></a>入门案例——hash</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"192.168.126.148"</span>, <span class="number">6379</span>);</span><br><span class="line">jedis.hset(<span class="string">"user"</span>, <span class="string">"id"</span>, <span class="string">"1"</span>);</span><br><span class="line">jedis.hset(<span class="string">"user"</span>, <span class="string">"name"</span>, <span class="string">"tomcat"</span>);</span><br><span class="line">jedis.hset(<span class="string">"user"</span>, <span class="string">"age"</span>, <span class="string">"18"</span>);</span><br><span class="line">System.out.println(<span class="string">"操作完成!!!"</span>+jedis.hget(<span class="string">"user"</span>, <span class="string">"id"</span>));</span><br><span class="line">Map&lt;String,String&gt; map = jedis.hgetAll(<span class="string">"user"</span>);</span><br><span class="line">System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="入门案例——List"><a href="#入门案例——List" class="headerlink" title="入门案例——List"></a>入门案例——List</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"192.168.126.148"</span>, <span class="number">6379</span>);</span><br><span class="line">Long number = jedis.lpush(<span class="string">"list"</span>, <span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>,<span class="string">"e"</span>);</span><br><span class="line">System.out.println(<span class="string">"获取数据"</span>+number);</span><br><span class="line">List&lt;String&gt; list= jedis.lrange(<span class="string">"list"</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">"获取参数:"</span>+list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SpringBoot整合Redis"><a href="#SpringBoot整合Redis" class="headerlink" title="SpringBoot整合Redis"></a>SpringBoot整合Redis</h3><h4 id="导入jar包"><a href="#导入jar包" class="headerlink" title="导入jar包"></a>导入jar包</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--spring整合redis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String类型操作方式   配置文件3处  防火墙</span></span><br><span class="line"><span class="comment">//IP:端口号</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"192.168.175.129"</span>,<span class="number">6379</span>);</span><br><span class="line">jedis.set(<span class="string">"1902"</span>,<span class="string">"1902班"</span>);</span><br><span class="line">jedis.expire(<span class="string">"1902"</span>, <span class="number">10</span>);</span><br><span class="line">System.out.println(jedis.get(<span class="string">"1902"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="超时时间定时"><a href="#超时时间定时" class="headerlink" title="超时时间定时"></a>超时时间定时</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设定数据的超时方法</span></span><br><span class="line"><span class="comment">//分布式锁!!!!!</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTimeOut</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"192.168.175.129"</span>,<span class="number">6379</span>);</span><br><span class="line">jedis.setex(<span class="string">"aa"</span>, <span class="number">2</span>, <span class="string">"aa"</span>);</span><br><span class="line">System.out.println(jedis.get(<span class="string">"aa"</span>));</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line"><span class="comment">//当key不存在时操作正常.当key存在时,则操作失败</span></span><br><span class="line">Long result = jedis.setnx(<span class="string">"aa"</span>,<span class="string">"bb"</span>);</span><br><span class="line">System.out.println(<span class="string">"获取输出数据:"</span>+result+<span class="string">":"</span>+jedis.get(<span class="string">"aa"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对象转化JSON"><a href="#对象转化JSON" class="headerlink" title="对象转化JSON"></a>对象转化JSON</h4><h5 id="转化说明"><a href="#转化说明" class="headerlink" title="转化说明"></a>转化说明</h5><p><strong>利用ObjectMapper实现对象的转化.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"><span class="comment">//对象转化为JSON</span></span><br><span class="line">String json串 = mapper.writeValueAsString(对象);</span><br><span class="line"><span class="comment">//JSON转化为对象</span></span><br><span class="line">对象  T =  mapper.readValue(json, 对象.class);</span><br></pre></td></tr></table></figure><h5 id="对象与JSON互转"><a href="#对象与JSON互转" class="headerlink" title="对象与JSON互转"></a>对象与JSON互转</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 3.利用Redis保存业务数据  数据库</span></span><br><span class="line"><span class="comment"> *  数据库数据:  对象 Object</span></span><br><span class="line"><span class="comment"> *  String类型要求只能存储字符串类型</span></span><br><span class="line"><span class="comment"> *  item ~~~  JSON  ~~~ 字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">objectToJSON</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">ItemDesc itemDesc = <span class="keyword">new</span> ItemDesc();</span><br><span class="line">itemDesc.setItemId(<span class="number">1000L</span>)</span><br><span class="line">.setItemDesc(<span class="string">"测试方法"</span>)</span><br><span class="line">.setCreated(<span class="keyword">new</span> Date())</span><br><span class="line">.setUpdated(<span class="keyword">new</span> Date());</span><br><span class="line">ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"><span class="comment">//转化JSON时必须 get/set方法</span></span><br><span class="line">String json =mapper.writeValueAsString(itemDesc);</span><br><span class="line">System.out.println(json);</span><br><span class="line"><span class="comment">//将json串转化为对象</span></span><br><span class="line">ItemDesc desc2 = mapper.readValue(json, ItemDesc.class);</span><br><span class="line">System.out.println(<span class="string">"测试对象:"</span>+desc2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="List与JSON互转"><a href="#List与JSON互转" class="headerlink" title="List与JSON互转"></a>List与JSON互转</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现List集合与JSON转化</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listTOJSON</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">ItemDesc itemDesc1 = <span class="keyword">new</span> ItemDesc();</span><br><span class="line">itemDesc1.setItemId(<span class="number">1000L</span>).setItemDesc(<span class="string">"测试方法"</span>);</span><br><span class="line">ItemDesc itemDesc2 = <span class="keyword">new</span> ItemDesc();</span><br><span class="line">itemDesc2.setItemId(<span class="number">1000L</span>).setItemDesc(<span class="string">"测试方法"</span>);</span><br><span class="line">List&lt;ItemDesc&gt; list = <span class="keyword">new</span> ArrayList&lt;ItemDesc&gt;();</span><br><span class="line">list.add(itemDesc1);</span><br><span class="line">list.add(itemDesc2);</span><br><span class="line">ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">String json = mapper.writeValueAsString(list);</span><br><span class="line">System.out.println(<span class="string">"集合转化为JSON"</span>+json);</span><br><span class="line"><span class="comment">//将数据保存到redis中</span></span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"192.168.175.129"</span>,<span class="number">6379</span>);</span><br><span class="line">jedis.set(<span class="string">"itemDescList"</span>, json);</span><br><span class="line"><span class="comment">//从redis中获取数据</span></span><br><span class="line">String result = jedis.get(<span class="string">"itemDescList"</span>);</span><br><span class="line">List&lt;ItemDesc&gt; descList = mapper.readValue(result,list.getClass());</span><br><span class="line">System.out.println(descList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编辑pro文件"><a href="#编辑pro文件" class="headerlink" title="编辑pro文件"></a>编辑pro文件</h4><p><strong>jedis.host=192.168.175.129</strong><br><strong>jedis.port=6379</strong></p><h4 id="编辑配置类"><a href="#编辑配置类" class="headerlink" title="编辑配置类"></a>编辑配置类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示redis配置类</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:/properties/redis.properties"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;jedis.host&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String  host;</span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;jedis.port&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> Integer port;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Jedis <span class="title">jedis</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Jedis(host, port);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设定虚拟机静态IP"><a href="#设定虚拟机静态IP" class="headerlink" title="设定虚拟机静态IP"></a>设定虚拟机静态IP</h2><p><strong>检查当前IP</strong></p><p><strong>检查网关地址</strong><br><img src="https://s2.ax1x.com/2019/06/24/ZAdHL8.png" alt></p><p><strong>配置静态IP</strong><br><img src="https://s2.ax1x.com/2019/06/24/ZAdvJs.png" alt></p><h2 id="Redis分片机制"><a href="#Redis分片机制" class="headerlink" title="Redis分片机制"></a>Redis分片机制</h2><h3 id="Redis单台问题"><a href="#Redis单台问题" class="headerlink" title="Redis单台问题"></a>Redis单台问题</h3><p><strong>1. 使用redis单台时内存会明显不足.如果一味的扩容内存,则运行的效率低.</strong><br><strong>2. 如果redis单台服务器宕机.</strong></p><h3 id="Redis分片（分区）介绍"><a href="#Redis分片（分区）介绍" class="headerlink" title="Redis分片（分区）介绍"></a>Redis分片（分区）介绍</h3><p><strong>核心特点:实现了redis内存的扩容.</strong><br><strong>说明:使用多个redis节点,共同为用户提供服务.内存空间翻倍.</strong><br>​      <strong>用户使用时当做一个整体.并且内存保存的数据不一.</strong></p><h3 id="分片搭建"><a href="#分片搭建" class="headerlink" title="分片搭建"></a>分片搭建</h3><h4 id="创建新文件"><a href="#创建新文件" class="headerlink" title="创建新文件"></a>创建新文件</h4><p><strong>在Redis根目录下创建一个新的文件夹</strong><br><img src="https://s2.ax1x.com/2019/06/24/ZA0RCd.png" alt></p><h4 id="复制配置文件"><a href="#复制配置文件" class="headerlink" title="复制配置文件"></a>复制配置文件</h4><p><strong>复制配置文件到新建的文件夹里</strong><br><strong>[root@localhost redis-5.0.4]# cp redis.conf shards/redis-6379.conf</strong><br><strong>[root@localhost redis-5.0.4]# cp redis.conf shards/redis-6380.conf</strong><br><strong>[root@localhost redis-5.0.4]# cp redis.conf shards/redis-6381.conf</strong><br><img src="https://s2.ax1x.com/2019/06/24/ZA0jvq.png" alt></p><h4 id="修改端口号"><a href="#修改端口号" class="headerlink" title="修改端口号"></a>修改端口号</h4><p><strong>可以使用:/port快速定位数据</strong><br><img src="https://s2.ax1x.com/2019/06/24/ZABKaD.png" alt><br><strong>将6380.conf中端口号改为6380.</strong><br><img src="https://s2.ax1x.com/2019/06/24/ZAB3RA.png" alt><br><strong>同理 修改其他配置文件</strong></p><h4 id="启动多台Redis"><a href="#启动多台Redis" class="headerlink" title="启动多台Redis"></a>启动多台Redis</h4><h5 id="启动Redis"><a href="#启动Redis" class="headerlink" title="启动Redis"></a>启动Redis</h5><p><strong>redis-server redis-6379.conf</strong><br><strong>redis-server redis-6380.conf</strong><br><strong>redis-server redis-6381.conf</strong></p><h5 id="检查redis服务"><a href="#检查redis服务" class="headerlink" title="检查redis服务"></a>检查redis服务</h5><p><strong>ps -ef | grep redis</strong><br><img src="https://s2.ax1x.com/2019/06/24/ZAB6s0.png" alt></p><h3 id="Redis分片测试"><a href="#Redis分片测试" class="headerlink" title="Redis分片测试"></a>Redis分片测试</h3><h4 id="入门案例-1"><a href="#入门案例-1" class="headerlink" title="入门案例"></a>入门案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 操作时需要将多台redis当做1台使用.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testShards</span><span class="params">()</span> </span>&#123;</span><br><span class="line">List&lt;JedisShardInfo&gt; shards = <span class="keyword">new</span> ArrayList&lt;JedisShardInfo&gt;();</span><br><span class="line">JedisShardInfo info1 = <span class="keyword">new</span> JedisShardInfo(<span class="string">"192.168.175.129"</span>,<span class="number">6379</span>);</span><br><span class="line">JedisShardInfo info2 = <span class="keyword">new</span> JedisShardInfo(<span class="string">"192.168.175.129"</span>,<span class="number">6380</span>);</span><br><span class="line">JedisShardInfo info3 = <span class="keyword">new</span> JedisShardInfo(<span class="string">"192.168.175.129"</span>,<span class="number">6381</span>);</span><br><span class="line">shards.add(info1);</span><br><span class="line">shards.add(info2);</span><br><span class="line">shards.add(info3);</span><br><span class="line"><span class="comment">//操作分片 redis对象工具类</span></span><br><span class="line">ShardedJedis shardedJedis = <span class="keyword">new</span> ShardedJedis(shards);</span><br><span class="line">shardedJedis.set(<span class="string">"1902"</span>,<span class="string">"1902班"</span>);</span><br><span class="line">System.out.println(shardedJedis.get(<span class="string">"1902"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hash一致性算法"><a href="#Hash一致性算法" class="headerlink" title="Hash一致性算法"></a>Hash一致性算法</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><strong>概念:同一个字符串hash值是一致的.</strong></p><h4 id="Hash一致性说明"><a href="#Hash一致性说明" class="headerlink" title="Hash一致性说明"></a>Hash一致性说明</h4><p><img src="https://s2.ax1x.com/2019/06/24/ZADg1A.png" alt></p><h4 id="Hash一致性——特性"><a href="#Hash一致性——特性" class="headerlink" title="Hash一致性——特性"></a>Hash一致性——特性</h4><h5 id="问题说明"><a href="#问题说明" class="headerlink" title="问题说明"></a>问题说明</h5><p><strong>因为所有节点都是通过ip地址加算法计算获取的,则可能会出现节点分配不均的问题.导致数据丢失.</strong></p><h5 id="均衡性"><a href="#均衡性" class="headerlink" title="均衡性"></a>均衡性</h5><p><strong>说明:均衡性要求节点中的数据尽可能的平均.</strong><br><strong>措施:引入虚拟节点概念</strong><br><img src="https://s2.ax1x.com/2019/06/24/ZArn4e.png" alt></p><h5 id="单调性"><a href="#单调性" class="headerlink" title="单调性"></a>单调性</h5><p><strong>说明:当节点新增时,能够实现数据的自动的迁移.</strong><br><strong>补充说明:如果节点一旦丢失,则导致内存丢失则整个分片无法使用.</strong><br><img src="https://s2.ax1x.com/2019/06/24/ZArDuq.png" alt></p><h5 id="分散性"><a href="#分散性" class="headerlink" title="分散性"></a>分散性</h5><p><strong>概念:由于分布式原因,导致系统不能获取全部的内存空间.导致一个key有多个位置.</strong></p><h5 id="负载"><a href="#负载" class="headerlink" title="负载"></a>负载</h5><p><strong>概念:由于分布式原因,系统不能获取全部的内存地址.导致同一个位置保存多个数据</strong></p><h3 id="Spring整合Redis分片"><a href="#Spring整合Redis分片" class="headerlink" title="Spring整合Redis分片"></a>Spring整合Redis分片</h3><h4 id="编辑properties文件"><a href="#编辑properties文件" class="headerlink" title="编辑properties文件"></a>编辑properties文件</h4><p><strong>redis.nodes=ip:端口，ip:端口，……</strong><br><strong>redis.nodes=192.168.175.129:6379,192.168.175.129:6380,192.168.175.129:6381</strong></p><h4 id="编辑配置类-1"><a href="#编辑配置类-1" class="headerlink" title="编辑配置类"></a>编辑配置类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示redis配置类</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:/properties/redis.properties"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;redis.nodes&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String redisNodes; <span class="comment">//node1,node2,node3</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ShardedJedis <span class="title">shardedJedis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">List&lt;JedisShardInfo&gt; shards = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//ip:端口,ip:端口</span></span><br><span class="line">String[] nodes = redisNodes.split(<span class="string">","</span>);</span><br><span class="line"><span class="keyword">for</span> (String node : nodes) &#123;</span><br><span class="line">String host = node.split(<span class="string">":"</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> port = Integer.parseInt(node.split(<span class="string">":"</span>)[<span class="number">1</span>]);</span><br><span class="line">JedisShardInfo info = <span class="keyword">new</span> JedisShardInfo(host, port);</span><br><span class="line">shards.add(info);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ShardedJedis(shards);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Redis持久化策略"><a href="#Redis持久化策略" class="headerlink" title="Redis持久化策略"></a>Redis持久化策略</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p><strong>Redis中的数据都在内存中,如果断电宕机则内存数据丢失.其中数据应该持久化保存.不允许丢失.</strong><br><strong>持久化策略:</strong><br><strong>1. RDB模式</strong><br><strong>2. AOF模式</strong></p><h3 id="Redis持久化工作原理"><a href="#Redis持久化工作原理" class="headerlink" title="Redis持久化工作原理"></a>Redis持久化工作原理</h3><p><strong>说明:按照配置的时间,定期将内存数据保存到redis中的持久化文件中.</strong><br><strong>当redis服务器宕机之后重启时,首先读取指定的持久化文件,恢复内存数据,方便用户使用.</strong></p><h3 id="RDB模式"><a href="#RDB模式" class="headerlink" title="RDB模式"></a>RDB模式</h3><p><strong>概念:</strong><br><strong>​    RDB模式是Redis中默认的持久化策略.保存的是redis的内存快照。占用的资源少.持久化效率最高的.</strong><br><strong>RDB特点:</strong><br><strong>​        1.RDB模式能够定期持久化,但是有丢失数据的风险.</strong><br><strong>​        2.Redis中默认的持久化策略</strong><br><strong>​        3.RDB模式做内存的快照. 效率高</strong><br><strong>​        4.占用磁盘空间较小.</strong></p><h4 id="RDB模式配置"><a href="#RDB模式配置" class="headerlink" title="RDB模式配置"></a>RDB模式配置</h4><p><strong>1. 修改持久化文件名称</strong><br><img src="https://s2.ax1x.com/2019/06/24/ZAsA2j.png" alt><br><strong>2.持久化文件目录设定</strong><br><img src="https://s2.ax1x.com/2019/06/24/ZAsmq0.png" alt><br><strong>3.持久化策略</strong><br><strong>save 900 1      用户在900秒内做1次set操作时持久化1次</strong><br><strong>save 300 10     用户在300秒内做10次set草时持久化1次</strong><br><strong>save 60  10000        60秒内做10000次set 持久化一次</strong></p><p><strong>使用save持久化化时,如果执行持久化操作,则程序陷入阻塞.用户不能执行set.</strong></p><h3 id="AOF模式"><a href="#AOF模式" class="headerlink" title="AOF模式"></a>AOF模式</h3><p><strong>特点:</strong><br><strong>1. AOF模式可以实现数据的实时持久化.</strong><br><strong>2. 记录的是用户的操作过程.</strong><br><strong>3. 持久化文件会比较大.</strong><br><strong>4. 持久化效率低.</strong><br><strong>5. AOF模式默认是关闭的</strong><br><strong>6. AOF模式持久化是异步的.</strong></p><h4 id="AOF模式持久化策略"><a href="#AOF模式持久化策略" class="headerlink" title="AOF模式持久化策略"></a>AOF模式持久化策略</h4><p><strong>1.开启AOF模式</strong><br><img src="https://s2.ax1x.com/2019/06/24/ZAsMIU.png" alt><br><strong>2.修改持久化文件名称</strong><br><img src="https://s2.ax1x.com/2019/06/24/ZAsOoT.png" alt><br><strong>3.持久化策略</strong><br><strong># appendfsync always  只要用户执行”更新”命令则持久化一次</strong><br><strong>appendfsync everysec  每秒持久化一次.</strong><br><strong># appendfsync no        由默认的操作系统决定什么时候持久化.</strong></p><h3 id="Redis缓存策略说明"><a href="#Redis缓存策略说明" class="headerlink" title="Redis缓存策略说明"></a>Redis缓存策略说明</h3><p><strong>1. 如果有并发查询时.如果缓存服务器宕机/缓存失效.则查询数据库.可能导致数据库宕机. 俗称<font color="red*">缓存雪崩</font></strong><br><strong>2. 如果用户,高并发查询一个不存在的数据时.后台数据库有宕机的风险，俗称<font color="red*">缓存穿透</font></strong><br><strong>限流 直至封杀IP地址. IP模拟器</strong><br><strong>3. 如果高并发条件下.当某一个热点的key,超时或者失效时.数据库有宕机的风险.俗称:<font color="red*">缓存击穿</font></strong></p><h3 id="Redis内存机制"><a href="#Redis内存机制" class="headerlink" title="Redis内存机制"></a>Redis内存机制</h3><h4 id="业务需求"><a href="#业务需求" class="headerlink" title="业务需求"></a>业务需求</h4><p><strong>Redis中的数据都保存内存中.内存中的数据如果一味的新增,不删除则内存数据很快存满.导致新的数据保存错误.</strong><br><strong>需求:用户每次都能存储数据,但是内存大小是可控的.要求动态维护内存大小.</strong></p><h4 id="Redis中内存策略"><a href="#Redis中内存策略" class="headerlink" title="Redis中内存策略"></a>Redis中内存策略</h4><h5 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h5><p><strong><a href="https://baike.baidu.com/item/内存管理/5633616" target="_blank" rel="noopener">内存管理</a>的一种页面置换算法，对于在内存中但又不用的<a href="https://baike.baidu.com/item/数据块/107672" target="_blank" rel="noopener">数据块</a>（内存块）叫做LRU，操作系统会根据哪些数据属于LRU而将其移出内存而腾出空间来加载另外的数据。</strong></p><h5 id="LFU算法"><a href="#LFU算法" class="headerlink" title="LFU算法"></a>LFU算法</h5><p><strong>LFU（least frequently used (LFU) page-replacement algorithm）。即最不经常使用页置换算法，要求在页置换时置换引用计数最小的页，因为经常使用的页应该有一个较大的引用次数。但是有些页在开始时使用次数很多，但以后就不再使用，这类页将会长时间留在内存中，因此可以将引用计数寄存器定时右移一位，形成指数衰减的平均使用次数。</strong></p><p><strong>LFU:根据数据使用的次数多少删除数据.</strong></p><h5 id="内存优化策略"><a href="#内存优化策略" class="headerlink" title="内存优化策略"></a>内存优化策略</h5><p><strong>1. volatile-lru设定超时时间的数据采用LRU算法删除数据.</strong><br><strong>2. allkeys-lru所有的数据采用LRU算法删除数据</strong><br><strong>3. volatile-lfu设定了超时时间的数据采用LFU删除数据</strong><br><strong>4. allkeys-lfu所有的数据采用LFU算法删除数据</strong><br><strong>5. volatile-random设定了超时时间的随机删除</strong><br><strong>6. allkeys-random所有key随机删除</strong><br><strong>7. volatile-ttl设定了超时时间的数据排序.将马上要超时的数据提前删除.</strong><br><strong>8. Noeviction不删除数据.如果内存数据存满则报错返回. 该策略是默认策略</strong><br><img src="https://s2.ax1x.com/2019/06/24/ZA2sbR.png" alt></p><h2 id="Redis主从同步"><a href="#Redis主从同步" class="headerlink" title="Redis主从同步"></a>Redis主从同步</h2><h3 id="高可用介绍-HA"><a href="#高可用介绍-HA" class="headerlink" title="高可用介绍(HA)"></a>高可用介绍(HA)</h3><p><strong>“高可用性”（High Availability）通常来描述一个系统经过专门的设计，从而减少停工时间，而保持其服务的高度可用性。</strong><br><strong>概括:利用技术手段实现了当服务器宕机,自动的实现故障的迁移.</strong></p><h3 id="业务说明"><a href="#业务说明" class="headerlink" title="业务说明"></a>业务说明</h3><p><strong>Redis的最终形态必须实现高可用,实现高可用的前提必须满足<font color="orange">主从同步</font>.</strong><br><strong>当发生故障,由于从机与主机的数据是相同的,所以可以非常灵活实现数据的故障迁移.</strong></p><h3 id="主从同步搭建"><a href="#主从同步搭建" class="headerlink" title="主从同步搭建"></a>主从同步搭建</h3><h4 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h4><p><strong>说明:将分片文件夹shards复制为sentinel.（shards文件参考上方分片）</strong><br><strong>cp –r shards sentinel</strong><br><img src="https://s2.ax1x.com/2019/06/24/ZA42cT.md.png" alt></p><h4 id="检查主从关系"><a href="#检查主从关系" class="headerlink" title="检查主从关系"></a>检查主从关系</h4><p><strong>进入Redis-6379客户端，输入<code>info replication</code></strong><br><img src="https://s2.ax1x.com/2019/06/24/ZA5gIA.md.png" alt></p><h4 id="实现主从挂载"><a href="#实现主从挂载" class="headerlink" title="实现主从挂载"></a>实现主从挂载</h4><p><strong>说明:6379当主机, 6380/6381当从机.</strong><br><strong>命令:在客户端中cli端 执行指令 ****<code>saveof  IP  端口</code></strong><br><img src="https://s2.ax1x.com/2019/06/24/ZAok7Q.md.png" alt></p><p><strong>挂载情况</strong><br><img src="https://s2.ax1x.com/2019/06/24/ZAoUc6.md.png" alt></p><p><strong>主从测试</strong></p><p><strong>当在6379中写入数据时,从机80/81也同步了数据.</strong></p><h4 id="主从同步持久性"><a href="#主从同步持久性" class="headerlink" title="主从同步持久性"></a>主从同步持久性</h4><p><strong>问题说明:通过slaveof指令可以指定主从关系.如果从机关闭之后重启问情况如何??</strong><br><strong>回答:</strong><br><strong>​        当6381重启之后,发现主从结构不存在了.6381变为主机.</strong><br><strong>如何解决该问题:</strong><br><strong>​    需求:当6381为从机时,当重启服务器依然是从机.</strong><br><strong>​    需要人为的动态修改redis.conf配置文件.</strong></p><h3 id="Redis哨兵实现高可用"><a href="#Redis哨兵实现高可用" class="headerlink" title="Redis哨兵实现高可用"></a>Redis哨兵实现高可用</h3><h4 id="Redis中哨兵的作用"><a href="#Redis中哨兵的作用" class="headerlink" title="Redis中哨兵的作用"></a>Redis中哨兵的作用</h4><p><strong>分片作用:redis分片实现了redis内存扩容.</strong><br><strong>Redis哨兵:主要实现了redis节点的高可用.</strong></p><h4 id="Redis哨兵实现步骤"><a href="#Redis哨兵实现步骤" class="headerlink" title="Redis哨兵实现步骤"></a>Redis哨兵实现步骤</h4><p><strong>1. redis哨兵会监听redis主节点.</strong><br><strong>目的1:检查主节点是否存活</strong><br><strong>目的2:获取连接主节点的从机. IP:端口</strong><br><strong>2. 当利用ping-pong检测机制.检查主节点是否存活,当哨兵连续3次检测都没有数据返回.则表明主节点宕机.</strong><br><strong>3. 哨兵根据从主节点获取的从节点信息,进行推选.从中挑选一台新的从节点当做现在的主节点.将新的主从关系写入其他节点的redis.conf文件中.</strong><br><strong>4. 当服务器重启后,能够了解当前主从关系,实现了redis高可用.</strong><br><img src="https://s2.ax1x.com/2019/06/24/ZAHt9s.png" alt></p><h4 id="Redis哨兵配置"><a href="#Redis哨兵配置" class="headerlink" title="Redis哨兵配置"></a>Redis哨兵配置</h4><h5 id="复制哨兵配置文件"><a href="#复制哨兵配置文件" class="headerlink" title="复制哨兵配置文件"></a>复制哨兵配置文件</h5><p><strong>cp sentinel.conf sentinel/</strong></p><h5 id="编辑sentinel配置文件"><a href="#编辑sentinel配置文件" class="headerlink" title="编辑sentinel配置文件"></a>编辑sentinel配置文件</h5><p><strong>1. 关闭保护模式    17行</strong><br><img src="https://s2.ax1x.com/2019/06/24/ZAquef.png" alt></p><p><strong>2.开启哨兵后台启动   26行</strong><br><img src="https://s2.ax1x.com/2019/06/24/ZAqDfJ.md.png" alt></p><p><strong>3.修改哨兵监控    84行</strong><br><strong>sentinel monitor mymaster 127.0.0.1 6379 1</strong><br><strong>mymaster:当前主机的变量</strong><br><strong>IP:端口:  redis主节点的IP和端口</strong><br><strong>投票生效票数:  ****规则:<font color="red">超半数即可,哨兵的数量是奇数</font>.</strong><br><img src="https://s2.ax1x.com/2019/06/24/ZAqHXt.md.png" alt></p><p><strong>4.主机宕机后多久进行推选.</strong><br><img src="https://s2.ax1x.com/2019/06/24/ZALm9J.md.png" alt></p><p><strong>5.修改哨兵推选失败超时时间.</strong><br><img src="https://s2.ax1x.com/2019/06/24/ZALwut.md.png" alt></p><h4 id="Redis哨兵测试"><a href="#Redis哨兵测试" class="headerlink" title="Redis哨兵测试"></a>Redis哨兵测试</h4><p><strong>1. 启动redis哨兵</strong><br><strong>redis-sentinel sentinel.conf</strong><br><img src="https://s2.ax1x.com/2019/06/24/ZAOma8.md.png" alt></p><p><strong>2. 当关闭redis-6379之后等10秒之后.检查主从结构是否正确.</strong><br><img src="https://s2.ax1x.com/2019/06/24/ZAOXWQ.md.png" alt></p><h4 id="Spring整合哨兵"><a href="#Spring整合哨兵" class="headerlink" title="Spring整合哨兵"></a>Spring整合哨兵</h4><h5 id="入门案例-2"><a href="#入门案例-2" class="headerlink" title="入门案例"></a>入门案例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试哨兵get/set操作</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//masterName 代表主机的变量名称</span></span><br><span class="line"><span class="comment">//sentinels  Set&lt;String&gt;  IP:端口</span></span><br><span class="line">Set&lt;String&gt; sentinels = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">sentinels.add(<span class="string">"192.168.175.129:26379"</span>);</span><br><span class="line">JedisSentinelPool sentinelPool = </span><br><span class="line"><span class="keyword">new</span> JedisSentinelPool(<span class="string">"mymaster"</span>, sentinels);</span><br><span class="line">Jedis jedis = sentinelPool.getResource();</span><br><span class="line">jedis.set(<span class="string">"z"</span>, <span class="string">"dd"</span>);</span><br><span class="line">System.out.println(jedis.get(<span class="string">"z"</span>));</span><br><span class="line">jedis.close();<span class="comment">//关闭链接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Spring整合哨兵思路"><a href="#Spring整合哨兵思路" class="headerlink" title="Spring整合哨兵思路"></a>Spring整合哨兵思路</h5><p><strong>1. 利用配置类,封装JedisSentinelPool.</strong><br><strong>2. 利用工具API封装2个方法.set/get</strong></p><h5 id="编辑pro文件-1"><a href="#编辑pro文件-1" class="headerlink" title="编辑pro文件"></a>编辑pro文件</h5><p><strong>redis.sentinels=192.168.175.129:26379</strong><br><strong>redis.sentinel.masterName=mymaster</strong></p><h5 id="编辑配置类-2"><a href="#编辑配置类-2" class="headerlink" title="编辑配置类"></a>编辑配置类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示redis配置类</span></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">//xml</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:/properties/redis.properties"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;redis.sentinels&#125;"</span>)   </span><br><span class="line"><span class="keyword">private</span> String jedisSentinelNodes;</span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;redis.sentinel.masterName&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String masterName;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JedisSentinelPool <span class="title">jedisSentinelPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Set&lt;String&gt; sentinels = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">sentinels.add(jedisSentinelNodes);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JedisSentinelPool(masterName, sentinels);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="编辑工具API"><a href="#编辑工具API" class="headerlink" title="编辑工具API"></a>编辑工具API</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisService</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)<span class="comment">//调用时才注入</span></span><br><span class="line"><span class="keyword">private</span> JedisSentinelPool sentinelPool;</span><br><span class="line"><span class="comment">//封装方法  get</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">Jedis jedis = sentinelPool.getResource();</span><br><span class="line">String result = jedis.get(key);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String key,String value)</span> </span>&#123;</span><br><span class="line">Jedis jedis = sentinelPool.getResource();</span><br><span class="line">jedis.set(key, value);</span><br><span class="line">jedis.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setex</span><span class="params">(String key,<span class="keyword">int</span> seconds,String value)</span> </span>&#123;</span><br><span class="line">Jedis jedis = sentinelPool.getResource();</span><br><span class="line">jedis.setex(key, seconds, value);</span><br><span class="line">jedis.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="编辑RedisAOP配置项"><a href="#编辑RedisAOP配置项" class="headerlink" title="编辑RedisAOP配置项"></a>编辑RedisAOP配置项</h5><p><img src="https://s2.ax1x.com/2019/06/24/ZAvRiT.md.png" alt></p><h5 id="项目测试"><a href="#项目测试" class="headerlink" title="项目测试"></a>项目测试</h5><p><strong>说明:重启tomcat服务器.检查程序调用是否正确.当redis节点宕机时.检查是否影响用户操作redis.</strong></p><h2 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p><strong>1. Redis分片</strong><br><strong>用户通过API利用hash一致性算法,实现了数据存储.利用分片机制实现了内存的扩容!!!</strong><br><strong>缺点:如果一个节点宕机.,则违反单调性要求,分片失效.</strong><br><strong>2. Redis哨兵</strong><br><strong>哨兵基于心跳检测机制.实现redis节点高可用.但是前提必须配置主从.</strong><br><strong>哨兵缺点:</strong><br><strong>1. 操作的redis依然是单台,内存无法扩容.</strong><br><strong>2. Redis哨兵也有可能宕机.</strong></p><p><strong>分片:没有高可用效果.</strong><br><strong>哨兵:哨兵本身没有高可用需要借助第三方. 内存没有扩容.</strong></p><h3 id="Redis集群介绍"><a href="#Redis集群介绍" class="headerlink" title="Redis集群介绍"></a>Redis集群介绍</h3><p><strong>说明:搭建redis集群可以实现redis分片和哨兵的全部功能!!!.Redis集群中<font color="red">所有的主节点参与选举</font>.redis集群中全部的节点都能互相通信.所有的节点都有投票权(发现某个节点宕机投票数+1)</strong></p><h3 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h3><h4 id="集群设计"><a href="#集群设计" class="headerlink" title="集群设计"></a>集群设计</h4><p><strong>最小的集群单位3个主节点,从机不做要求,搭建策略一主一从</strong><br><strong>主机3台</strong><br><strong>​    端口:7000/7001/7002</strong><br><strong>从机3台</strong><br><strong>​    端口:7003/7004/7005</strong></p><h4 id="准备集群文件"><a href="#准备集群文件" class="headerlink" title="准备集群文件"></a>准备集群文件</h4><p><strong>1.准备集群文件夹</strong></p><p><strong>redis根目录下<code>Mkdir cluster</code></strong></p><p><strong>2.在cluster文件夹中分别创建7000-7005文件夹</strong><br><strong><code>mkdir 7000 7001 7002 7003 7004 7005</code></strong></p><h4 id="复制配置文件-1"><a href="#复制配置文件-1" class="headerlink" title="复制配置文件"></a>复制配置文件</h4><p><strong>说明:</strong><br><strong>将redis根目录中的redis.conf文件复制到cluster/7000/ 并以原名保存</strong><br><strong><code>cp redis.conf cluster/7000/</code></strong></p><h4 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h4><p><strong>1. 注释本地绑定IP地址</strong><br><img src="https://s2.ax1x.com/2019/06/24/ZEpDhV.png" alt></p><p><strong>2.关闭保护模式</strong><br><img src="https://s2.ax1x.com/2019/06/24/ZEphA1.png" alt></p><p><strong>3.修改端口号</strong><br><img src="https://s2.ax1x.com/2019/06/24/ZEpo9K.png" alt></p><p><strong>4. 启动后台启动</strong><br><img src="https://s2.ax1x.com/2019/06/24/ZEpHje.png" alt></p><p><strong>5. 修改pid文件</strong><br><img src="https://s2.ax1x.com/2019/06/24/ZEpx4P.md.png" alt></p><p><strong>6. 修改持久化文件路径</strong><br><img src="https://s2.ax1x.com/2019/06/24/ZE9FBj.md.png" alt></p><p><strong>7. 设定内存优化策略</strong><br><img src="https://s2.ax1x.com/2019/06/24/ZE9mCV.md.png" alt></p><p><strong>8. 关闭AOF模式</strong><br><img src="https://s2.ax1x.com/2019/06/24/ZE9KvF.md.png" alt></p><p><strong>9. 开启集群配置</strong><br><img src="https://s2.ax1x.com/2019/06/24/ZE9Qu4.png" alt></p><p><strong>10. 开启集群配置文件，保存集群中的状态信息.谁是主机,谁是从机</strong><br><img src="https://s2.ax1x.com/2019/06/24/ZE91b9.md.png" alt></p><p><strong>11. 修改集群超时时间</strong><br><img src="https://s2.ax1x.com/2019/06/24/ZE9UgO.png" alt></p><h4 id="复制修改后的配置文件"><a href="#复制修改后的配置文件" class="headerlink" title="复制修改后的配置文件"></a>复制修改后的配置文件</h4><p><strong>说明:将7000文件夹下的redis.conf文件分别复制到7001-7005中</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost cluster]# cp 7000/redis.conf  7001/</span><br><span class="line">[root@localhost cluster]# cp 7000/redis.conf  7002/</span><br><span class="line">[root@localhost cluster]# cp 7000/redis.conf  7003/</span><br><span class="line">[root@localhost cluster]# cp 7000/redis.conf  7004/</span><br><span class="line">[root@localhost cluster]# cp 7000/redis.conf  7005/</span><br></pre></td></tr></table></figure><h4 id="批量修改"><a href="#批量修改" class="headerlink" title="批量修改"></a>批量修改</h4><p><strong>说明:分别将7001-7005文件中的7000改为对应的端口号的名称,</strong><br><strong>修改时注意方向键的使用</strong><br><img src="https://s2.ax1x.com/2019/06/24/ZE9XMF.md.png" alt></p><h4 id="通过脚本编辑启动-关闭命令"><a href="#通过脚本编辑启动-关闭命令" class="headerlink" title="通过脚本编辑启动/关闭命令"></a>通过脚本编辑启动/关闭命令</h4><p><strong>1. 创建启动脚本  <code>vim start.sh</code></strong><br><img src="https://s2.ax1x.com/2019/06/24/ZECMJP.png" alt></p><p><strong>2.编辑关闭的脚本    <code>vim  shutdown.sh</code></strong><br><img src="https://s2.ax1x.com/2019/06/24/ZEC0zT.png" alt></p><p><strong>3.启动redis节点<code>sh start.sh</code></strong></p><p><strong>4.检查redis节点启动是否正常</strong></p><p><strong><code>ps ef | grep redis</code></strong><br><img src="https://s2.ax1x.com/2019/06/25/ZEh19x.md.png" alt></p><h4 id="创建redis集群"><a href="#创建redis集群" class="headerlink" title="创建redis集群"></a>创建redis集群</h4><p><strong>#5.0版本执行 使用C语言内部管理集群</strong><br><strong><code>redis-cli --cluster create --cluster-replicas 1 192.168.35.130:7000 192.168.35.130:7001 192.168.35.130:7002 192.168.35.130:7003 192.168.35.130:7004 192.168.35.130:7005</code></strong><br><img src="https://s2.ax1x.com/2019/06/25/ZEhGjO.md.png" alt><br><img src="https://s2.ax1x.com/2019/06/25/ZEhYuD.md.png" alt><br><img src="https://s2.ax1x.com/2019/06/25/ZEhtDe.png" alt></p><h4 id="Redis高可用测试"><a href="#Redis高可用测试" class="headerlink" title="Redis高可用测试"></a>Redis高可用测试</h4><p><strong>1. 关闭redis主机.检查是否自动实现故障迁移.</strong><br><strong>2. 再次启动关闭的主机.检查是否能够实现自动的挂载.</strong><br><strong>一般情况下 能够实现主从挂载</strong><br><strong>个别情况: 宕机后的节点重启,可能挂载到其他主节点中(7001-7002) 正确的</strong><br><img src="https://s2.ax1x.com/2019/06/25/ZEhw4I.png" alt></p><h3 id="Redis集群工作原理"><a href="#Redis集群工作原理" class="headerlink" title="Redis集群工作原理"></a>Redis集群工作原理</h3><h4 id="数据存储原理"><a href="#数据存储原理" class="headerlink" title="数据存储原理"></a>数据存储原理</h4><p><strong><font color="orange">分片数据存储原理</font>: 根据hash一致性算法实现数据存储.</strong><br><strong>Hash一致性运算发生在服务器端.</strong><br><strong>在存储数据前已经计算完成存储到哪台redis服务器中.</strong><br><strong>分片中存在的问题:</strong><br>*<em>​    分片的数据是用户通过服务器程序计算进行存储.用户也可以利用redis的客户端进行非法的操作.修改分片中的数据!!!    *</em></p><p><strong><font color="orange">集群中数据存储</font>：1.当在从节点中存储数据时.不允许操作,只有主节点能够set/get数据。2.Redis集群与分片明显不同.存储数据必须满足条件.</strong><br><img src="https://s2.ax1x.com/2019/06/25/ZEhf5n.md.png" alt><br><img src="https://s2.ax1x.com/2019/06/25/ZE4eRP.md.png" alt></p><p><strong><font color="orange">Redis集群储存条件</font>：</strong><br><img src="https://s2.ax1x.com/2019/06/25/ZE4KsS.md.png" alt><br><img src="https://s2.ax1x.com/2019/06/25/ZE4Mqg.png" alt><br><strong>说明:redis集群一共有16384个槽位.这些操作会均匀的分配给主节点.</strong><br><strong>当数据进行存取时首先根据key进行计算.计算槽位的位置.之后从节点中获取数据.</strong><br><img src="https://s2.ax1x.com/2019/06/25/ZE4lZQ.md.png" alt><br><strong>Crc16算法</strong></p><h4 id="Redis集群宕机条件"><a href="#Redis集群宕机条件" class="headerlink" title="Redis集群宕机条件"></a>Redis集群宕机条件</h4><p><strong>宕机条件:Redis集群宕机的条件是<font color="red">主节点宕机</font>则集群奔溃</strong><br><strong>例子:9个redis节点   3主6从 节点宕机多少次集群奔溃</strong><br><strong>5-7台集群奔溃</strong><br><img src="https://s2.ax1x.com/2019/06/25/ZE4YR0.png" alt><br><strong>条件说明:Redis集群中当节点宕机后,由主节点进行推选.如果当前节点没有从节点时.从其他主节点中借用多余的从节点</strong></p><h3 id="SpringBoot整合Redis集群"><a href="#SpringBoot整合Redis集群" class="headerlink" title="SpringBoot整合Redis集群"></a>SpringBoot整合Redis集群</h3><h4 id="测试案例"><a href="#测试案例" class="headerlink" title="测试案例"></a>测试案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Set&lt;HostAndPort&gt; sets = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">sets.add(<span class="keyword">new</span> HostAndPort(<span class="string">"192.168.175.129"</span>,<span class="number">7000</span>));</span><br><span class="line">sets.add(<span class="keyword">new</span> HostAndPort(<span class="string">"192.168.175.129"</span>,<span class="number">7001</span>));</span><br><span class="line">sets.add(<span class="keyword">new</span> HostAndPort(<span class="string">"192.168.175.129"</span>,<span class="number">7002</span>));</span><br><span class="line">sets.add(<span class="keyword">new</span> HostAndPort(<span class="string">"192.168.175.129"</span>,<span class="number">7003</span>));</span><br><span class="line">sets.add(<span class="keyword">new</span> HostAndPort(<span class="string">"192.168.175.129"</span>,<span class="number">7004</span>));</span><br><span class="line">sets.add(<span class="keyword">new</span> HostAndPort(<span class="string">"192.168.175.129"</span>,<span class="number">7005</span>));</span><br><span class="line">JedisCluster cluster = <span class="keyword">new</span> JedisCluster(sets);</span><br><span class="line">cluster.set(<span class="string">"1902"</span>, <span class="string">"集群搭建完成"</span>);</span><br><span class="line">System.out.println(<span class="string">"获取集群数据:"</span>+cluster.get(<span class="string">"1902"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编辑pro文件-2"><a href="#编辑pro文件-2" class="headerlink" title="编辑pro文件"></a>编辑pro文件</h4><p><strong><code>redis.nodes=192.168.175.129:7000,192.168.175.129:7001,192.168.175.129:7002,192.168.175.129:7003,192.168.175.129:7004,192.168.175.129:7005</code></strong></p><h4 id="编辑配置类-3"><a href="#编辑配置类-3" class="headerlink" title="编辑配置类"></a>编辑配置类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示redis配置类</span></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">//xml</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:/properties/redis.properties"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"><span class="comment">//redis.nodes=192.168.175.129:7000,192.168.175.129:7001,192.168.175.129:7002,192.168.175.129:7003,192.168.175.129:7004,192.168.175.129:7005</span></span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;redis.nodes&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String redisNodes;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JedisCluster <span class="title">jedisCluster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Set&lt;HostAndPort&gt; nodes = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="comment">//1.根据,号拆分为多个node</span></span><br><span class="line">String[] strNode = redisNodes.split(<span class="string">","</span>);</span><br><span class="line"><span class="comment">//IP:端口</span></span><br><span class="line"><span class="keyword">for</span> (String node : strNode) &#123;</span><br><span class="line">String host = node.split(<span class="string">":"</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> port = Integer.parseInt(node.split(<span class="string">":"</span>)[<span class="number">1</span>]);</span><br><span class="line">HostAndPort hostAndPort = </span><br><span class="line"><span class="keyword">new</span> HostAndPort(host, port);</span><br><span class="line">nodes.add(hostAndPort);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JedisCluster(nodes);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="修改AOP切面"><a href="#修改AOP切面" class="headerlink" title="修改AOP切面"></a>修改AOP切面</h4><p><img src="https://s2.ax1x.com/2019/06/25/ZE4BdJ.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Redis介绍&quot;&gt;&lt;a href=&quot;#Redis介绍&quot; class=&quot;headerlink&quot; title=&quot;Redis介绍&quot;&gt;&lt;/a&gt;Redis介绍&lt;/h2&gt;&lt;p&gt;Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件
      
    
    </summary>
    
      <category term="redis" scheme="https://51461.github.io/blog/categories/redis/"/>
    
    
      <category term="java" scheme="https://51461.github.io/blog/tags/java/"/>
    
      <category term="redis" scheme="https://51461.github.io/blog/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>微服务基础</title>
    <link href="https://51461.github.io/blog/2019/06/24/weifuwu/"/>
    <id>https://51461.github.io/blog/2019/06/24/weifuwu/</id>
    <published>2019-06-24T06:08:53.000Z</published>
    <updated>2019-06-24T10:32:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="微服务架构背景"><a href="#微服务架构背景" class="headerlink" title="微服务架构背景"></a>微服务架构背景</h2><p><strong>从软件开发之初，业界一直致力于寻找大型分布式应用系统开发的“银弹”从结构化编程、面向对象，到COBRA、EJB、ESB、SOA等。Fread Brooks在《没有银弹：软件工程的本质性与附属性工作》一文中提出：<font color="f02f00">大型分布式系统具有复杂性、隐匿性、配合性和易变性四大难题</font>，不会存在任何单一软件工程上的突破，能够让开发生产力得到一个数量上的提升。而<font color="f0500">微服务的出现虽然不是一颗“银弹”，但它给出了四大难题的对策，解决了以往单体架构系统构建的困境</font></strong></p><h2 id="单体架构的困境"><a href="#单体架构的困境" class="headerlink" title="单体架构的困境"></a>单体架构的困境</h2><p><strong>Java开发中一个单体架构应用就是将一个应用中的所有功能都打包到一个war文件中，并部署到服务器（Tomcat）中运行</strong></p><p><strong><font color="blue">对于单体架构来说，随着业务的扩张，其开发、部署和运维都会越来越慢，越来越复杂，甚至在单体架构应用开发中敏捷模式都无法施展开。</font></strong></p><p><strong>在单体架构中，一个应用承载的职责太多，其开发、部署运维复杂度都会呈几何形增长，应用的每次编译和启动都需要更长的时间，每次需要修改、增加新功能时都需要更多的协调和测试。而对于新功能，每次修正bug都会使系统的代码更加复杂，使<font color="blue">开发——编译——启动——测试进入了一种恶性循环，大大降低了开发效率</font>。</strong></p><p><strong>单体架构应用逐渐变得不稳定，一方面是因为<font color="blue">系统不断增长的复杂性</font>造成的，另一方面是由于<font color="blue">系统本身牵一发而动全身的特性</font>造成的，可能一个不常用的模块因为存在内存泄漏而造成整个服务器无法正常提供服务，甚至引起服务崩溃</strong></p><p><strong>在数据管理上单体架构应用容易产生漏洞，最常见的就是数据管理。单体架构往往要管理的数据类型/表都非常多，而且分布在不同团队之间，如果沟通不好可能某些团队的开发会直接操纵数据库表，最常见的就是在数据层通过写SQL语句操作数据表。这种做法相当于埋下了定时炸弹，<font color="blue">当数据相关团队修改了数据库结构，由于之前团队之间使用SQL语句进行处理，程序在系统编译、打包和测试时都有可能通过，但当在真实的生产环境使用时就有可能造成服务的崩溃</font></strong></p><p><strong><font color="blue">单体架构的应用开发时要求我们必须使用同一个技术栈</font>，使得单体架构应用很难接受或切换到其他框架、语言。因为重写风险太大，即使有更合适的开发框架或语言，甚至应用使用的框架有了新版本，也很难进行升级</strong></p><p><strong>单体架构应用开发对于开发者来说，需要了解更多的东西，如系统架构、统一的开发模式、与之交互的相关模块等，造成了一个新加入的开发者需要更长的时间才能够进入开发状态</strong></p><p><strong>最后，单体架构应用还有一个显著的问题：<font color="blue">多名开发者同时修改一个代码库</font>。一方面需要<font color="orange">开发者自己快速提交修改的代码</font>，另一方面<font color="orange">开发者每次提交修改都要祈求代码不要发生冲突</font>这也造成了代码库很难快速进入稳定可发布状态</strong></p><p><strong>在部署上，单体架构应用还会造成系统难以进行水平扩展，因为每一个应用实例对服务器来说都需要相同的硬件配置，这让服务器无法充分发挥其能力，造成浪费，并且<font color="blue">部署的服务速度会随着代码积累逐渐变慢，性能降低</font></strong></p><h2 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h2><p><strong>微服务架构中的服务和模块化开发很相似，单服务是有明确服务边界的，所以更易于开发和管控，同时也更易于单独部署和扩展</strong><br><strong>模块化开发是在大型开发、复杂应用中常用的开发方式，大型应用的开发往往是一个人无法掌控全局的，通过模块化的方式将应用分解成多个具有关联的模块，并交由不同开发团队来完成。模块之间的调用直接使用接口，依赖关系则是可以使用Maven等工具进行管理</strong></p><h3 id="微服务架构的定义"><a href="#微服务架构的定义" class="headerlink" title="微服务架构的定义"></a>微服务架构的定义</h3><p><strong>微服务架构可以说是一种<font color="red*">将功能分解成一系列服务的一种架构模式</font>。对于一个应用系统包含两部分的需求：第一部分是功能需求，用于定义一个应用是用来做什么的，该应用系统用来达到什么目的。第二部分是非功能需求，包括了对应用系统的扩展性、灵活性，还有性能、运维、安全、测试、监控等需求，这种非功能性需求是用来保障业务系统能够正确、顺畅的运行。而对于微服务来说，更侧重于第二种需求</strong></p><p><strong>微服务从结构上来看就是<font color="blue">将一个应用拆分成多个松耦合的服务</font>，这些服务之间通过某种协议（REST、RPC等）进行互相协作，完成单元体架构下的业务功能，但提供更灵活的部署模式，更容易扩展，降低了开发、运维上的复杂度。</strong></p><p><strong>微服务的核心思路就是<font color="blue">分而治之</font></strong></p><p><strong>服务是一个可以独立运行、提供范围有限的功能(可以是业务功能，也可以是非业务功能)的组件。功能具体实现隐藏在组件内部，而对外提供访问接口，外部其他服务可以通过这些接口进行访问交互</strong></p><h3 id="微服务架构的优点"><a href="#微服务架构的优点" class="headerlink" title="微服务架构的优点"></a>微服务架构的优点</h3><p><strong><font color="blue">松耦合</font>：基于微服务架构的应用是一系列小服务的集合，这些服务之间通过非具体实现的接口及非专有通信协议进行通信(比如REST)，这样只要原接口没有变，就不会对服务消费者造成任何影响</strong></p><p><strong><font color="blue">抽象</font>：一个微服务对其数据结构和数据源有绝对的控制权，只有该服务才可以对数据进行修改，其他微服务只有通过该服务才能够访问数据。因此该服务可以很方便的对所能提供的数据进行有效控制</strong></p><p><strong><font color="blue">独立</font>：每个微服务都可以在不影响其他微服务的情况下进行编译、打包和部署，这是单体架构应用无法做到的</strong></p><p><strong><font color="blue">多样性</font>：微服务架构可以让我们轻松应对不同客户的特殊需求，通过定义良好的接口，可以让不同的微服务承担不同的职责，同时快速部署上线能力可以让用户需求尽早实现</strong></p><p><strong><font color="blue">更高可用性和弹性</font>：微服务架构可以认为是一个去中心化的应用，每一个微服务都可以随时上线下线。这样当某个微服务出现问题时只需要将其下线即可，其他同类型的微服务将承担其功能，对外仍旧可以提供服务，不会造成整个服务器无法正常工作。</strong></p><p><strong>微服务项目工程代码少，不会造成IDE速度变慢，开发和调试速度也会非常有效率。微服务架构不会要求我们在一个应用中选用同一个技术栈，每个服务可以根据应用特性、开发人员特长选择合适的开发语言和框架。因为微服务足够小，非常容易重构或重写，同时在重构或重写时可以选择合适的开发语言和框架，而且一旦有更适合的技术也可以在低风险的情况下对应用进行升级或改造，而不至于影响整个应该。通过微服务架构可以为我们带来<font color="blue">开发、运维、升级上的灵活性</font></strong></p><p><strong>因为每个服务都可以独立进行部署，开发人员可以很快对自己所开发的服务做出变更，而不会影响其他服务，也不会受其他服务影响，<font color="blue">持续集成和开发都很灵活</font></strong></p><p><strong>每个微服务都可以快速的实施X（运行多个应用实例）、Z（数据分区的扩展）轴扩展（提升应用的容量和可用性），并为每个服务定义合适的硬件环境（I/O密集型、计算密集型），而不像单体架构采用大锅饭形式，可以为组织<font color="blue">节约硬件成本</font></strong></p><p><strong><font color="blue">错误隔离</font>：比如一个服务内存泄漏，它只会影响自身微服务实例，不会影响到其他微服务</strong></p><h3 id="微服务的缺点"><a href="#微服务的缺点" class="headerlink" title="微服务的缺点"></a>微服务的缺点</h3><p><strong><font color="blue">可用性降低</font>：微服务之间都是通过远程调用进行协作的，而远程调用的代名词就是不稳定，如果没有有效的方案，微服务架构可能会大大降低应用的可用性。当一个服务不可用时，有可能会引起级联反应，最终造成应用的“雪崩效应”而拖垮整个应用</strong></p><p><strong><font color="blue">处理分布式事务较棘手</font>：当一个用户请求的业务涉及多个微服务时，如何保障数据的一致性就成为一个棘手的问题。传统开发通常会使用两阶段提交的解决方案来解决这个问题。但对于微服务架构来说，这个解决方案并不是一个很好的选择，甚至在某些情况下很难实现。</strong></p><p><strong><font color="blue">全能对象阻止业务拆分</font>：在进行微服务拆分时最让人头疼的一个问题就是全能对象，几乎对于任何一个业务的应用来说都可能存在一个或多个这样的全能对象。比如电子商城中的订单，订单几乎涉及到电商应用中的每一个业务，它会阻止你进行业务拆分</strong></p><p><strong><font color="blue">学习难度曲线加大</font>：微服务架构虽然可以将业务可以分解为更小、更容易开发的模式，但也需要开发人员学习掌握一门微服务开发技术，加大了进入门槛。</strong></p><p><strong><font color="blue">组织结构变更</font>：虽然对于单独一个微服务的部署简化了，但整个应用部署复杂度却提升了，需要涉及服务编排和服务治理等一系列处理，即不需要制定微服务之间的部署编排、关联关系、回滚计划等，还需要协调不同的团队，以及在人事组织上进行调整来适应这种变化</strong></p><h3 id="微服务架构设计的步骤"><a href="#微服务架构设计的步骤" class="headerlink" title="微服务架构设计的步骤"></a>微服务架构设计的步骤</h3><p><strong>1.把应用中的关键需求定义出来</strong></p><p><strong>2.识别出采用微服务架构时应用中所包含的所有服务</strong></p><p><strong>3.将第一步所定义出的关键需求作为架构需求的场景来描述服务之间如何进行协作</strong></p><h3 id="微服务拆分原则"><a href="#微服务拆分原则" class="headerlink" title="微服务拆分原则"></a>微服务拆分原则</h3><h4 id="单一职责原则（SRP）"><a href="#单一职责原则（SRP）" class="headerlink" title="单一职责原则（SRP）"></a>单一职责原则（SRP）</h4><p><strong>单一职责原则（Single Responsibility Principle）：一个类应该有且只有一个变化的原因</strong></p><p><strong>每一个职责都是一个变化引起类变化的中心。当功能变化时，通常需要通过更改相关的类来实现。如果一个类拥有多个职责，那么就会有多于一个原因来导致这个类的变化。另外，一个类承担多个职责后，往往这些职责就会耦合在一起，某一职责的改变可能会影响到其他的职责。这样的类设计是非常脆弱的，从而会导致应用的稳定性。因此，我们在进行类设计时要遵守单一职责原则。</strong></p><p><strong>同样，对于微服务设计来说，如果一个微服务承担太多职责的话，也会导致微服务业务之间的耦合，为业务进行改变时埋下了不稳定因素。所以，单一职责原则同样也适用于微服务设计，我们可以将<font color="orange">微服务保持足够小，仅拥有一个业务职责，保持微服务的业务单一性，从而提升应用的稳定性</font>。</strong></p><h4 id="共同封闭原则（CCP）"><a href="#共同封闭原则（CCP）" class="headerlink" title="共同封闭原则（CCP）"></a>共同封闭原则（CCP）</h4><p><strong>共同封闭原则（Common Closure Principle，CCP）：包中的所有的类对于同一种性质的变化应该是共同封闭的。一个变化若对一个封闭的包产生影响，则将对该包中的所有类产生影响，而对其他包则不造成任何影响。</strong></p><p><strong>共同封闭原则是延伸了面向对象开发中六大原则之一的开闭原则（OCP）中的关闭概念。就是说当需要修改某项业务时，我们需要将修改的范围限制在同一个包内，而不是遍布在很多包中。共同封闭原则指导我们如何对类进行有效的组织，将那些在业务概念上联系得非常紧密、通常一起发生改变的类，封装到同一个包中。通过共同封闭原则可以提升对应用组织上的管理。</strong></p><p><strong>同样，通过使用共同封闭原则可以将那些在业务上联系紧密，由于同一个原因而改变的服务组织在一个微服务中。这样一方面我们可以<font color="orange">减少微服务的数量</font>，另外一方面<font color="orange">当业务发生改变时我们只需要一个业务开发团队进行单独修改，只需要重新部署该服务即可，减少了不同微服务开发团队之间沟通成本</font>。</strong></p><h3 id="微服务自治原则"><a href="#微服务自治原则" class="headerlink" title="微服务自治原则"></a>微服务自治原则</h3><p><strong>一个团队越大，那么沟通与协助成本就会越高。因此，在微服务治理中有一个重要的理念就是自治，自治范围并不只是代码和数据，还包含微服务的运行和维护管理，所以亚马逊的微服务有一个规则：<font color="red*">你构建，你运行。</font></strong></p><p><strong>将微服务分而治之的另一个重要方面是数据管理的分而治之。传统单体架构应用的开发在很多时候多个业务之间的数据交互是直接通过操作数据库来完成，当需要更改某一业务数据库表时往往会涉及多个模块，甚至有时候根本不清楚修改这张数据库表到底会影响到多少业务代码，从而不敢动数据库表的定义，只好退而求其次，通过增加表来处理，进而加剧了系统架构的恶化。</strong></p><p><strong>虽然现在O／R mapping技术的出现从一定程度上解决了这个头痛的问题，但终未从根本上解决。而微服务中的分而治之理念，不但是指业务功能，也同时包含了对业务数据的管理。<font color="red*">将业务数据管理进行私有化之后就进一步降低了业务之间的耦合度</font>，所以实施微服务的架构师，一定要保持业务数据管理的私有化，即使你在项目中不能够分库，也要牢记这条规则，严格要求各微服务团队看好自己的数据。</strong></p><p><strong>服务架构中的数据自治是指每个微服务拥有其业务领域对象下的数据，<font color="red*">只有该微服务可以对这些数据进行操作（包含读取与更改），而其他微服务只有通过该服务才能访问到这些数据，不能直接通过数据库进行沟通。</font>因此，我们可以不用为每一个微服务创建一个独立数据库，可以将它们统一存放在一个数据库中，保障不破坏上述的数据访问原则即可。</strong></p><h3 id="微服务交互原则"><a href="#微服务交互原则" class="headerlink" title="微服务交互原则"></a>微服务交互原则</h3><p><strong><font color="red*">REST协议</font>：（http+uri）REST在微服务互相调用之间起着非常重要的角色，强烈建议使用HTTP作为服务的调用协议，并在服务处理上使用HTTP标准动词（GET、POST、PUT、DELETE）。</strong></p><p><strong><font color="red*">URI表达</font>：服务端点的URI应该能清晰的表达出我们想要解决的问题、提供的方法、相应资源信息及资源之间的关联关系</strong></p><p><strong><font color="red*">JSON数据格式</font>：JSON作为轻量级数据格式协议，及自带的序列化和反序列化机制，几乎已经成为通信中的数据标准协议，并且对于前端开发来说非常容易使用和整合</strong></p><p><strong><font color="red*">HTTP标准状态码</font>：HTTP协议本身具有非常丰富的状态码，那么使用这些状态码来作为服务调用结果的状态是非常合适的</strong></p><h3 id="微服务架构迁移"><a href="#微服务架构迁移" class="headerlink" title="微服务架构迁移"></a>微服务架构迁移</h3><p><strong>单体架构应用迁移到微服务架构意味着一个漫长的过程，不过这和在开发时经常做的代码重构类似，只是变成了对架构的重构，因此可以从中吸取一些思路。对于代码重构，有一个很重要的指导思想就是<font color="orange">不要大规模进行重构，而是一小步一小步来</font>。作为开发人员，每次听到重写代码可能会很兴奋，但实际上却是充满了风险，道路也是非常崎岖坎坷，最终也有可能会失败，每一个重写过代码的开发者可能对这一点深有体会。</strong></p><p><strong>因此，与大规模进行重构相反，在进行微服务架构迁移时可以使用Martin Fowler提出绞杀（Strangler）模式。该策略名字来源于雨林中的绞杀藤，绞杀藤为了能够爬到森林顶端都要缠绕着某棵大树生长，最终使被缠绕的大树死掉，只留下树形一样的绞杀藤。通过这种策略，我们在迁移时应首先围绕着传统应用开发出新的微服务应用，并逐渐替代传统应用中的部分业务功能。通过这种方式逐步构建微服务应用，并替代、兼容整合旧的传统应用，直到微服务承担全部应用功能，而传统单体架构应用此时也就可以退出历史舞台了。</strong></p><h3 id="不应用微服务的场景"><a href="#不应用微服务的场景" class="headerlink" title="不应用微服务的场景"></a>不应用微服务的场景</h3><p><strong>构建分布式架构非常吃力</strong></p><p><strong>服务器蔓延时</strong></p><p><strong>采用小型应用、快速产品原型时</strong></p><p><strong>对数据事务的一致性有一定要求时</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;微服务架构背景&quot;&gt;&lt;a href=&quot;#微服务架构背景&quot; class=&quot;headerlink&quot; title=&quot;微服务架构背景&quot;&gt;&lt;/a&gt;微服务架构背景&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;从软件开发之初，业界一直致力于寻找大型分布式应用系统开发的“银弹”从结构化编程、面向
      
    
    </summary>
    
      <category term="微服务" scheme="https://51461.github.io/blog/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="java" scheme="https://51461.github.io/blog/tags/java/"/>
    
      <category term="微服务" scheme="https://51461.github.io/blog/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>常用的算法思想——1</title>
    <link href="https://51461.github.io/blog/2019/06/23/suanfa/"/>
    <id>https://51461.github.io/blog/2019/06/23/suanfa/</id>
    <published>2019-06-23T09:43:12.000Z</published>
    <updated>2019-06-29T13:47:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="枚举算法"><a href="#枚举算法" class="headerlink" title="枚举算法"></a>枚举算法</h2><p><strong>枚举算法思想特点是在<font color="f02ff0">面对任何问题时它都会去尝试每一种解决方法</font>，在进行归纳推理时，如果逐个考察了某类事件的所有可能情况，因而得出一般结论，那么这个结论可能是可靠的，这种归纳方法叫<font color="0f25f">归纳法</font></strong></p><h3 id="枚举算法基础"><a href="#枚举算法基础" class="headerlink" title="枚举算法基础"></a>枚举算法基础</h3><p><strong>枚举算法思想是：<font color="f02ff0">将问题所有可能的答案一一列举，然后根据条件判断此答案是否合适，保留合适的，丢弃不合适的</font></strong></p><h4 id="枚举算法基本思路"><a href="#枚举算法基本思路" class="headerlink" title="枚举算法基本思路"></a>枚举算法基本思路</h4><p><strong>1.确定枚举对象、枚举范围和判定条件</strong></p><p><strong>2.逐一列举可能的解，验证每个解是否是问题的解</strong></p><h4 id="枚举算法基本步骤"><a href="#枚举算法基本步骤" class="headerlink" title="枚举算法基本步骤"></a>枚举算法基本步骤</h4><p><strong>1.题解的可能范围，不能遗漏任何一个真正解，也要避免有重复</strong></p><p><strong>2.判断是否是真正解的方法</strong></p><p><strong>3.使可能解的范围将至最小，以便提高解决问题的效率</strong></p><img src="https://s2.ax1x.com/2019/06/23/ZiCRZq.png" style="zoom:50%"><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><h4 id="百元买百鸡"><a href="#百元买百鸡" class="headerlink" title="百元买百鸡"></a>百元买百鸡</h4><p><strong>公鸡每只5元，母鸡每只3元，小鸡3只1元。用100元买一百只鸡</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> xj;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> gj=<span class="number">0</span>;gj&lt;=<span class="number">20</span>;gj++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> mj=<span class="number">0</span>;mj&lt;=<span class="number">33</span>;mj++)&#123;</span><br><span class="line">            xj=<span class="number">100</span>-gj-mj;</span><br><span class="line">            <span class="keyword">if</span> (xj%<span class="number">3</span>==<span class="number">0</span>&amp;&amp;<span class="number">5</span>*gj+<span class="number">3</span>*mj+xj/<span class="number">3</span>==<span class="number">100</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"公鸡："</span>+gj+<span class="string">",母鸡："</span>+mj+<span class="string">",小鸡："</span>+xj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong><br><img src="https://s2.ax1x.com/2019/06/23/Zi7bvT.png" alt="运行结果"></p><h4 id="填写运算符"><a href="#填写运算符" class="headerlink" title="填写运算符"></a>填写运算符</h4><p><strong>在下面算式中，添加“＋”“－”“×”“÷”4个运算符使等式成立</strong></p><p><strong>5   5   5   5   5 = 5</strong></p><p><strong><font color="f02ff0">‘×’，’÷’运算符优先级高于’+’,’-‘且’÷’后面的数不可以是0</font></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] i=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];        <span class="comment">//表示4个运算符</span></span><br><span class="line">        <span class="keyword">int</span> sign;   <span class="comment">//累加运算时的符号</span></span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">5</span>; <span class="comment">//运算的结果值</span></span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;    <span class="comment">//结果个数</span></span><br><span class="line">        <span class="keyword">int</span> [] num=&#123;<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">char</span> [] oper=&#123;<span class="string">' '</span>,<span class="string">'+'</span>,<span class="string">'-'</span>,<span class="string">'*'</span>,<span class="string">'/'</span>&#125;;</span><br><span class="line">        <span class="keyword">double</span> left,right;</span><br><span class="line">        <span class="keyword">for</span> (i[<span class="number">0</span>]=<span class="number">1</span>;i[<span class="number">0</span>]&lt;=<span class="number">4</span>;i[<span class="number">0</span>]++)&#123;<span class="comment">//循环4种运算符，1+2-3*4/</span></span><br><span class="line">            <span class="keyword">if</span> (i[<span class="number">0</span>]&lt;<span class="number">4</span>||(num[<span class="number">1</span>]!=<span class="number">0</span>))&#123;<span class="comment">//若运算符为/，下一个数值不能为0</span></span><br><span class="line">                <span class="keyword">for</span> (i[<span class="number">1</span>]=<span class="number">1</span>;i[<span class="number">1</span>]&lt;=<span class="number">4</span>;i[<span class="number">1</span>]++)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (i[<span class="number">1</span>]&lt;<span class="number">4</span>||num[<span class="number">2</span>]!=<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">for</span> (i[<span class="number">2</span>]=<span class="number">1</span>;i[<span class="number">2</span>]&lt;=<span class="number">4</span>;i[<span class="number">2</span>]++)&#123;</span><br><span class="line">                            <span class="keyword">if</span> (i[<span class="number">2</span>]&lt;<span class="number">4</span>||num[<span class="number">3</span>]!=<span class="number">0</span>)&#123;</span><br><span class="line">                                <span class="keyword">for</span> (i[<span class="number">3</span>]=<span class="number">1</span>;i[<span class="number">3</span>]&lt;=<span class="number">4</span>;i[<span class="number">3</span>]++)&#123;</span><br><span class="line">                                    <span class="keyword">if</span> (i[<span class="number">3</span>]&lt;<span class="number">4</span>||num[<span class="number">4</span>]!=<span class="number">0</span>)&#123;</span><br><span class="line">                                        left=<span class="number">0</span>;</span><br><span class="line">                                        right=num[<span class="number">0</span>];</span><br><span class="line">                                        sign=<span class="number">1</span>;</span><br><span class="line">                                        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line">                                            <span class="keyword">switch</span> (oper[i[j]])&#123;</span><br><span class="line">                                                <span class="keyword">case</span> <span class="string">'+'</span>:left=left+sign*right;</span><br><span class="line">                                                sign=<span class="number">1</span>;</span><br><span class="line">                                                right=num[j+<span class="number">1</span>];</span><br><span class="line">                                                <span class="keyword">break</span>;</span><br><span class="line">                                                <span class="keyword">case</span> <span class="string">'-'</span>:left=left+sign*right;</span><br><span class="line">                                                sign=-<span class="number">1</span>;</span><br><span class="line">                                                right=num[j+<span class="number">1</span>];</span><br><span class="line">                                                <span class="keyword">break</span>;</span><br><span class="line">                                                <span class="keyword">case</span> <span class="string">'*'</span>:right=right*num[j+<span class="number">1</span>];</span><br><span class="line">                                                <span class="keyword">break</span>;</span><br><span class="line">                                                <span class="keyword">case</span> <span class="string">'/'</span>:right=right/num[j+<span class="number">1</span>];</span><br><span class="line">                                                <span class="keyword">break</span>;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        <span class="keyword">if</span> (left+sign*right==result)&#123;</span><br><span class="line">                                            count++;</span><br><span class="line">                                            System.out.print(count+<span class="string">":"</span>);</span><br><span class="line">                                            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line">                                                System.out.print(num[j]+<span class="string">""</span>+oper[i[j]]);</span><br><span class="line">                                            &#125;</span><br><span class="line">                                            System.out.print(num[<span class="number">4</span>]+<span class="string">"="</span>+result+<span class="string">" "</span>);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong><br><img src="https://s2.ax1x.com/2019/06/23/ZFmIoQ.png" alt="运行结果"></p><h2 id="递推算法"><a href="#递推算法" class="headerlink" title="递推算法"></a>递推算法</h2><h3 id="递推算法基础"><a href="#递推算法基础" class="headerlink" title="递推算法基础"></a>递推算法基础</h3><p><strong>递推算法可以不断利用已有信息推导出新的东西</strong></p><p><strong><font color="f0500">顺推法</font>：从已知条件出发，逐步推算出要解决问题的方法</strong><br><strong><font color="f0500">逆推法</font>：从已知结果出发，用迭代表达式逐步推算出问题开始的条件，即顺推法的逆过程</strong></p><h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><h4 id="顺推法——裴波那契数列"><a href="#顺推法——裴波那契数列" class="headerlink" title="顺推法——裴波那契数列"></a>顺推法——裴波那契数列</h4><p><strong>兔子在出生两个月以后就有繁殖能力，一对兔子每月能生出一对兔子，如果所有兔子都不死，一年后有多少兔子</strong></p><h5 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h5><ul><li><strong>第一个月兔子没有繁殖能力，所以还是一对</strong></li><li><strong>二个月后，一对小兔子生出一对新兔子，所以是两对</strong></li><li><strong>第三个月后老兔子又生下一对，小兔子还没有繁殖能力，所有有三对</strong></li></ul><table><thead><tr><th>月数：</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>…</th></tr></thead><tbody><tr><td><strong>对数：</strong></td><td>1</td><td>1</td><td>2</td><td>3</td><td>5</td><td>8</td><td>13</td><td>21</td><td>…</td></tr></tbody></table><p><strong>得出特征：<font color="blue">前面相邻两项之和等于后一项</font></strong></p><p><strong>由此可知n个月的兔子总数为：<font color="f0500">Fn=Fn-2+Fn-1</font></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] fib=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">13</span>];</span><br><span class="line">        fib[<span class="number">0</span>]=fib[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;fib.length;i++)&#123;</span><br><span class="line">            fib[i]=fib[i-<span class="number">1</span>]+fib[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;fib.length;i++)&#123;</span><br><span class="line">            System.out.print(i+<span class="number">1</span>+<span class="string">"月："</span>+fib[i]+<span class="string">"个兔子   "</span>);</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong><br><img src="https://s2.ax1x.com/2019/06/23/ZF8SRe.png" alt="运行结果"></p><h4 id="逆推法——银行存款问题"><a href="#逆推法——银行存款问题" class="headerlink" title="逆推法——银行存款问题"></a>逆推法——银行存款问题</h4><p><strong>母亲为儿子4年大学生活准备了一笔存款，方式是整存零取，规定儿子每月月底取下一个月生活费，现假设银行年利率为1.71%，计算母亲最少要存入多少钱</strong></p><h5 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h5><p><strong>因为按月取钱，所以需要将4年分为48个月</strong></p><p><strong>如果48月后，儿子大学毕业时连本带利要取1000，则要先求出第47个月时银行存款的钱数</strong></p><p><strong>47月末=1000/(1+0.0171/12)</strong></p><p><strong>46月末=(47月末+1000)/(1+0.171/12)</strong></p><p><strong>45月末=(46月末+1000)/(1+0.171/12)</strong></p><p><strong>44月末=(45月末+1000)/(1+0.171/12)</strong></p><p><strong>43月末=(44月末+1000)/(1+0.171/12)</strong></p><p><strong>……</strong></p><p><strong>2月末=(3月末+1000)/(1+0.171/12)</strong></p><p><strong>1月末=(2月末+1000)/(1+0.171/12)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> [] corpus=<span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">48</span>];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    corpus[<span class="number">47</span>]=<span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">double</span> rate=<span class="number">0.0171</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">46</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        corpus[i]=(corpus[i+<span class="number">1</span>]+<span class="number">1000</span>)/(<span class="number">1</span>+rate/<span class="number">12</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"需存储："</span>+corpus[<span class="number">0</span>]+<span class="string">"元"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong><br><img src="https://s2.ax1x.com/2019/06/23/ZFae7d.png" alt="运行结果"></p><h2 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h2><h3 id="递归算法基础"><a href="#递归算法基础" class="headerlink" title="递归算法基础"></a>递归算法基础</h3><p><strong>在计算机编程中，递归算法对解决大多数问题是十分有效的，它能使算法的描述变得简洁而且易于理解</strong></p><h4 id="递归算法的特点"><a href="#递归算法的特点" class="headerlink" title="递归算法的特点"></a>递归算法的特点</h4><p><strong>1.递归过程一般通过函数或子过程来实现</strong></p><p><strong>2.递归算法在函数或子过程的内部，直接或间接的调用自身</strong></p><p><strong>3.递归算法实际上是把问题转化为小规模的同类问题，然后再递归调用函数或过程来表示问题的解</strong></p><h4 id="使用递归的注意事项"><a href="#使用递归的注意事项" class="headerlink" title="使用递归的注意事项"></a>使用递归的注意事项</h4><p><strong>1.递归是在过程或函数中调用自身的过程</strong></p><p><strong>2.在使用递归时，必须有一个明确的结束条件（递归出口）</strong></p><p><strong>3.递归算法通常显得很简洁，但运行效率很低，所以一般不提倡用递归算法设计程序</strong></p><p><strong>4.在递归调用过程中，系统用栈来存储每一层的返回点和局部变量。如果递归次数过多，则会造成栈溢出，所以一般不提倡使用递归算法设计程序</strong></p><h3 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h3><h4 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h4><p><strong>详解（<a href="https://www.cnblogs.com/vsky/p/5014657.html/" target="_blank" rel="noopener">https://www.cnblogs.com/vsky/p/5014657.html/</a> ）（<a href="https://blog.csdn.net/qq_37873310/article/details/80461767" target="_blank" rel="noopener">https://blog.csdn.net/qq_37873310/article/details/80461767</a> ）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> n, String x, String y, String z)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">""</span>+x+z);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            move(n-<span class="number">1</span>,x,z,y);</span><br><span class="line">            <span class="comment">//System.out.println(""+x+z);</span></span><br><span class="line">            move(n-<span class="number">1</span>, y,x ,z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h4><p><strong>自然数由1~n的n个数连乘积叫做n的阶乘，记作n！</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JieCheng</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">6</span>;</span><br><span class="line">        <span class="keyword">long</span> n=fact(i);</span><br><span class="line">        System.out.println(i+<span class="string">"的阶乘是："</span>+n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fact</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> n*fact(n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong><br><img src="https://s2.ax1x.com/2019/06/24/ZkAK8P.png" alt="运行结果"><br><strong>调用过程</strong><br><img src="https://s2.ax1x.com/2019/06/24/ZkkfBQ.png" style="zoom:70%"></p><h2 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h2><p><strong>分治算法也采取了各个击破的方法，将一个规模为N的问题分解成K个规模较小的子问题，这些子问题相互独立且与原问题性质相同，只要求出子问题的解，就可得到原问题的解</strong></p><h3 id="分治算法基础"><a href="#分治算法基础" class="headerlink" title="分治算法基础"></a>分治算法基础</h3><h4 id="分治算法基本步骤"><a href="#分治算法基本步骤" class="headerlink" title="分治算法基本步骤"></a>分治算法基本步骤</h4><p><strong>1.分解，将要解决的问题划分为若干个规模较小的同类问题</strong></p><p><strong>2.求解，当子问题划分的足够小时，用较简单的方法求解</strong></p><p><strong>3.合并，按原问题要求将子问题的解逐层合并构成原问题的解</strong></p><h3 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h3><h4 id="大数相乘"><a href="#大数相乘" class="headerlink" title="大数相乘"></a>大数相乘</h4><p><strong>问题详解（<a href="https://blog.csdn.net/u011446177/article/details/52894191/" target="_blank" rel="noopener">https://blog.csdn.net/u011446177/article/details/52894191/</a> ）</strong></p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">"2345678900987766655554444455"</span>;</span><br><span class="line">        String str2 = <span class="string">"34658743659843759437594387593875"</span>;</span><br><span class="line">        <span class="keyword">int</span> len1 = str1.length();</span><br><span class="line">        <span class="keyword">int</span> len2 = str2.length();</span><br><span class="line">        <span class="keyword">char</span>[] s1 = str1.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] s2 = str2.toCharArray();</span><br><span class="line">        <span class="comment">// 高低位对调</span></span><br><span class="line">        covertdata(s1, len1);</span><br><span class="line">        covertdata(s2, len2);</span><br><span class="line">        System.out.println(<span class="string">"乘数："</span>+str1);</span><br><span class="line">        System.out.println(<span class="string">"乘数："</span>+str2);</span><br><span class="line">        multiply(s1, len1, s2, len2); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">covertdata</span><span class="params">(<span class="keyword">char</span> data[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//高低位对调</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            data[i] += data[len - <span class="number">1</span> - i];</span><br><span class="line">            data[len - <span class="number">1</span> - i] = (<span class="keyword">char</span>) (data[i] - data[len - <span class="number">1</span> - i]);</span><br><span class="line">            data[i] = (<span class="keyword">char</span>) (data[i] - data[len - <span class="number">1</span> - i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">multiply</span><span class="params">(<span class="keyword">char</span> a[], <span class="keyword">int</span> alen, <span class="keyword">char</span> b[], <span class="keyword">int</span> blen)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 两数乘积位数不会超过乘数位数和+ 3位</span></span><br><span class="line">        <span class="keyword">int</span> csize = alen + blen + <span class="number">3</span>;</span><br><span class="line">        <span class="comment">// 开辟乘积数组</span></span><br><span class="line">        <span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[csize];</span><br><span class="line">        <span class="comment">// 乘积数组填充0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ii = <span class="number">0</span>; ii &lt; csize; ii++) &#123;</span><br><span class="line">            c[ii] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对齐逐位相乘</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; blen; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; alen; i++) &#123;</span><br><span class="line">                c[i + j] +=  Integer.parseInt(String.valueOf(a[i]))* Integer.parseInt(String.valueOf(b[j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 进位处理</span></span><br><span class="line">        <span class="keyword">for</span> (m = <span class="number">0</span>; m &lt; csize; m++) &#123;</span><br><span class="line">            <span class="keyword">int</span> carry = c[m] / <span class="number">10</span>;</span><br><span class="line">            c[m] = c[m] % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                c[m + <span class="number">1</span>] += carry;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到最高位</span></span><br><span class="line">        <span class="keyword">for</span> (m = csize - <span class="number">1</span>; m &gt;= <span class="number">0</span>;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c[m] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            m--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 由最高位开始打印乘积</span></span><br><span class="line">        System.out.print(<span class="string">"乘积："</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt;= m; n++) &#123;</span><br><span class="line">            System.out.print(c[m - n]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="欧洲冠军杯比赛"><a href="#欧洲冠军杯比赛" class="headerlink" title="欧洲冠军杯比赛"></a>欧洲冠军杯比赛</h4><p><strong>欧洲冠军杯初赛阶段采用循环制，设共有n队参加，初赛共进行n-1天，每队都要和其他各队进行一场比赛，然后按照最后积分选拔进入决赛的球队。要求每队每天只能进行一场比赛，并且不能轮空。</strong></p><h5 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h5><p><strong>根据分治算法思路，将所有参赛队伍分为两半，则n队比赛日程表可以通过n/2个队的比赛日程来决定，然后继续划分，直到只剩下最后2队为止。</strong></p><h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><p><strong>转自(<a href="https://www.jianshu.com/p/2089e19e7f99/" target="_blank" rel="noopener">https://www.jianshu.com/p/2089e19e7f99/</a> )</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 循环赛日程表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ranksNumber</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">raceSchedule</span><span class="params">(<span class="keyword">int</span> ranksNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ranksNumber &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"无需安排"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] resultArray = <span class="keyword">new</span> <span class="keyword">int</span>[ranksNumber][ranksNumber];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> counter = <span class="number">0</span>;counter &lt; ranksNumber;counter++) &#123;</span><br><span class="line">            resultArray[counter][<span class="number">0</span>] = counter + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> counter1 = <span class="number">1</span>;counter1 &lt; ranksNumber;counter1++) &#123;</span><br><span class="line">                resultArray[counter][counter1] = resultArray[counter][counter1 - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (resultArray[counter][counter1] &gt; ranksNumber)resultArray[counter][counter1] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> counter = <span class="number">0</span>;counter &lt; ranksNumber;counter++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (counter == <span class="number">0</span>)System.out.print(<span class="string">"No.\t"</span>);</span><br><span class="line">            <span class="keyword">else</span> System.out.print(<span class="string">"D"</span> + counter + <span class="string">"\t"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> counter = <span class="number">0</span>;counter &lt; ranksNumber;counter++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> counter1 = <span class="number">0</span>;counter1 &lt; ranksNumber;counter1++) &#123;</span><br><span class="line">                System.out.print(resultArray[counter][counter1] + <span class="string">"\t"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 本算法采用分治策略来解决。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ranksNumber</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">raceSchedule0</span><span class="params">(<span class="keyword">int</span> ranksNumber)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断它是不是2的次幂，并且它还必须至少是2.</span></span><br><span class="line">        <span class="keyword">if</span> (!isPowerOfTwo(ranksNumber) || ranksNumber &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"输入错误"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] scheduleArray = <span class="keyword">new</span> <span class="keyword">int</span>[ranksNumber][ranksNumber];</span><br><span class="line">        Solution.dAndC(scheduleArray,<span class="number">1</span>,ranksNumber,ranksNumber);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> counter = <span class="number">0</span>;counter &lt; ranksNumber;counter++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (counter == <span class="number">0</span>)System.out.print(<span class="string">"No.\t"</span>);</span><br><span class="line">            <span class="keyword">else</span> System.out.print(<span class="string">"D"</span> + counter + <span class="string">"\t"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> counter = <span class="number">0</span>;counter &lt; ranksNumber;counter++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> counter1 = <span class="number">0</span>;counter1 &lt; ranksNumber;counter1++) &#123;</span><br><span class="line">                System.out.print(scheduleArray[counter][counter1] + <span class="string">"\t"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分治策略的迭代部分</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> scheduleArray</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> number</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ranksNumber</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dAndC</span><span class="params">(<span class="keyword">int</span>[][] scheduleArray,<span class="keyword">int</span> number,<span class="keyword">int</span> length,<span class="keyword">int</span> ranksNumber)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果就2个队伍就很简单了，就是2个斜方向的问题了。</span></span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">2</span>) &#123;</span><br><span class="line">            scheduleArray[number - <span class="number">1</span>][<span class="number">0</span>] = number;</span><br><span class="line">            scheduleArray[number][<span class="number">1</span>] = number;</span><br><span class="line">            scheduleArray[number - <span class="number">1</span>][<span class="number">1</span>] = number + <span class="number">1</span>;</span><br><span class="line">            scheduleArray[number][<span class="number">0</span>] = number + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> halfLength = length / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//迭代处理左上角方阵。</span></span><br><span class="line">            Solution.dAndC(scheduleArray,number,halfLength,ranksNumber);</span><br><span class="line">            Solution.printMatrix(scheduleArray,ranksNumber);</span><br><span class="line">            <span class="comment">//迭代处理左下角方阵。</span></span><br><span class="line">            Solution.dAndC(scheduleArray,number + halfLength,halfLength,ranksNumber);</span><br><span class="line">            Solution.printMatrix(scheduleArray,ranksNumber);</span><br><span class="line">            <span class="comment">//接下来把左下的方阵复制到右上角的方阵去</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> counter = number - <span class="number">1</span>;counter &lt; number - <span class="number">1</span> + halfLength;counter++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> counter0 = halfLength;counter0 &lt; length;counter0++)</span><br><span class="line">                    scheduleArray[counter][counter0] = scheduleArray[counter + halfLength][counter0 - halfLength];</span><br><span class="line">            Solution.printMatrix(scheduleArray,ranksNumber);</span><br><span class="line">            <span class="comment">//接下来把左上的方阵复制到右下角的方阵去</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> counter = number - <span class="number">1</span> + halfLength;counter &lt; number - <span class="number">1</span> + length;counter++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> counter0 = halfLength;counter0 &lt; length;counter0++)</span><br><span class="line">                    scheduleArray[counter][counter0] = scheduleArray[counter - halfLength][counter0 - halfLength];</span><br><span class="line">            Solution.printMatrix(scheduleArray,ranksNumber);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印矩阵</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> scheduleArray</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rank</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span>[][] scheduleArray,<span class="keyword">int</span> rank)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> counter = <span class="number">0</span>;counter &lt; rank;counter++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> counter1 = <span class="number">0</span>;counter1 &lt; rank;counter1++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (scheduleArray[counter][counter1] == <span class="number">0</span>)System.out.print(<span class="string">"  "</span>);</span><br><span class="line">                <span class="keyword">else</span> System.out.print(scheduleArray[counter][counter1] + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断一个数是不是2的幂次</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> number</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> bitFlag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> bitSum = Integer.SIZE - <span class="number">1</span>;<span class="comment">//不算符号位</span></span><br><span class="line">        <span class="keyword">int</span> bitIterator = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> oneCounter = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (bitIterator &lt; bitSum) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((bitFlag &amp; number) != <span class="number">0</span>) &#123;</span><br><span class="line">                oneCounter++;</span><br><span class="line">                <span class="keyword">if</span> (oneCounter &gt; <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            bitFlag = bitFlag &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            bitIterator++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;枚举算法&quot;&gt;&lt;a href=&quot;#枚举算法&quot; class=&quot;headerlink&quot; title=&quot;枚举算法&quot;&gt;&lt;/a&gt;枚举算法&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;枚举算法思想特点是在&lt;font color=&quot;f02ff0&quot;&gt;面对任何问题时它都会去尝试每一种解决方法&lt;/f
      
    
    </summary>
    
      <category term="算法" scheme="https://51461.github.io/blog/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="https://51461.github.io/blog/tags/java/"/>
    
      <category term="算法" scheme="https://51461.github.io/blog/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>java基础知识</title>
    <link href="https://51461.github.io/blog/2019/06/22/java01/"/>
    <id>https://51461.github.io/blog/2019/06/22/java01/</id>
    <published>2019-06-22T09:48:24.000Z</published>
    <updated>2019-06-23T08:34:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="重载与重写的区别"><a href="#重载与重写的区别" class="headerlink" title="重载与重写的区别"></a>重载与重写的区别</h2><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p><strong>重载发生在<font color="red">同一个类中</font>,<font color="red">方法名相同</font>，参数类型，个数，顺序<font color="red">不同</font>返回值和访问修饰符<font color="red">可以不同</font></strong></p><h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p><strong>重写发生在<font color="red">子类中</font>，方法名，参数列表必须<font color="red">相同</font>，返回值范围<font color="red">小于等于</font>父类，抛出异常范围<font color="red">小于等于</font>父类，<font color="red">访问修饰符大于等于父类</font>,如果父类方法修饰符为<font color="blue">private</font>则不可以重写该方法</strong></p><h2 id="String-StringBuffer-StringBuilder的区别，String为什么不可变"><a href="#String-StringBuffer-StringBuilder的区别，String为什么不可变" class="headerlink" title="String,StringBuffer,StringBuilder的区别，String为什么不可变"></a>String,StringBuffer,StringBuilder的区别，String为什么不可变</h2><h3 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a>可变性</h3><p><strong>String类中使用final关键字字符数组保存字符串,<font color="blue">private final char value[]</font>,所以string对象是不可变的,而<font color="red">StringBuffer</font>和<font color="red">StringBuilder</font>都继承<font color="red">AbstractStringBuilder</font>类，在AbstractStringBuilder中也是使用字符数组保存字符串，但是没用<font color="red">final</font>关键字修饰，所以这两种对象都是可变的</strong></p><p><strong>AbstractStringBuilder.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line"><span class="comment">//The value is used for character storage.</span></span><br><span class="line">    <span class="comment">//该值用于字符存储。</span></span><br><span class="line">    <span class="keyword">char</span>[] value;</span><br><span class="line">    <span class="comment">//The count is the number of characters used.</span></span><br><span class="line">    <span class="comment">//使用的字符数。</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="comment">//This no-arg constructor is necessary for serialization of subclasses.</span></span><br><span class="line"><span class="comment">//这个无参数构造函数是子类序列化所必需的。</span></span><br><span class="line">AbstractStringBuilder() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建指定容量的AbstractStringBuilder。</span></span><br><span class="line">AbstractStringBuilder(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h3><p><strong>String中的对象是<font color="red">不可变的</font>，也可以理解为<font color="blue">常量</font>，线程<font color="red">安全</font></strong></p><p><strong><font color="red">AbstractStringBuilder</font>是<font color="blue">StringBuilder</font>和<font color="blue">StringBuffer</font>的<font color="red">公共父类</font>，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexof等公共方法，<font color="red">StringBuffer</font>对方法<font color="red">加了同步锁或对调用的方法加入了同步锁</font>，所以线程是<font color="red">安全的</font>而<font color="red">StringBuilder</font><font color="#ff500">并没有对方法加同步锁</font>，所以线程是<font color="red">不安全的</font></strong></p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p><strong>每次对<font color="red">String</font>类型进行改变的时候，都会<font color="ff500">生成一个新的String对象，然后将指针指向新的String对象</font></strong></p><p><strong><font color="red">StingBuffer</font>每次都会对<font color="ff500">StringBuffer对象本身</font>进行操作，而不是生成新的对象并改变对象引用。相同情况下使用<font color="red">StringBuilder</font>比<font color="red">StringBuffer</font><font color="ff500">性能高10%·15%左右</font>，<font color="f02ff0">但要冒多线程下不安全的风险</font></strong></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p><strong>操作量少的数据<font color="f02ff0">String</font></strong></p></li><li><p><strong>单线程操作字符串缓冲区下操作大量数据<font color="f02ff0">StringBuilder</font></strong></p></li><li><p><strong>多线程操作字符串缓冲区下操作大量数据<font color="f02ff0">StringBuffer</font></strong></p></li></ul><h2 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h2><p><strong>装箱：将<font color="f02ff0">基本类型</font>用他们对应的<font color="f02ff0">引用类型</font>包装起来</strong></p><p><strong>拆箱：将<font color="f02ff0">包装类型</font>转换为<font color="f02ff0">基本类型</font></strong></p><p><strong>注：<font color="f02ff0">基本类型</font>与<font color="f02ff0">引用类型</font>用<font color="red">==</font>判断相等时注意空指针异常(<a href="https://gpdstudy.club/posts/integer-bug/#more" target="_blank" rel="noopener">https://gpdstudy.club/posts/integer-bug/#more</a>)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">Integer b = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span>(a == b) &#123;<span class="comment">//空指针异常 </span></span><br><span class="line">    System.out.println(<span class="keyword">true</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="与equals"><a href="#与equals" class="headerlink" title="==与equals"></a>==与equals</h2><h3 id><a href="#" class="headerlink" title="=="></a>==</h3><p><strong>它的作用是判断两个对象的<font color="f02ff0">地址</font>是否相等，即<font color="f02ff0">判断两个对象是不是同一个对象</font><font color="blue">基本类型比值，引用数据类型比较的是内存地址</font></strong></p><h3 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h3><p><strong>它的也作用是判断两个对象是否相等，但他一般有两种情况</strong></p><ul><li><p><strong><font color="f02ff0">类没有重写equals方法</font>通过equals()比较该类型的两个对象时，等价于<font color="f02ff0">==</font>比较</strong></p></li><li><p><strong><font color="f02ff0">类重写了equals()方法</font>，一般，我们重写equals方法来<font color="f02ff0">比较两个对象的内容相等</font>相等返回true</strong></p></li></ul><p><strong>举个例子</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(string[] args)</span></span>&#123;</span><br><span class="line">        String a=<span class="keyword">new</span> String(<span class="string">"ab"</span>);<span class="comment">//a为一个引用</span></span><br><span class="line">        String b=<span class="keyword">new</span> String(<span class="string">"ab"</span>);<span class="comment">//b为另一个引用，对象内容一样</span></span><br><span class="line">        String c=<span class="string">"ab"</span>;<span class="comment">//放在常量池中</span></span><br><span class="line">        String d=<span class="string">"ab"</span>;<span class="comment">//从常量池中查找</span></span><br><span class="line">        <span class="keyword">if</span>(a==b)<span class="comment">//false</span></span><br><span class="line">        System.out.println(<span class="string">"a==b"</span>)</span><br><span class="line">       <span class="keyword">if</span>(c==d)<span class="comment">//true</span></span><br><span class="line">       System.out.println(<span class="string">"c==d"</span>)</span><br><span class="line">       <span class="keyword">if</span>(<span class="number">42</span>==<span class="number">42.0</span>)<span class="comment">//true</span></span><br><span class="line">       System.out.println(<span class="string">"true"</span>)</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color="f02ff0">String中的equals()方法是被重写过的</font>,因为<font color="f02ff0">Object的equals方法是比较对象的内存地址</font>而<font color="f02ff0">String中的equals()方法比较的是对象的内容</font></strong></p><p><strong>当<font color="f02ff0">创建String类型的对象时</font>，虚拟机会在常量池中查找有没有已存的值和要创建的值相等，如果有就把他给当前对象引用，如果没有就在常量池中重新创建一个String对象</strong></p><h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p><strong>final关键字主要用在三个地方：<font color="red">变量，方法，类</font></strong></p><ul><li><strong>对于一个final变量，如果是<font color="f02ff0">基本数据的类型的变量</font>，则其数值一旦初始化后<font color="red">不能在更改</font>.如果是<font color="f02ff0">引用类型的变量</font>，则在其初始化后便<font color="red">不能再让其指向另一个对象</font></strong></li><li><strong>当用final修饰一个<font color="red*">类</font>时，表示<font color="f02ff0">这个类不能被继承</font>。<font color="ff500">final类中的所有成员方法都会被隐式指定为final方法</font></strong></li><li><strong>用final修饰的方法原因有两个<font color="f02ff0">一是因为把方法锁定，以防任何继承类修改它的含义</font><font color="ff500">二是因为效率</font>早期java实现版本中，会将final方法转为内嵌调用，但如果方法过于庞大，可能看不到内嵌调用带来的性能提升（现在java版本已不需要final方法进行优化）类中所有private方法都隐式指定为final</strong><h2 id="Object类中的常见方法总结"><a href="#Object类中的常见方法总结" class="headerlink" title="Object类中的常见方法总结"></a>Object类中的常见方法总结</h2></li></ul><p><strong><font color="f02ff0">Object是所有类的父类,主要提供了11个方法</font></strong></p><ul><li><p><strong>native方法，用于返回<font color="f02ff0">当前运行时对象的Class对象</font>，使用了final关键字，不允许重写</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br></pre></td></tr></table></figure></li><li><p><strong>native方法，用于返回<font color="f02ff0">对象的哈希码</font>，主要使用在哈希表中（HshMap）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>用于比较两个对象的地址是否相同，string重写改为了比较两个对象的内容</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>native方法，用于创建并返回当前对象的一份拷贝，一般情况下，对于任何对象x，表达式<font color="f02ff0">x.clone()!=x</font>为<font color="f02ff0">true</font>，而<font color="f02ff0">x.clone().getClass()==x.getClass()</font>为<font color="f02ff0">true</font>。Object本身没有实现<font color="f02ff0">Cloneable接口</font>，所以不重写clone方法并调用的话会发生<font color="red">CloneNotSupportedException</font>异常</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>返回类的名字@实例的哈希码的16进制的字符串(建议Object子类都重写这个方法）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>native方法，并且不能重写。<font color="f02ff0">唤醒一个在此对象监视器上等待的线程</font>（监视器相当于就是锁的概念），如果有<font color="f02ff0">多个线程在等待只会随机唤醒一个</font></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>native方法，并且不能重写。与notify方法一样，区别在于<font color="f02ff0">会唤醒在此对象监视器上等待的所有线程，而不是其中一个</font></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>native方法，并且不能重写。<font color="f02ff0">暂停线程的执行</font>,注：<font color="red">sleep方法没有释放锁，而wait释放了锁</font>，timeout是等待时间</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>与上个方法一样，只是<font color="f02ff0">多了nanos参数</font>，这个参数表示<font color="f02ff0">额外时间</font>（以毫秒为单位，0-999999），所以<font color="red*">超时时间还要加上nanos毫秒</font></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                                <span class="string">"nanosecond timeout value out of range"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &gt;= <span class="number">500000</span> || (nanos != <span class="number">0</span> &amp;&amp; timeout == <span class="number">0</span>)) &#123;</span><br><span class="line">        timeout++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wait(timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>和之前两个wait方法一样，只不过该方法<font color="f02ff0">一直等待，没有超时</font></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><font color="red*">实例被垃圾回收器回收时触发的操作</font></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="java中的异常处理"><a href="#java中的异常处理" class="headerlink" title="java中的异常处理"></a>java中的异常处理</h2><p><img src="https://s2.ax1x.com/2019/06/23/ZPivpF.png" alt="java异常类型"><br><strong>在java中，所有的异常都有一个共同的父类<font color="f02ff0">java.lang.Throwable</font>,Throwable有两个子类<font color="red">Exception(异常)</font>和<font color="ff500">Error(错误)</font>两者都是异常处理的重要子类，各自都包含大量子类</strong></p><h3 id="Error-错误"><a href="#Error-错误" class="headerlink" title="Error(错误)"></a>Error(错误)</h3><p>**<font color="red">Error(错误)是程序无法处理的错误</font>，<font color="f02ff0">表示运行程序中较严重的问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时JVM出现的问题</font></p><ul><li><strong>java虚拟机运行错误(Virtual MachineError)</strong></li><li><strong>类定义错误(NoClassDefFoundError)</strong></li><li>……</li></ul><h3 id="Exception-异常"><a href="#Exception-异常" class="headerlink" title="Exception(异常)"></a>Exception(异常)</h3><p><strong><font color="red">Exception(异常)是程序本身可以处理的异常</font>Exception有一个重要的子类<font color="f02ff0">RuntimeException</font>。RuntimeExceptioon由java虚拟机抛出</strong></p><ul><li><strong>NullPointerException，要访问的变量没有任何对象引用时，抛出该异常</strong></li><li><strong>ArithmeticException，算术运算异常，整数除0时抛出</strong></li><li><strong>ArrayIndexOutOfBoundsException,下标越界异常</strong></li></ul><p><strong><font color="blue">注：异常和错误的区别在于异常能被程序本身处理，而错误不可以</font></strong></p><h3 id="Throwable类常用方法"><a href="#Throwable类常用方法" class="headerlink" title="Throwable类常用方法"></a>Throwable类常用方法</h3><ul><li><p><strong><font color="f02ff0">getMessage()</font>：返回异常发生时的详细信息</strong></p></li><li><p><strong><font color="f02ff0">toString()</font>：返回异常发生时的简要描述</strong></p></li><li><p><strong><font color="f02ff0">getLocalizedMessage()</font>：返回异常对象的本地化信息。使用Throwable子类重写这个方法可以声称本地化信息，如果子类没有重写该方法，则返回与getMessage()结果相同</strong></p></li><li><p><strong><font color="f02ff0">printStackTrace()</font>：在控制台打印Throwable对象封装的异常信息</strong></p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3></li><li><p><strong><font color="f02ff0">try块</font>：用于捕捉异常，其后可接零或多个catch块，如果没有catch块则必须跟一个finally块</strong></p></li><li><p><strong><font color="f02ff0">catch块</font>：用于处理try捕捉到的异常</strong></p></li><li><p><strong><font color="f02ff0">finally块</font>：无论是否捕捉到异常都会执行<font color="f002ff0">当在try或catch中遇到return语句时，finally语句在返回前执行</font></strong></p><h4 id="finally不会执行的条件"><a href="#finally不会执行的条件" class="headerlink" title="finally不会执行的条件"></a>finally不会执行的条件</h4></li><li><p><strong>finally中发生了异常</strong></p></li><li><p><strong>在finally前用System.exit()退出程序</strong></p></li><li><p><strong>程序所在线程死亡</strong></p></li><li><p><strong>关闭CPU</strong></p><h2 id="获取键盘输入"><a href="#获取键盘输入" class="headerlink" title="获取键盘输入"></a>获取键盘输入</h2></li></ul><p><strong>通过<font color="f02ff0">Scanner</font></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String s = input.nextLine();</span><br><span class="line">input.close();</span><br></pre></td></tr></table></figure><p><strong>通过<font color="f02ff0">BufferedReader</font></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader input =<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">String s = input.readLine();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口与抽象类的区别"><a href="#接口与抽象类的区别" class="headerlink" title="接口与抽象类的区别"></a>接口与抽象类的区别</h2><ul><li><strong>接口方法默认public，所有方法在接口中不能有实现<font color="f02ff0">在java8开始接口方法可以有默认实现</font>抽象类可以有非抽象方法</strong></li><li><strong>接口中的实例变量默认是final类型的而抽象类不一定</strong></li><li><strong>一个类可以实现多个接口，但只能实现一个抽象类</strong></li><li><strong>接口不能被new实例化，但可以声明，但是必须引用一个实现该接口的对象，从设计层来说，<font color="f02ff0">抽象是对类的抽象，是一种模板设计，接口是行为的接口，是一种行为规范</font></strong></li></ul><p><strong><font color="f02ff0">jdk8中，接口也可以定义静态方法，可以直接用接口名调用。实现类和实现是不可以调用的。如果同时实现了两个接口，接口定义了一样的默认方法，必须重写，不然会报错</font>（<a href="https://github.com/Snailclimb/JavaGuide/issues/146/" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide/issues/146/</a> ）</strong></p><h2 id="java集合"><a href="#java集合" class="headerlink" title="java集合"></a>java集合</h2><h3 id="ArrayList与LinkedList异同"><a href="#ArrayList与LinkedList异同" class="headerlink" title="ArrayList与LinkedList异同"></a>ArrayList与LinkedList异同</h3><ul><li><strong>线程安全</strong></li></ul><p><strong>ArrayList和LinkedList都是不同步的，线程不保证安全</strong></p><ul><li><strong>底层数据结构</strong></li></ul><p><strong>ArrayList底层是Object数组，LinkedList底层使用的是双向链表数据结构（1.6之前是循环链表，1.7取消了循环）</strong></p><ul><li><strong>插入和删除是否受元素位置的影响</strong></li></ul><p><strong><font color="f02ff0">ArrayList采用数组存储，所以插入和删除元素的时间复杂度受元素的位置影响</font>，比如：执行<code>add(E e)</code>方法的时候，ArrayList会默认将指定元素追加到末尾，这种情况下时间复杂度为O(1),但如果是在指定位置i插入和删除元素<code>add(int index E e)</code>时时间复杂度为O(n-i)。因为在执行此方法时集合中的第i个元素个i之后(n-i)个元素都要执行向后/前位移一位的操作<font color="f02f0">LinkedList采用链表存储，所以插入删除元素时间复杂度不受元素位置影响，都是近似O(1)，而数组为近似O(n)</font></strong></p><ul><li><strong>是否支持快速随机访问</strong></li></ul><p><strong>LinkedList不支持高效的随机元素访问，而ArrayList支持<code>get(int index)</code></strong></p><ul><li><strong>内存空间占用</strong></li></ul><p><strong>ArrayList空间浪费在list列表结尾会预留一定的容量空间，而LinkedList空间花费在每一个元素，每个元素消耗的空间都比ArrayList更多，因为LinkendList要存放直接后继和直接前驱以及数据</strong></p><ul><li><strong>list的遍历</strong></li></ul><p><strong>实现了<font color="f02ff0">RandomAccess</font>接口的list，优先使用for循环，其次foreach</strong><br><strong>未实现<font color="f02ff0">RandomAccess</font>接口的list，优先选择iterator遍历（foreach底层也是有iterator实现的）大size的数据不要使用普通for循环</strong></p><h3 id="ArrayList和Vector"><a href="#ArrayList和Vector" class="headerlink" title="ArrayList和Vector"></a>ArrayList和Vector</h3><p><strong>Vector类所有方法都是<font color="f02ff0">同步的</font>。可以由两个线程安全的访问一个Vector对象，但一个线程访问Vector的话代码要在同步操作上耗费大量的时间</strong></p><p><strong>ArrayList不是同步的，在不需要保证线程安全的时候建议使用</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;重载与重写的区别&quot;&gt;&lt;a href=&quot;#重载与重写的区别&quot; class=&quot;headerlink&quot; title=&quot;重载与重写的区别&quot;&gt;&lt;/a&gt;重载与重写的区别&lt;/h2&gt;&lt;h3 id=&quot;重载&quot;&gt;&lt;a href=&quot;#重载&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="java" scheme="https://51461.github.io/blog/categories/java/"/>
    
    
      <category term="java" scheme="https://51461.github.io/blog/tags/java/"/>
    
      <category term="基础" scheme="https://51461.github.io/blog/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>学go第三天</title>
    <link href="https://51461.github.io/blog/2019/06/18/go3/"/>
    <id>https://51461.github.io/blog/2019/06/18/go3/</id>
    <published>2019-06-18T04:32:13.000Z</published>
    <updated>2019-06-19T00:30:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><p><strong>if后条件判断语句没有()</strong><br><strong>if后面条件成立则执行{}里程序，不成立则跳过</strong></p><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p><strong>运行实例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> =<span class="number">3</span></span><br><span class="line"><span class="keyword">if</span> a==<span class="number">3</span> &#123;<span class="comment">//条件判断语句没有()</span></span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果:</strong><br><code>3</code></p><h3 id="if…else…"><a href="#if…else…" class="headerlink" title="if…else…"></a>if…else…</h3><p><strong>if后条件不成立则执行else{}里语句</strong><br><strong>运行实例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> =<span class="number">3</span></span><br><span class="line"><span class="keyword">if</span> a&gt;<span class="number">3</span> &#123;<span class="comment">//条件判断语句没有()</span></span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"a不大于3"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果:</strong><br><code>a不大于3</code></p><h3 id="if…else-if…else…"><a href="#if…else-if…else…" class="headerlink" title="if…else if…else…"></a>if…else if…else…</h3><p><strong>第一个if不成立则判断第二个，直到所有if不成立执行else{}里程序，如果有一个if条件成立，则执行其{}内语句并跳出判断</strong><br><strong>运行实例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> =<span class="number">3</span></span><br><span class="line"><span class="keyword">if</span> a == <span class="number">1</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"a==1"</span>)</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> a == <span class="number">2</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"a==2"</span>)</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> a == <span class="number">3</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"a==3"</span>)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"a&gt;=3"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果:</strong><br><code>a==3</code></p><h2 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h2><p><strong>switch后写的是变量本身，不是判断条件,变量与case等式都不成立则执行default，go语言保留了break关键字,默认情况下不写，默认包含</strong></p><hr><p><strong>运行实例:</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">num:=<span class="number">3</span></span><br><span class="line"><span class="keyword">switch</span> num &#123;<span class="comment">//switch后写的是变量本身，不是判断条件</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">fmt.Println(<span class="string">"按下的是"</span>,num,<span class="string">"楼"</span>)</span><br><span class="line"><span class="comment">//break//go语言保留了break关键字,默认不写，默认包含</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">fmt.Println(<span class="string">"按下的是"</span>,num,<span class="string">"楼"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">fmt.Println(<span class="string">"按下的是"</span>,num,<span class="string">"楼"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">fmt.Println(<span class="string">"按下的是"</span>,num,<span class="string">"楼"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"按下的是"</span>,num,<span class="string">"楼"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果:</strong><br><code>按下的是 3 楼</code></p><h3 id="fallthrough关键字"><a href="#fallthrough关键字" class="headerlink" title="fallthrough关键字"></a>fallthrough关键字</h3><p><strong>fallthrough表示不跳出switch循环,后面条件无条件执行</strong><br><strong>运行实例:</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">num:=<span class="number">3</span></span><br><span class="line"><span class="keyword">switch</span> num &#123;<span class="comment">//switch后写的是变量本身，不是判断条件</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">fmt.Println(<span class="string">"按下的是"</span>,num,<span class="string">"楼"</span>)</span><br><span class="line"><span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">fmt.Println(<span class="string">"按下的是"</span>,num,<span class="string">"楼"</span>)</span><br><span class="line"><span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">fmt.Println(<span class="string">"按下的是"</span>,num,<span class="string">"楼"</span>)</span><br><span class="line"><span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">fmt.Println(<span class="string">"按下的是"</span>,num,<span class="string">"楼"</span>)</span><br><span class="line"><span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"按下的是"</span>,num,<span class="string">"楼"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果:</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">按下的是 <span class="number">3</span> 楼</span><br><span class="line">按下的是 <span class="number">3</span> 楼</span><br><span class="line">按下的是 <span class="number">3</span> 楼</span><br></pre></td></tr></table></figure><h3 id="switch语句其他用法"><a href="#switch语句其他用法" class="headerlink" title="switch语句其他用法"></a>switch语句其他用法</h3><p><strong>switch语句支持一个初始化语句,初始化语句和变量本身以分号分割</strong><br><strong>运行实例:</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="comment">//switch语句支持一个初始化语句,初始化语句和变量本身以分号分割</span></span><br><span class="line"><span class="keyword">switch</span> num := <span class="number">3</span>;num &#123;<span class="comment">//switch后写的是变量本身，不是判断条件</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">fmt.Println(<span class="string">"按下的是"</span>,num,<span class="string">"楼"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">fmt.Println(<span class="string">"按下的是"</span>,num,<span class="string">"楼"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">fmt.Println(<span class="string">"按下的是"</span>,num,<span class="string">"楼"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">fmt.Println(<span class="string">"按下的是"</span>,num,<span class="string">"楼"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"按下的是"</span>,num,<span class="string">"楼"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果:</strong><br><code>按下的是 3 楼</code><br><strong>switch后可以没有变量,case后面可以加判断语句</strong><br><strong>运行实例:</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">s :=<span class="number">88</span></span><br><span class="line"><span class="keyword">switch</span>  &#123;<span class="comment">//可以没有条件</span></span><br><span class="line"><span class="keyword">case</span> s &gt; <span class="number">90</span>:</span><br><span class="line">fmt.Println(<span class="string">"优秀"</span>)</span><br><span class="line"><span class="keyword">case</span> s &gt; <span class="number">80</span>:</span><br><span class="line">fmt.Println(<span class="string">"良好"</span>)</span><br><span class="line"><span class="keyword">case</span> s &gt; <span class="number">70</span>:</span><br><span class="line">fmt.Println(<span class="string">"一般"</span>)</span><br><span class="line"><span class="keyword">case</span> s &gt; <span class="number">60</span>:</span><br><span class="line">fmt.Println(<span class="string">"较差"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"差"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果:</strong><br><code>良好</code><br><strong>switch语句case后可以加多个常量</strong><br><strong>运行实例:</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="keyword">switch</span> num := <span class="number">3</span>;num &#123;<span class="comment">//switch后写的是变量本身，不是判断条件</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">fmt.Println(<span class="string">"按下的是"</span>,num,<span class="string">"楼"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">fmt.Println(<span class="string">"按下的是"</span>,num,<span class="string">"楼"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>:<span class="comment">//num=3|num=4|num=5时执行</span></span><br><span class="line">fmt.Println(<span class="string">"按下的是"</span>,num,<span class="string">"楼"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"按下的是"</span>,num,<span class="string">"楼"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果:</strong><br><code>按下的是 3 楼</code></p><h2 id="for循环语句"><a href="#for循环语句" class="headerlink" title="for循环语句"></a>for循环语句</h2><ul><li><strong>语法</strong><br>  <strong>for 初始化条件;判断条件;条件变化{}</strong></li></ul><p><strong>判断条件是否为真，如果为真执行循环体，如果为假跳出循环,如果不写判断条件则陷入死循环</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">sum:=<span class="number">0</span></span><br><span class="line"><span class="comment">//判断条件是否为真,如果为真执行循环体,如果为假跳出循环</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++ &#123;</span><br><span class="line">sum=sum+i</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="range迭代器"><a href="#range迭代器" class="headerlink" title="range迭代器"></a>range迭代器</h2><p><strong>迭代打印每个元素,默认返回两个值:一个元素位置，一个元素本身</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">str :=<span class="string">"abc"</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(str); i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%d,%c\n"</span>,i,str[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代打印每个元素,默认返回两个值:一个元素位置，一个元素本身</span></span><br><span class="line"><span class="keyword">for</span> i,data:=<span class="keyword">range</span> str&#123;</span><br><span class="line">fmt.Println(i,data)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果:</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>,a</span><br><span class="line"><span class="number">1</span>,b</span><br><span class="line"><span class="number">2</span>,c</span><br><span class="line"><span class="number">0</span> <span class="number">97</span></span><br><span class="line"><span class="number">1</span> <span class="number">98</span></span><br><span class="line"><span class="number">2</span> <span class="number">99</span></span><br></pre></td></tr></table></figure><p><strong>其他用法</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i :=<span class="keyword">range</span> str &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%d,%c"</span>,i,str[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i,_ :=<span class="keyword">range</span> str &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%d,%c"</span>,i,str[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h2><h3 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h3><p><strong>break可用于for、switch、select，而continue只能用于for循环</strong><br><strong>braek运行实例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"time"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">i:=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">i++</span><br><span class="line">time.Sleep(time.Second)<span class="comment">//休眠一秒</span></span><br><span class="line"><span class="keyword">if</span> i==<span class="number">5</span> &#123;</span><br><span class="line"><span class="keyword">break</span> <span class="comment">//跳出循环，如果嵌套多个循环，跳出最近的那个循环</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>continue运行实例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"time"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">i:=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">i++</span><br><span class="line">time.Sleep(time.Second)<span class="comment">//休眠一秒</span></span><br><span class="line"><span class="keyword">if</span> i==<span class="number">5</span> &#123;</span><br><span class="line"><span class="comment">//break //跳出循环，如果嵌套多个循环，跳出最近的那个循环</span></span><br><span class="line"><span class="keyword">continue</span><span class="comment">//跳过本次循环,下一次继续</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line">……</span><br></pre></td></tr></table></figure><h3 id="goto跳转"><a href="#goto跳转" class="headerlink" title="goto跳转"></a>goto跳转</h3><p><strong>goto可以用在任何地方，但不能夸函数使用，用goto跳转前必须在当前函数内定义标签</strong><br><strong>运行实例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="comment">//goto可以用在任何地方，但不能夸函数使用</span></span><br><span class="line">fmt.Println(<span class="string">"111111111111111111111111111111"</span>)</span><br><span class="line"><span class="keyword">goto</span> end<span class="comment">//goto是关键字，end是用户定义标签的名字</span></span><br><span class="line">fmt.Println(<span class="string">"22222222222222222222222222"</span>)</span><br><span class="line">end:<span class="comment">//定义标签</span></span><br><span class="line">fmt.Println(<span class="string">"33333333333333333333333"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果:</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">111111111111111111111111111111</span></span><br><span class="line"><span class="number">33333333333333333333333</span></span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p><strong>在golang中，函数基本组成为:关键字func、函数名、参数列表、返回值、函数体和返回语句</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span>/*关键字*/ <span class="title">name</span>/*函数名*/<span class="params">(/*参数列表*/)</span><span class="params">(a <span class="keyword">string</span>,b <span class="keyword">int</span>/*返回类型*/)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*函数体*/</span></span><br><span class="line">    <span class="keyword">return</span> v1,v2<span class="comment">//返回语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><p><strong>自定义函数不调用不会执行</strong></p><h3 id="无参无返回值函数"><a href="#无参无返回值函数" class="headerlink" title="无参无返回值函数"></a>无参无返回值函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Myfunc</span><span class="params">()</span></span>  &#123;<span class="comment">//自定义函数</span></span><br><span class="line">fmt.Println(<span class="string">"我是Myfunc函数"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">Myfunc()<span class="comment">//无参无返回值函数的调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果:</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我是Myfunc函数</span><br></pre></td></tr></table></figure><h3 id="有参无返回值函数"><a href="#有参无返回值函数" class="headerlink" title="有参无返回值函数"></a>有参无返回值函数</h3><h4 id="普通参数"><a href="#普通参数" class="headerlink" title="普通参数"></a>普通参数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    <span class="comment">//调用函数传递的参数叫实参</span></span><br><span class="line">youcan(<span class="number">10</span>,<span class="number">10</span>)<span class="comment">//调用函数</span></span><br><span class="line">    youcan2(<span class="number">10</span>,<span class="string">"abc"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义函数时，在（）内定义的参数是形参</span></span><br><span class="line"><span class="comment">//参数传递只能由实参传给形参</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">youcan</span><span class="params">(a,b <span class="keyword">int</span>)</span></span>&#123;<span class="comment">//定义有参无返回值函数</span></span><br><span class="line">fmt.Println(a,b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">youcan2</span><span class="params">(a <span class="keyword">int</span>,b <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">fmt.Println(a,b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">10</span></span><br><span class="line"><span class="number">10</span> abc</span><br></pre></td></tr></table></figure><h4 id="不定参数"><a href="#不定参数" class="headerlink" title="不定参数"></a>不定参数</h4><p><strong>不定参数是指函数传入的参数个数为不定数量</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">Myfunc(<span class="number">100</span>,<span class="number">200</span>)</span><br><span class="line">Bdfunc(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">   Bdfunc(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">    Bdfunc()<span class="comment">//不定参数也可以不传参数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Myfunc</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">fmt.Println(a,b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...type不定参数类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Bdfunc</span><span class="params">(a...<span class="keyword">int</span>)</span></span>&#123;<span class="comment">//不定参数函数</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i&lt; <span class="built_in">len</span>(a);i++&#123;</span><br><span class="line">fmt.Print(a[i])<span class="comment">//传多少参数打印多少个</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span> <span class="number">200</span></span><br><span class="line"><span class="number">12345</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><p><strong>不定参数，只能放在形参中的最后一个参数</strong></p><p><strong>不定参数的传递</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">test(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(args ...<span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">test01(args...)<span class="comment">//全部元素传递给test01()函数</span></span><br><span class="line">test01(args[:<span class="number">2</span>]...)<span class="comment">//从args[0]开始，到args[2]结束(不包括args[2])把中间所有元素传递过去</span></span><br><span class="line">    test01(args[<span class="number">2</span>:]...)<span class="comment">//从args[2]开始(包括args[2])，把后面所有元素传递过去</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test01</span><span class="params">(args ...<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> _,data:=<span class="keyword">range</span> args&#123;</span><br><span class="line">fmt.Printf(<span class="string">"%d"</span>,data)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12345</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">345</span></span><br></pre></td></tr></table></figure><h3 id="无参有返回值"><a href="#无参有返回值" class="headerlink" title="无参有返回值"></a>无参有返回值</h3><p><strong>有返回值的参数，<font color="red">必须有明确的终止语句(return语句)</font>，否则会引发编译错误，</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = func1()</span><br><span class="line">fmt.Println(a)</span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">string</span></span><br><span class="line">b,c=func2()</span><br><span class="line">fmt.Println(b,c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//常用推荐写法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func1</span><span class="params">()</span><span class="params">(a <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//也可写为,不推荐</span></span><br><span class="line"><span class="comment">//func func1() int&#123;</span></span><br><span class="line"><span class="comment">//return 1</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func2</span><span class="params">()</span><span class="params">(a <span class="keyword">int</span>,b <span class="keyword">string</span>)</span></span>  &#123;</span><br><span class="line">a=<span class="number">1</span></span><br><span class="line">b=<span class="string">"abc"</span></span><br><span class="line"><span class="keyword">return</span> a,b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//func func2()(int,string)  &#123;</span></span><br><span class="line"><span class="comment">//return 1,"abc"</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span> abc</span><br></pre></td></tr></table></figure><h3 id="有参有返回值"><a href="#有参有返回值" class="headerlink" title="有参有返回值"></a>有参有返回值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">max:=maxfunc(<span class="number">5</span>,<span class="number">10</span>)</span><br><span class="line">fmt.Println(max)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求两数最大值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxfunc</span><span class="params">(a ,b <span class="keyword">int</span>)</span><span class="params">(c <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> a&gt;b &#123;</span><br><span class="line">c=a</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">c=b</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p><strong>递归函数可以直接或间接调用自身</strong><br><strong>递归函数通常有相同的结构:一个跳出条件和一个递归体。所谓跳出条件是根据传入的参数判断是否需要停止递归，而递归体则是函数自身所做的一些处理</strong></p><h3 id="普通函数的调用流程"><a href="#普通函数的调用流程" class="headerlink" title="普通函数的调用流程"></a>普通函数的调用流程</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    a :=funca()<span class="comment">//调用funca()</span></span><br><span class="line">fmt.Println(a)<span class="comment">//4最后执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funca</span><span class="params">()</span><span class="params">(a <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">a=<span class="number">1</span></span><br><span class="line">    b:=funcb()<span class="comment">//调用funcb()</span></span><br><span class="line">fmt.Println(<span class="string">"funca b="</span>,b)<span class="comment">//2</span></span><br><span class="line">fmt.Println(<span class="string">"funca a="</span>,a)<span class="comment">//3</span></span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcb</span><span class="params">()</span><span class="params">(a <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">a=<span class="number">1</span></span><br><span class="line">fmt.Println(<span class="string">"funcb a="</span>,a)<span class="comment">//1</span></span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">funcb a= <span class="number">1</span></span><br><span class="line">funca b= <span class="number">1</span></span><br><span class="line">funca a= <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="递归函数调用流程"><a href="#递归函数调用流程" class="headerlink" title="递归函数调用流程"></a>递归函数调用流程</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">funcjian(<span class="number">10</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcjian</span><span class="params">(a <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line"><span class="keyword">if</span> a == <span class="number">1</span> &#123;<span class="comment">//此条件不成立下面调用函数一直执行，此语句成立时结束调用开始打印</span></span><br><span class="line">fmt.Println(a)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">funcjian(a<span class="number">-1</span>)</span><br><span class="line">fmt.Print(<span class="string">"a="</span>,a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">a=<span class="number">2</span>a=<span class="number">3</span>a=<span class="number">4</span>a=<span class="number">5</span>a=<span class="number">6</span>a=<span class="number">7</span>a=<span class="number">8</span>a=<span class="number">9</span>a=<span class="number">10</span></span><br></pre></td></tr></table></figure><h3 id="数字的累加"><a href="#数字的累加" class="headerlink" title="数字的累加"></a>数字的累加</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="keyword">var</span> aum <span class="keyword">int</span> = sum()</span><br><span class="line">fmt.Println(aum)</span><br><span class="line">sum1 :=sum01(<span class="number">100</span>)</span><br><span class="line">fmt.Println(sum1)</span><br><span class="line">sum2 :=sum02(<span class="number">1</span>)</span><br><span class="line">fmt.Println(sum2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//普通方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">()</span><span class="params">(sum <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i &lt;=<span class="number">100</span> ;i++  &#123;</span><br><span class="line">sum +=i</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum01</span><span class="params">(a <span class="keyword">int</span>)</span><span class="params">(sum <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line"><span class="keyword">if</span> a==<span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a+sum01(a<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum02</span><span class="params">(a <span class="keyword">int</span>)</span><span class="params">(sum <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line"><span class="keyword">if</span> a==<span class="number">100</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a+sum02(a+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果:</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5050</span></span><br><span class="line"><span class="number">5050</span></span><br><span class="line"><span class="number">5050</span></span><br></pre></td></tr></table></figure><h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p><strong>可以通过type给一个函数类型起名，并根据别名声明一个变量</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="keyword">var</span> result <span class="keyword">int</span></span><br><span class="line">result=addd(<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line">fmt.Println(result)</span><br><span class="line"><span class="comment">//声明一个函数类型的变量，变量名叫s</span></span><br><span class="line"><span class="keyword">var</span> sss Functype</span><br><span class="line">sss=addd<span class="comment">//是变量就可以赋值</span></span><br><span class="line">result=sss(<span class="number">10</span>,<span class="number">20</span>)<span class="comment">//等价于addd（10,20）</span></span><br><span class="line">fmt.Println(result)</span><br><span class="line">sss=jian</span><br><span class="line">result=sss(<span class="number">20</span>,<span class="number">10</span>)<span class="comment">//等价于jian(20,10)</span></span><br><span class="line">fmt.Println(result)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数也是一种数据类型，通过type给一个函数类型起名，名字为Functype</span></span><br><span class="line"><span class="keyword">type</span> Functype <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">addd</span><span class="params">(a,b <span class="keyword">int</span>)</span><span class="title">int</span></span>  &#123;</span><br><span class="line"><span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">jian</span><span class="params">(a,b <span class="keyword">int</span>)</span><span class="title">int</span></span>  &#123;</span><br><span class="line"><span class="keyword">return</span> a-b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">30</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="comment">//回调函数。函数参数是函数类型，这个函数就是回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="keyword">var</span> result <span class="keyword">int</span></span><br><span class="line">result = funccc(<span class="number">20</span>,<span class="number">10</span>,jia)</span><br><span class="line">fmt.Println(result)</span><br><span class="line">result = funccc(<span class="number">20</span>,<span class="number">10</span>,jians)</span><br><span class="line">fmt.Println(result)</span><br><span class="line">result = funccc(<span class="number">20</span>,<span class="number">10</span>,cheng)</span><br><span class="line">fmt.Println(result)</span><br><span class="line">result = funccc(<span class="number">20</span>,<span class="number">10</span>,chu)</span><br><span class="line">fmt.Println(result)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> funcType <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span><span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">funccc</span><span class="params">(a,b <span class="keyword">int</span>,fun funcType)</span> <span class="params">(c <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Print(<span class="string">"funccc:"</span>)</span><br><span class="line">c=fun(a,b)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">jia</span><span class="params">(a <span class="keyword">int</span>,b <span class="keyword">int</span>)</span><span class="title">int</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">jians</span><span class="params">(a <span class="keyword">int</span>,b <span class="keyword">int</span>)</span><span class="title">int</span></span>  &#123;</span><br><span class="line"><span class="keyword">return</span> a-b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cheng</span><span class="params">(a <span class="keyword">int</span>,b <span class="keyword">int</span>)</span><span class="title">int</span></span>  &#123;</span><br><span class="line"><span class="keyword">return</span> a*b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chu</span><span class="params">(a <span class="keyword">int</span>,b <span class="keyword">int</span>)</span><span class="title">int</span></span>  &#123;</span><br><span class="line"><span class="keyword">return</span> a/b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">funccc:<span class="number">30</span></span><br><span class="line">funccc:<span class="number">10</span></span><br><span class="line">funccc:<span class="number">200</span></span><br><span class="line">funccc:<span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="匿名函数与闭包"><a href="#匿名函数与闭包" class="headerlink" title="匿名函数与闭包"></a>匿名函数与闭包</h3><p><strong>详解（&lt;<a href="https://blog.csdn.net/lengyuezuixue/article/details/78527667）（" target="_blank" rel="noopener">https://blog.csdn.net/lengyuezuixue/article/details/78527667）（</a><a href="https://www.cnblogs.com/williamjie/p/9875362.html" target="_blank" rel="noopener">https://www.cnblogs.com/williamjie/p/9875362.html</a>）</strong></p><h4 id="匿名函数基本使用"><a href="#匿名函数基本使用" class="headerlink" title="匿名函数基本使用"></a>匿名函数基本使用</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">a:=<span class="number">10</span></span><br><span class="line">str:=<span class="string">"abc"</span></span><br><span class="line"><span class="comment">//匿名函数，没有函数名字</span></span><br><span class="line">f1 := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(a)</span><br><span class="line">fmt.Println(str)</span><br><span class="line">&#125;</span><br><span class="line">f1()</span><br><span class="line">    <span class="comment">//给一个函数类型起别名</span></span><br><span class="line"><span class="keyword">type</span> funcType <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">f2</span> <span class="title">funcType</span></span></span><br><span class="line"><span class="function"><span class="title">f2</span>=<span class="title">f1</span></span></span><br><span class="line"><span class="function"><span class="title">f2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line">abc</span><br><span class="line"><span class="number">10</span></span><br><span class="line">abc</span><br></pre></td></tr></table></figure><h4 id="定义匿名函数同时调用"><a href="#定义匿名函数同时调用" class="headerlink" title="定义匿名函数同时调用"></a>定义匿名函数同时调用</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">a:=<span class="number">10</span></span><br><span class="line">str:=<span class="string">"abc"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(a,str)</span><br><span class="line">&#125;()<span class="comment">//()代表调用此匿名函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> abc</span><br></pre></td></tr></table></figure><h4 id="带参数的匿名函数"><a href="#带参数的匿名函数" class="headerlink" title="带参数的匿名函数"></a>带参数的匿名函数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(i,j <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">fmt.Println(i,j)</span><br><span class="line">&#125;(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="匿名函数有参有返回值"><a href="#匿名函数有参有返回值" class="headerlink" title="匿名函数有参有返回值"></a>匿名函数有参有返回值</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">x,y:=<span class="function"><span class="keyword">func</span><span class="params">(i,j <span class="keyword">int</span>)</span><span class="params">(max,min <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> i&gt;j &#123;</span><br><span class="line">max=i</span><br><span class="line">min=j</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">max=j</span><br><span class="line">min=i</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line">fmt.Println(x,y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;流程控制&quot;&gt;&lt;a href=&quot;#流程控制&quot; class=&quot;headerlink&quot; title=&quot;流程控制&quot;&gt;&lt;/a&gt;流程控制&lt;/h1&gt;&lt;h2 id=&quot;if语句&quot;&gt;&lt;a href=&quot;#if语句&quot; class=&quot;headerlink&quot; title=&quot;if语句&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="go" scheme="https://51461.github.io/blog/categories/go/"/>
    
    
      <category term="-go" scheme="https://51461.github.io/blog/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>学go第二天</title>
    <link href="https://51461.github.io/blog/2019/06/17/go2/"/>
    <id>https://51461.github.io/blog/2019/06/17/go2/</id>
    <published>2019-06-17T10:22:07.000Z</published>
    <updated>2019-06-18T10:35:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="fmt包的格式化输出输入"><a href="#fmt包的格式化输出输入" class="headerlink" title="fmt包的格式化输出输入"></a>fmt包的格式化输出输入</h1><h2 id="fmt包的格式化输出"><a href="#fmt包的格式化输出" class="headerlink" title="fmt包的格式化输出"></a>fmt包的格式化输出</h2><p><strong>摘自(<a href="https://www.cnblogs.com/yinzhengjie/p/7680829.html/" target="_blank" rel="noopener">https://www.cnblogs.com/yinzhengjie/p/7680829.html/</a>)</strong></p><ul><li><strong>常用</strong><br>  %d    表示为十进制<br>  %c    该值对应的unicode码值<br>  %T    值的类型的Go语法表示<br>  %v    使用默认格式输出的内置或者自定义类型的值，或者是使用其类型的String()方法输出自定义值,(如果有的话)</li><li><strong>通用</strong><br>  %v    值的默认格式表示。当输出结构体时，扩展标志（%+v）会添加字段名<br>  %#v   值的Go语法表示<br>  %T    值的类型的Go语法表示<br>  %%    百分号</li><li><strong>布尔值</strong><br>  %t    单词true或false</li><li><strong>整数</strong><br>  %b    表示为二进制<br>  %c    该值对应的unicode码值<br>  %d    表示为十进制<br>  %o    表示为八进制<br>  %q    该值对应的单引号括起来的go语法字符字面值，必要时会采用安全的转义表示<br>  %x    表示为十六进制，使用a-f<br>  %X    表示为十六进制，使用A-F<br>  %U    表示为Unicode格式：U+1234，等价于”U+%04X”</li><li><strong>浮点数、复数的两个组分</strong><br>  %b    无小数部分、二进制指数的科学计数法<br>  %G    根据实际情况采用%E或%F格式（以获得更简洁、准确的输出）</li><li><strong>字符串和[]byte</strong><br>  %s    直接输出字符串或者[]byte %q    该值对应的双引号括起来的go语法字符串字面值，必要时会采用安全的转义表示<br>  %x    每个字节用两字符十六进制数表示（使用a-f）<br>  %X    每个字节用两字符十六进制数表示（使用A-F）</li><li><strong>指针</strong><br>  %p    表示为十六进制，并加上前导的0x<br>  %f:    默认宽度，默认精度<br>  %9f    宽度9，默认精度<br>  %.2f   默认宽度，精度2 %9.2f  宽度9，精度2 %9.f   宽度9，精度0</li><li><strong>其它flag</strong><br>  “+”    总是输出数值的正负号；对%q（%+q）会生成全部是ASCII字符的输出（通过转义）<pre><code>&quot;-&quot;    在输出右边填充空白而不是默认的左边（即从默认的右对齐切换为左对齐）</code></pre>  #切换格式<br>  八进制数前加0（%#o），十六进制数前加0x（%#x）或0X（%#X），指针去掉前面的0x（%#p）；<br>  对%q（%#q），如果strconv.CanBackquote返回真会输出反引号括起来的未转义字符串；<br>  对%U（%#U），如果字符是可打印的，会在输出Unicode格式、空格、单引号括起来的go字面值；<br>  ‘ ‘    对数值，正数前加空格而负数前加负号；<br>  对字符串采用%x或%X时（% x或% X）会给各打印的字节之间加空格；<br>  0    使用0而不是空格填充，对于数值类型会把填充的0放在正负号后面；<br>verb会忽略不支持的flag。例如，因为没有十进制切换模式，所以%#d和%d的输出是相同的。</li></ul><p><strong>对每一个类似Printf的函数，都有对应的Print型函数，该函数不接受格式字符串，就效果上等价于对每一个参数都是用verb %v。另一个变体Println型函数会在各个操作数的输出之间加空格并在最后换行</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">a:=<span class="number">10</span></span><br><span class="line">b:=<span class="string">"asd"</span></span><br><span class="line">c:=<span class="string">'a'</span></span><br><span class="line">d:=<span class="number">3.14</span></span><br><span class="line">fmt.Printf(<span class="string">"%T,%T,%T,%T\n"</span>,a,b,c,d)<span class="comment">//%T操作变量所属类型</span></span><br><span class="line"><span class="comment">//%d 整型格式%s 字符串格式%c 字符格式%f 浮点格式</span></span><br><span class="line">fmt.Printf(<span class="string">"a=%d,b=%s,c=%c,d=%f\n"</span>,a,b,c,d)</span><br><span class="line">fmt.Printf(<span class="string">"a=%v,b=%v,c=%v,d=%v\n"</span>,a,b,c,d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="../../../../images/gshsc.png" alt="运行结果"></p><h2 id="变量的输入"><a href="#变量的输入" class="headerlink" title="变量的输入"></a>变量的输入</h2><p><strong>fmt.Scanf()必须要输入正确的格式</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span></span><br><span class="line">fmt.Printf(<span class="string">"请输入变量a:"</span>)</span><br><span class="line"><span class="comment">//fmt.Scanf("%d",&amp;a)</span></span><br><span class="line">fmt.Scan(&amp;a)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p><strong>golang中不允许隐式转换，所有类型转换必须显式声明，而且转换只能发生在两种相互兼容的类型之间</strong><br>布尔类型和整型不兼容</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="keyword">var</span> flag <span class="keyword">bool</span></span><br><span class="line">flag=<span class="literal">true</span></span><br><span class="line">fmt.Printf(<span class="string">"flag=%t\n"</span>,flag)</span><br><span class="line"><span class="comment">//bool类型不能转换为整型</span></span><br><span class="line"><span class="comment">//fmt.Printf("flag=%d\n",int(flag))</span></span><br><span class="line"><span class="comment">//整型也不能转换为bool</span></span><br><span class="line"><span class="comment">//flag=bool(1)</span></span><br><span class="line"><span class="keyword">var</span> ch <span class="keyword">byte</span></span><br><span class="line">ch=<span class="string">'a'</span></span><br><span class="line"><span class="keyword">var</span> t <span class="keyword">int</span></span><br><span class="line">t=<span class="keyword">int</span>(ch)<span class="comment">//byte转int</span></span><br><span class="line">fmt.Printf(<span class="string">"t="</span>,t)</span><br><span class="line">fmt.Println()</span><br><span class="line">fmt.Println(ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p><strong>type关键字(可以为变量类型更改一个名字)</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="keyword">type</span> bigint <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">var</span> a bigint</span><br><span class="line">fmt.Printf(<span class="string">"a = %T\n"</span>,a)</span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">long <span class="keyword">int64</span></span><br><span class="line">char <span class="keyword">byte</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> b long = <span class="number">11</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">byte</span> = <span class="string">'a'</span></span><br><span class="line">fmt.Printf(<span class="string">"%d ,%s\n"</span>,b,c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p><strong>详细使用实例(<a href="https://blog.csdn.net/ahaotata/article/details/84316528" target="_blank" rel="noopener">https://blog.csdn.net/ahaotata/article/details/84316528</a>)</strong></p><h2 id="数学运算符"><a href="#数学运算符" class="headerlink" title="数学运算符"></a>数学运算符</h2><p><strong>“+”        加</strong><br><strong>“-“        减</strong><br><strong>“*”        乘</strong><br><strong>“/“        除</strong><br><strong>“%”        取模(取余)</strong><br><strong>“++”    后自增(没有前自增)</strong><br><strong>“- -“    后自减(没有前自减)</strong></p><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p><strong>“==”    判断相等</strong><br><strong>“!=”    不相等</strong><br><strong>“&lt;”    小于</strong><br><strong>“&gt;”    大于</strong><br><strong>“&lt;=”    小于等于</strong><br><strong>“&gt;=”    大于等于</strong></p><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p><strong>“!”    非,取反</strong><br><strong>“&amp;&amp;”    与,同真为真</strong><br><strong>“||”    或,有一个为真为真</strong></p><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p><strong>“&amp;”    按位与,参与运算的两数各对应的二进位相与(加)</strong><br><strong>“|”    按位或,参与运算的两数各对应的二进位相或(有1取1)</strong><br><strong>“^”    异或,参与运算的两数各对应的二进位相异或(两数不同得1)</strong><br><strong>“&lt;&lt;”    左移,左移n位=乘以2的n次方，左边丢弃，右边补0</strong><br><strong>“&gt;&gt;”    右移,右移n位=除以2的n次方，右侧丢弃左边补0</strong></p><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p><strong>“=”    普通赋值</strong><br><strong>“+=”    相加后再赋值(a+=1等于a=a+1)</strong><br><strong>“-=”    相减后再赋值(a-=1等于a=a-1)</strong><br><strong>“*=”    相乘后再赋值(a*=2等于a=a*2)</strong><br><strong>“/=”    相除后再赋值(a/=2等于a=a/2)</strong><br><strong>“%=”    取模后再赋值(a%=2等于a=a%2)</strong><br><strong>“&lt;&lt;=”    左移后再赋值(a&lt;&lt;=2等于a=a&lt;&lt;2)</strong><br><strong>“&gt;&gt;=”    右移后再赋值(a&gt;&gt;=2等于a=a&gt;&gt;2)</strong><br><strong>“&amp;=”    按位与后再赋值(a&amp;=2等于a=a&amp;2)</strong><br><strong>“^=”    按位与后再赋值(a^=2等于a=a^2)</strong><br><strong>“|=”    按位或后再赋值(a|=2等于a=a|2)</strong></p><h2 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h2><p><strong>“&amp;”    取地址运算符(&amp;a=变量a的地址)</strong><br><strong>“*”    取值运算符(*a=指针变量a所指向内存的值)</strong><br><strong>使用示例：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">fmt.Println(<span class="string">"1&gt;2"</span>,<span class="number">1</span>&gt;<span class="number">2</span>)</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span>=<span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> ptr *<span class="keyword">int</span></span><br><span class="line">ptr=&amp;a</span><br><span class="line">fmt.Printf(<span class="string">"a 的值为  %d\n"</span>, a);</span><br><span class="line">fmt.Println(&amp;a)</span><br><span class="line">fmt.Printf(<span class="string">"*ptr 为 %d\n"</span>, *ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>&gt;<span class="number">2</span> <span class="literal">false</span></span><br><span class="line">a 的值为  <span class="number">10</span></span><br><span class="line"><span class="number">0xc00004c088</span></span><br><span class="line">*ptr 为 <span class="number">10</span></span><br></pre></td></tr></table></figure><h2 id="运算符优先级-https-www-sojson-com-operation-go-html"><a href="#运算符优先级-https-www-sojson-com-operation-go-html" class="headerlink" title="运算符优先级(https://www.sojson.com/operation/go.html)"></a>运算符优先级(<a href="https://www.sojson.com/operation/go.html" target="_blank" rel="noopener">https://www.sojson.com/operation/go.html</a>)</h2><p><img src="https://img-blog.csdnimg.cn/20181121115159889.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FoYW90YXRh,size_16,color_FFFFFF,t_70" alt="图片"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;fmt包的格式化输出输入&quot;&gt;&lt;a href=&quot;#fmt包的格式化输出输入&quot; class=&quot;headerlink&quot; title=&quot;fmt包的格式化输出输入&quot;&gt;&lt;/a&gt;fmt包的格式化输出输入&lt;/h1&gt;&lt;h2 id=&quot;fmt包的格式化输出&quot;&gt;&lt;a href=&quot;#fmt
      
    
    </summary>
    
      <category term="go" scheme="https://51461.github.io/blog/categories/go/"/>
    
    
      <category term="-go" scheme="https://51461.github.io/blog/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>学go第一天</title>
    <link href="https://51461.github.io/blog/2019/06/16/go1/"/>
    <id>https://51461.github.io/blog/2019/06/16/go1/</id>
    <published>2019-06-16T09:10:58.000Z</published>
    <updated>2019-06-18T10:34:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="go的环境配置"><a href="#go的环境配置" class="headerlink" title="go的环境配置"></a>go的环境配置</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- <span class="number">1.</span>golang下载(https:<span class="comment">//studygolang.com/dl)</span></span><br><span class="line">- <span class="number">2.</span>环境变量配置</span><br><span class="line">GOROOT：Go 安装后的根目录（例如：D:\Go），安装过程中会由安装程序自动写入系统环境变量中。</span><br><span class="line">GOBIN：Go 的二进制文件存放目录（%GOROOT%\bin）</span><br><span class="line">PATH：需要将 %GOBIN% 加在 PATH 变量的最后，方便在命令行下运行。</span><br><span class="line"><span class="number">-3.</span>Go 工作空间</span><br><span class="line">GOPATH :Go 的工作空间，就是我们的开发和依赖包的目录,例如(D:\abc\GO)</span><br><span class="line">注意：不要把 GOPATH 设置成 Go 的安装路径</span><br><span class="line">-配置好之后，通过 <span class="keyword">go</span> env 命令来查看<span class="keyword">go</span>环境是否配置正确，如下图</span><br></pre></td></tr></table></figure><p><img src="../../../../images/goenv.jpg" alt="图片"></p><h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="comment">//入口函数main()</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Hello World!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的程序保存成 helloworld.go，然后在文件地址栏输入cmd回车执行或者可以右键Git bash执行：<br><code>go run helloworld.go</code><br>运行结果</p><h2 id><a href="#" class="headerlink" title></a><img src="../../../../images/Helloword.png" alt="图片"></h2><h2 id="Golang标准库文档-https-studygolang-com-pkgdoc"><a href="#Golang标准库文档-https-studygolang-com-pkgdoc" class="headerlink" title="Golang标准库文档(https://studygolang.com/pkgdoc)"></a>Golang标准库文档(<a href="https://studygolang.com/pkgdoc" target="_blank" rel="noopener">https://studygolang.com/pkgdoc</a>)</h2><hr><h2 id="golang数据类型"><a href="#golang数据类型" class="headerlink" title="golang数据类型"></a>golang数据类型</h2><p><strong>数据类型作用：告诉编译器这个变量应该占用多大内存</strong><br>数据类型用于声明函数和变量。数据类型的出现是为了把数据分成所需内存大小不同的数据，编程的时候需要用大数据的时候才需要申请大内存，就可以充分利用内存。</p><ul><li>整型<pre><code>uint8:      无符号 8 位整型 (0 到 255)uint16:     无符号 16 位整型 (0 到 65535)uint32:     无符号 32 位整型 (0 到 4294967295)uint64:     无符号 64 位整型 (0 到 18446744073709551615)int8:         有符号 8 位整型 (-128 到 127)int16:        有符号 16 位整型 (-32768 到 32767)int32:         有符号 32 位整型 (-2147483648 到 2147483647)int64:         有符号 64 位整型 (-9223372036854775808 到 9223372036854775807)</code></pre></li><li>浮点型    <pre><code>float32:       IEEE-754 32位浮点型数float64:       IEEE-754 64位浮点型数complex64:     32 位实数和虚数complex128:  64 位实数和虚数</code></pre></li></ul><h2 id="变量命名规范"><a href="#变量命名规范" class="headerlink" title="变量命名规范"></a>变量命名规范</h2><pre><code>- 1）字母，下划线，数字- 2）不能以数字开头- 3）不能以关键字命名- 4）要区分大小写</code></pre><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><p><strong>变量，程序运行期间可以改变的量，关键字var</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//var(关键字) a(变量名) int(变量类型) </span></span><br><span class="line"><span class="comment">//var(关键字) a(变量名),b(变量名) int(变量类型)</span></span><br><span class="line"><span class="comment">//根据赋值自动推导变量类型，注同一个变量只能使用一次</span></span><br><span class="line">c := <span class="number">30</span></span><br><span class="line"><span class="comment">//打印变量c类型的函数</span></span><br><span class="line">fmt.Printf(<span class="string">"c type is %T\n"</span>,c)</span><br></pre></td></tr></table></figure><p><strong>注：变量声明之后必须引用，不然会报错</strong></p><h2 id="Println和Printf的区别"><a href="#Println和Printf的区别" class="headerlink" title="Println和Printf的区别"></a>Println和Printf的区别</h2><p>一个小例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">a,b,c :=<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span></span><br><span class="line">fmt.Println(<span class="string">"a="</span>,a,<span class="string">",b="</span>,b,<span class="string">"c="</span>,c)</span><br><span class="line">fmt.Printf(<span class="string">"a= %d,b= %d,c= %d\n"</span>,a,b,c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果都是<strong>a= 10 ,b= 20 c= 30</strong>但明显用<strong>Printf</strong>格式更好控制</p><h2 id="多重赋值和匿名变量"><a href="#多重赋值和匿名变量" class="headerlink" title="多重赋值和匿名变量"></a>多重赋值和匿名变量</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a:=10 b:=20 c:=30</span></span><br><span class="line"><span class="string">`a,b,c :=10,20,30`</span></span><br><span class="line"><span class="comment">//交换a,b变量的值</span></span><br><span class="line"><span class="comment">//传统方式</span></span><br><span class="line">c=a</span><br><span class="line">a=b</span><br><span class="line">b=c</span><br><span class="line"><span class="comment">//go的方式</span></span><br><span class="line">a,b,c=c,b,a</span><br><span class="line"><span class="comment">//_匿名变量，丢弃不处理，_匿名变量配合函数返回值使用，才有优势（go函数可以返回多个值）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span><span class="params">(a,b,c <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="keyword">var</span> e,f,g <span class="keyword">int</span></span><br><span class="line">e,f,g=test()</span><br><span class="line">fmt.Printf(<span class="string">"e= %d,f= %d,g= %d\n"</span>,e,f,g)</span><br><span class="line"><span class="comment">//如果不想要2,可以用匿名变量把2替换掉</span></span><br><span class="line">e,_,g=test()</span><br><span class="line">fmt.Printf(<span class="string">"e= %d,f= %d,g= %d\n"</span>,e,f,g)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p><strong>常量在程序运行期间不可改变，关键字const</strong><br>常量声明以后不可以再赋值<br>常量的类型推导</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a =<span class="number">10.2</span></span><br><span class="line">fmt.Printf(<span class="string">"a=%T/n"</span>,a)</span><br></pre></td></tr></table></figure><h2 id="多个变量-常量的定义"><a href="#多个变量-常量的定义" class="headerlink" title="多个变量/常量的定义"></a>多个变量/常量的定义</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">a <span class="keyword">int</span></span><br><span class="line">b <span class="keyword">float64</span></span><br><span class="line">c <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line">a,b,c=<span class="number">10</span>,<span class="number">10.1</span>,<span class="string">"20"</span></span><br><span class="line">fmt.Println(a,b,c)</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line"><span class="comment">//类型可以省略</span></span><br><span class="line">i <span class="keyword">int</span>=<span class="number">10</span></span><br><span class="line">j <span class="keyword">float64</span>=<span class="number">10.23</span></span><br><span class="line">) </span><br><span class="line">fmt.Println(i,j)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举iota"><a href="#枚举iota" class="headerlink" title="枚举iota"></a>枚举iota</h2><ul><li><strong>iota常量自动生成器，每换一行自动加1</strong></li><li><strong>iota给常量赋值</strong></li><li><strong>iota遇到const重置为0</strong></li><li><strong>可以只写一个iota</strong></li><li><strong>如果是同一行，值都一样</strong><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">a=<span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">b=<span class="literal">iota</span> <span class="comment">//1</span></span><br><span class="line">c=<span class="literal">iota</span> <span class="comment">//2</span></span><br><span class="line">)</span><br><span class="line">fmt.Println(a,b,c)</span><br><span class="line"><span class="keyword">const</span> d=<span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">fmt.Println(d)</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">a1=<span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">b1<span class="comment">//1</span></span><br><span class="line">c1 <span class="comment">//2</span></span><br><span class="line">)</span><br><span class="line">fmt.Println(a1,b1,c1)</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">i=<span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">j1,j2,j3=<span class="literal">iota</span>,<span class="literal">iota</span>,<span class="literal">iota</span> <span class="comment">//1</span></span><br><span class="line">k=<span class="literal">iota</span> <span class="comment">//2</span></span><br><span class="line">)</span><br><span class="line">fmt.Println(i,j1,j2,j3,k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><ul><li>bool  布尔类型  初始为false  长度1</li><li>byte  字节型    初始为0      长度1=uint8</li><li>rune  字符类型  0  长度4=uint32</li><li>int uint 整型 0 长度4/8 （uint表示无符号）</li><li>int8,uint8 整型 0 长度1 </li><li>int16,uint16 整型 0 长度2 </li><li>int32,uint32 整型 0 长度4</li><li>int64,uint64 整型 0 长度8</li><li>float32 浮点型 长度4</li><li>float64 浮点型 长度8</li><li>complex64 复数类型 长度8   (10+20i) 不常用</li><li>complex128 复数类型 长度16</li><li>uintptr 整型 长度4或8</li><li>string 字符串 utf-8字符串</li></ul><h2 id="复数类型"><a href="#复数类型" class="headerlink" title="复数类型"></a>复数类型</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> t <span class="keyword">complex64</span> <span class="comment">//声明</span></span><br><span class="line">t=<span class="number">2.1</span>+<span class="number">3.14i</span>   <span class="comment">//赋值</span></span><br><span class="line">fmt.Println(t)</span><br><span class="line">t1:=<span class="number">2.1</span>+<span class="number">3.14i</span></span><br><span class="line">fmt.Printf(<span class="string">"t= %T\n"</span>,t1)</span><br><span class="line">fmt.Println(<span class="built_in">real</span>(t1)) <span class="comment">//实部</span></span><br><span class="line">fmt.Println(<span class="built_in">imag</span>(t1)) <span class="comment">//虚部</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;go的环境配置&quot;&gt;&lt;a href=&quot;#go的环境配置&quot; class=&quot;headerlink&quot; title=&quot;go的环境配置&quot;&gt;&lt;/a&gt;go的环境配置&lt;/h1&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gu
      
    
    </summary>
    
      <category term="go" scheme="https://51461.github.io/blog/categories/go/"/>
    
    
      <category term="-go" scheme="https://51461.github.io/blog/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>第一篇文章</title>
    <link href="https://51461.github.io/blog/2019/06/15/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
    <id>https://51461.github.io/blog/2019/06/15/第一篇文章/</id>
    <published>2019-06-15T07:52:26.000Z</published>
    <updated>2019-06-18T04:38:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>测试文章</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Hello-World&quot;&gt;&lt;a href=&quot;#Hello-World&quot; class=&quot;headerlink&quot; title=&quot;Hello World&quot;&gt;&lt;/a&gt;Hello World&lt;/h2&gt;&lt;p&gt;测试文章&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="-测试" scheme="https://51461.github.io/blog/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://51461.github.io/blog/2019/06/15/hello-world/"/>
    <id>https://51461.github.io/blog/2019/06/15/hello-world/</id>
    <published>2019-06-15T02:53:50.000Z</published>
    <updated>2019-06-15T02:53:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>Hello World</p><a id="more"></a><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hello World&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello-world</title>
    <link href="https://51461.github.io/blog/2019/06/15/Hello-world-0/"/>
    <id>https://51461.github.io/blog/2019/06/15/Hello-world-0/</id>
    <published>2019-06-15T02:11:39.000Z</published>
    <updated>2019-06-18T04:38:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><h2 id="快乐就完事了"><a href="#快乐就完事了" class="headerlink" title="快乐就完事了"></a>快乐就完事了</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><ul><li>列表1</li><li>列表2<br>  a 子列表<br>  b 子列表</li><li>列表3</li></ul><hr><h2 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h2><p><a href="https://blog.gpdstudy.club/" target="_blank" rel="noopener">冒泡大佬</a><br><img src="http://img3.imgtn.bdimg.com/it/u=1905452358,4132262221&fm=26&gp=0.jpg" alt="图片"><br><em>你看我直不</em><br><strong>你看我细不</strong><br><code>&lt;html&gt;&lt;/html&gt;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;我是标题&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;我是一级标题&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><blockquote><p>我的内容是引用的哦</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hello-World&quot;&gt;&lt;a href=&quot;#Hello-World&quot; class=&quot;headerlink&quot; title=&quot;Hello World&quot;&gt;&lt;/a&gt;Hello World&lt;/h1&gt;&lt;h2 id=&quot;快乐就完事了&quot;&gt;&lt;a href=&quot;#快乐就完事了&quot; cla
      
    
    </summary>
    
      <category term="前端" scheme="https://51461.github.io/blog/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="导航" scheme="https://51461.github.io/blog/tags/%E5%AF%BC%E8%88%AA/"/>
    
      <category term="分享" scheme="https://51461.github.io/blog/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
</feed>
